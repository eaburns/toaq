// FreeSans has all the glyphs used in this file.
// For Acme users:
// Font /mnt/font/FreeSans/11a/font

package parse

import "github.com/eaburns/peggy/peg"

const (
	_full_text                                         int = 0
	_text                                              int = 1
	_discourse                                         int = 2
	_sentence                                          int = 3
	_sentence_1                                        int = 4
	_sentence_2                                        int = 5
	_sentence_3                                        int = 6
	_fragment                                          int = 7
	_coP_sentence                                      int = 8
	_co_bar_sentence                                   int = 9
	_forethought_coP_sentence                          int = 10
	_forethought_coP_sentence_1                        int = 11
	_forethought_co_bar_sentence                       int = 12
	_sentence_prefix                                   int = 13
	_statement                                         int = 14
	_statement_1                                       int = 15
	_statement_2                                       int = 16
	_statement_3                                       int = 17
	_end_statement                                     int = 18
	_prenex                                            int = 19
	_predication                                       int = 20
	_coP_statement                                     int = 21
	_co_bar_statement                                  int = 22
	_forethought_coP_statement                         int = 23
	_forethought_coP_statement_1                       int = 24
	_forethought_co_bar_statement                      int = 25
	_predicate                                         int = 26
	_predicate_1                                       int = 27
	_predicate_2                                       int = 28
	_predicate_3                                       int = 29
	_predicate_4                                       int = 30
	_serial_predicate                                  int = 31
	_serial_predicate_2                                int = 32
	_coP_pred                                          int = 33
	_co_bar_pred                                       int = 34
	_forethought_coP_pred                              int = 35
	_forethought_coP_pred_1                            int = 36
	_forethought_co_bar_pred                           int = 37
	_LU_predicate                                      int = 38
	_LU_predicate_tone                                 int = 39
	_MI_predicate                                      int = 40
	_MI_predicate_1                                    int = 41
	_MI_predicate_tone                                 int = 42
	_PO_predicate                                      int = 43
	_PO_predicate_1                                    int = 44
	_PO_predicate_tone                                 int = 45
	_quotation_predicate                               int = 46
	_MO_predicate                                      int = 47
	_MO_predicate_tone                                 int = 48
	_terms                                             int = 49
	_terms_2                                           int = 50
	_term                                              int = 51
	_argument                                          int = 52
	_arg_1                                             int = 53
	_arg_2                                             int = 54
	_arg_3                                             int = 55
	_arg_4                                             int = 56
	_arg_5                                             int = 57
	_arg_6                                             int = 58
	_arg_7                                             int = 59
	_serial_argument                                   int = 60
	_coP_arg                                           int = 61
	_co_bar_arg                                        int = 62
	_forethought_coP_arg                               int = 63
	_forethought_coP_arg_1                             int = 64
	_forethought_co_bar_arg                            int = 65
	_coP_pred_arg                                      int = 66
	_forethought_coP_pred_arg                          int = 67
	_forethought_coP_pred_arg_1                        int = 68
	_LU_arg                                            int = 69
	_LU_arg_tone                                       int = 70
	_MI_arg                                            int = 71
	_MI_arg_1                                          int = 72
	_MI_arg_tone                                       int = 73
	_PO_arg                                            int = 74
	_PO_arg_1                                          int = 75
	_PO_arg_tone                                       int = 76
	_quotation_argument                                int = 77
	_MO_argument                                       int = 78
	_MO_argument_tone                                  int = 79
	_relative_clause                                   int = 80
	_relative_clause_1                                 int = 81
	_relative_clause_2                                 int = 82
	_relative_clause_3                                 int = 83
	_relative_predication                              int = 84
	_coP_rel_statement                                 int = 85
	_coP_rel                                           int = 86
	_co_bar_rel                                        int = 87
	_forethought_coP_rel                               int = 88
	_forethought_coP_rel_1                             int = 89
	_forethought_co_bar_rel                            int = 90
	_relative_predicate                                int = 91
	_relative_predicate_1                              int = 92
	_relative_predicate_2                              int = 93
	_relative_predicate_3                              int = 94
	_serial_relative_predicate                         int = 95
	_coP_pred_relative_predicate                       int = 96
	_forethought_coP_pred_relative_predicate           int = 97
	_forethought_coP_pred_relative_predicate_1         int = 98
	_LU_relative                                       int = 99
	_LU_relative_tone                                  int = 100
	_MI_relative_predicate                             int = 101
	_MI_relative_predicate_1                           int = 102
	_MI_relative_predicate_tone                        int = 103
	_PO_relative_predicate                             int = 104
	_PO_relative_predicate_1                           int = 105
	_PO_relative_predicate_tone                        int = 106
	_quotation_relative_predicate                      int = 107
	_MO_relative_predicate                             int = 108
	_MO_relative_predicate_tone                        int = 109
	_termset                                           int = 110
	_termset_II                                        int = 111
	_forethought_coP_term_II                           int = 112
	_forethought_co_bar_term_II                        int = 113
	_termset_III                                       int = 114
	_forethought_coP_term_III                          int = 115
	_forethought_co_bar_term_III                       int = 116
	_termset_IV                                        int = 117
	_forethought_coP_term_IV                           int = 118
	_forethought_co_bar_term_IV                        int = 119
	_termset_V                                         int = 120
	_forethought_coP_term_V                            int = 121
	_forethought_co_bar_term_V                         int = 122
	_forethought_connective                            int = 123
	_forethought_marker                                int = 124
	_gik                                               int = 125
	_terms_II                                          int = 126
	_terms_III                                         int = 127
	_terms_IV                                          int = 128
	_terms_V                                           int = 129
	_adverb                                            int = 130
	_adverb_1                                          int = 131
	_adverb_2                                          int = 132
	_adverb_3                                          int = 133
	_adverb_4                                          int = 134
	_coP_adverb                                        int = 135
	_co_bar_adverb                                     int = 136
	_forethought_coP_adverb                            int = 137
	_forethought_coP_adverb_1                          int = 138
	_forethought_co_bar_adverb                         int = 139
	_serial_adverb                                     int = 140
	_coP_pred_adverb                                   int = 141
	_forethought_coP_pred_adverb                       int = 142
	_forethought_coP_pred_adverb_1                     int = 143
	_LU_adverb                                         int = 144
	_LU_adverb_tone                                    int = 145
	_MI_adverb                                         int = 146
	_MI_adverb_1                                       int = 147
	_MI_adverb_tone                                    int = 148
	_PO_adverb                                         int = 149
	_PO_adverb_1                                       int = 150
	_PO_adverb_tone                                    int = 151
	_quotation_adverb                                  int = 152
	_MO_adverb                                         int = 153
	_MO_adverb_tone                                    int = 154
	_prepositional_phrase                              int = 155
	_prepositional_phrase_1                            int = 156
	_prepositional_phrase_2                            int = 157
	_coP_prepositional_phrase                          int = 158
	_co_bar_prepositional_phrase                       int = 159
	_forethought_coP_prepositional_phrase              int = 160
	_forethought_coP_prepositional_phrase_1            int = 161
	_forethought_co_bar_prepositional_phrase           int = 162
	_preposition                                       int = 163
	_preposition_1                                     int = 164
	_preposition_2                                     int = 165
	_preposition_3                                     int = 166
	_preposition_4                                     int = 167
	_coP_preposition                                   int = 168
	_co_bar_preposition                                int = 169
	_forethought_coP_preposition                       int = 170
	_forethought_coP_preposition_1                     int = 171
	_forethought_co_bar_preposition                    int = 172
	_serial_preposition                                int = 173
	_coP_pred_preposition                              int = 174
	_forethought_coP_pred_preposition                  int = 175
	_forethought_coP_pred_preposition_1                int = 176
	_LU_preposition                                    int = 177
	_LU_preposition_tone                               int = 178
	_MI_preposition                                    int = 179
	_MI_preposition_1                                  int = 180
	_MI_preposition_tone                               int = 181
	_PO_preposition                                    int = 182
	_PO_preposition_1                                  int = 183
	_PO_preposition_tone                               int = 184
	_quotation_preposition                             int = 185
	_MO_preposition                                    int = 186
	_MO_preposition_tone                               int = 187
	_content_clause                                    int = 188
	_content_clause_1                                  int = 189
	_content_predication                               int = 190
	_coP_content_statement                             int = 191
	_content_predicate                                 int = 192
	_content_predicate_1                               int = 193
	_content_predicate_2                               int = 194
	_content_predicate_3                               int = 195
	_serial_content_predicate                          int = 196
	_coP_pred_content_predicate                        int = 197
	_forethought_coP_pred_content_predicate            int = 198
	_forethought_coP_pred_content_predicate_1          int = 199
	_LU_content                                        int = 200
	_LU_content_tone                                   int = 201
	_MI_content_predicate                              int = 202
	_MI_content_predicate_1                            int = 203
	_MI_content_tone                                   int = 204
	_PO_content_predicate                              int = 205
	_PO_content_predicate_1                            int = 206
	_PO_content_tone                                   int = 207
	_quotation_content_predicate                       int = 208
	_MO_content_predicate                              int = 209
	_MO_content_predicate_tone                         int = 210
	_freemod                                           int = 211
	_parenthetical                                     int = 212
	_parenthetical_1                                   int = 213
	_incidental                                        int = 214
	_vocative                                          int = 215
	_prefix                                            int = 216
	_focus                                             int = 217
	_function_word                                     int = 218
	_LU                                                int = 219
	_MI                                                int = 220
	_PO                                                int = 221
	_MO                                                int = 222
	_TEO                                               int = 223
	_GA                                                int = 224
	_NA                                                int = 225
	_MU                                                int = 226
	_KU                                                int = 227
	_end_prenex                                        int = 228
	_start_incidental                                  int = 229
	_start_parenthetical                               int = 230
	_end_parenthetical                                 int = 231
	_vocative_marker                                   int = 232
	_linking_word                                      int = 233
	_connective                                        int = 234
	_illocutionary                                     int = 235
	_quantifier                                        int = 236
	_interjection                                      int = 237
	_syllable__compound_desinence__compound_tone       int = 238
	_syllable__arg_desinence__arg_tone                 int = 239
	_syllable__relative_desinence__relative_tone       int = 240
	_syllable__verb_desinence__verb_tone               int = 241
	_syllable__content_desinence__content_tone         int = 242
	_syllable__preposition_desinence__preposition_tone int = 243
	_syllable__adverb_desinence__adverb_tone           int = 244
	_neutral_syllable                                  int = 245
	_compound_syllable                                 int = 246
	_arg_syllable                                      int = 247
	_relative_syllable                                 int = 248
	_verb_syllable                                     int = 249
	_content_syllable                                  int = 250
	_preposition_syllable                              int = 251
	_adverb_syllable                                   int = 252
	_boundary                                          int = 253
	_initial                                           int = 254
	_desinence__a__u__i__o__e                          int = 255
	_desinence__ā__ū__ī__ō__ē                          int = 256
	_desinence__á__ú__í__ó__é                          int = 257
	_desinence__ǎ__ǔ__ǐ__ǒ__ě                          int = 258
	_desinence__ả__ủ__ỉ__ỏ__ẻ                          int = 259
	_desinence__â__û__î__ô__ê                          int = 260
	_desinence__à__ù__ì__ò__è                          int = 261
	_desinence__ã__ũ__ĩ__õ__ẽ                          int = 262
	_neutral_desinence                                 int = 263
	_compound_desinence                                int = 264
	_arg_desinence                                     int = 265
	_relative_desinence                                int = 266
	_verb_desinence                                    int = 267
	_content_desinence                                 int = 268
	_preposition_desinence                             int = 269
	_adverb_desinence                                  int = 270
	_tone                                              int = 271
	_A                                                 int = 272
	_U                                                 int = 273
	_I                                                 int = 274
	_O                                                 int = 275
	_E                                                 int = 276
	_ā                                                 int = 277
	_ū                                                 int = 278
	_ī                                                 int = 279
	_ō                                                 int = 280
	_ē                                                 int = 281
	_macron_combiner                                   int = 282
	_compound_tone                                     int = 283
	_á                                                 int = 284
	_ú                                                 int = 285
	_í                                                 int = 286
	_ó                                                 int = 287
	_é                                                 int = 288
	_acute_combiner                                    int = 289
	_arg_tone                                          int = 290
	_ǎ                                                 int = 291
	_ǔ                                                 int = 292
	_ǐ                                                 int = 293
	_ǒ                                                 int = 294
	_ě                                                 int = 295
	_caron_combiner                                    int = 296
	_breve_combiner                                    int = 297
	_relative_tone                                     int = 298
	_ả                                                 int = 299
	_ủ                                                 int = 300
	_ỉ                                                 int = 301
	_ỏ                                                 int = 302
	_ẻ                                                 int = 303
	_hook_combiner                                     int = 304
	_verb_tone                                         int = 305
	_â                                                 int = 306
	_û                                                 int = 307
	_î                                                 int = 308
	_ô                                                 int = 309
	_ê                                                 int = 310
	_circumflex_combiner                               int = 311
	_content_tone                                      int = 312
	_à                                                 int = 313
	_ù                                                 int = 314
	_ì                                                 int = 315
	_ò                                                 int = 316
	_è                                                 int = 317
	_grave_combiner                                    int = 318
	_preposition_tone                                  int = 319
	_ã                                                 int = 320
	_ũ                                                 int = 321
	_ĩ                                                 int = 322
	_õ                                                 int = 323
	_ẽ                                                 int = 324
	_tilde_combiner                                    int = 325
	_adverb_tone                                       int = 326
	_a                                                 int = 327
	_b                                                 int = 328
	_c                                                 int = 329
	_d                                                 int = 330
	_e                                                 int = 331
	_f                                                 int = 332
	_g                                                 int = 333
	_h                                                 int = 334
	_i                                                 int = 335
	_j                                                 int = 336
	_k                                                 int = 337
	_l                                                 int = 338
	_m                                                 int = 339
	_n                                                 int = 340
	_o                                                 int = 341
	_p                                                 int = 342
	_q                                                 int = 343
	_r                                                 int = 344
	_s                                                 int = 345
	_t                                                 int = 346
	_u                                                 int = 347
	_w                                                 int = 348
	_y                                                 int = 349
	_spaces                                            int = 350
	_EOF                                               int = 351

	_N int = 352
)

type _Parser struct {
	text     string
	deltaPos [][_N]int32
	deltaErr [][_N]int32
	node     map[_key]*peg.Node
	fail     map[_key]*peg.Fail
	act      map[_key]interface{}
	lastFail int
	data     interface{}
}

type _key struct {
	start int
	rule  int
}

func _NewParser(text string) *_Parser {
	return &_Parser{
		text:     text,
		deltaPos: make([][_N]int32, len(text)+1),
		deltaErr: make([][_N]int32, len(text)+1),
		node:     make(map[_key]*peg.Node),
		fail:     make(map[_key]*peg.Fail),
		act:      make(map[_key]interface{}),
	}
}

func _max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func _memoize(parser *_Parser, rule, start, pos, perr int) (int, int) {
	parser.lastFail = perr
	derr := perr - start
	parser.deltaErr[start][rule] = int32(derr + 1)
	if pos >= 0 {
		dpos := pos - start
		parser.deltaPos[start][rule] = int32(dpos + 1)
		return dpos, derr
	}
	parser.deltaPos[start][rule] = -1
	return -1, derr
}

func _memo(parser *_Parser, rule, start int) (int, int, bool) {
	dp := parser.deltaPos[start][rule]
	if dp == 0 {
		return 0, 0, false
	}
	if dp > 0 {
		dp--
	}
	de := parser.deltaErr[start][rule] - 1
	return int(dp), int(de), true
}

func _failMemo(parser *_Parser, rule, start, errPos int) (int, *peg.Fail) {
	if start > parser.lastFail {
		return -1, &peg.Fail{}
	}
	dp := parser.deltaPos[start][rule]
	de := parser.deltaErr[start][rule]
	if start+int(de-1) < errPos {
		if dp > 0 {
			return start + int(dp-1), &peg.Fail{}
		}
		return -1, &peg.Fail{}
	}
	f := parser.fail[_key{start: start, rule: rule}]
	if dp < 0 && f != nil {
		return -1, f
	}
	if dp > 0 && f != nil {
		return start + int(dp-1), f
	}
	return start, nil
}

func _accept(parser *_Parser, f func(*_Parser, int) (int, int), pos, perr *int) bool {
	dp, de := f(parser, *pos)
	*perr = _max(*perr, *pos+de)
	if dp < 0 {
		return false
	}
	*pos += dp
	return true
}

func _node(parser *_Parser, f func(*_Parser, int) (int, *peg.Node), node *peg.Node, pos *int) bool {
	p, kid := f(parser, *pos)
	if kid == nil {
		return false
	}
	node.Kids = append(node.Kids, kid)
	*pos = p
	return true
}

func _fail(parser *_Parser, f func(*_Parser, int, int) (int, *peg.Fail), errPos int, node *peg.Fail, pos *int) bool {
	p, kid := f(parser, *pos, errPos)
	if kid.Want != "" || len(kid.Kids) > 0 {
		node.Kids = append(node.Kids, kid)
	}
	if p < 0 {
		return false
	}
	*pos = p
	return true
}

func _next(parser *_Parser, pos int) (rune, int) {
	r, w := peg.DecodeRuneInString(parser.text[pos:])
	return r, w
}

func _sub(parser *_Parser, start, end int, kids []*peg.Node) *peg.Node {
	node := &peg.Node{
		Text: parser.text[start:end],
		Kids: make([]*peg.Node, len(kids)),
	}
	copy(node.Kids, kids)
	return node
}

func _leaf(parser *_Parser, start, end int) *peg.Node {
	return &peg.Node{Text: parser.text[start:end]}
}

func _full_textAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _full_text, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// text EOF
	// text
	if !_accept(parser, _textAccepts, &pos, &perr) {
		goto fail
	}
	// EOF
	if !_accept(parser, _EOFAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _full_text, start, pos, perr)
fail:
	return _memoize(parser, _full_text, start, -1, perr)
}

func _full_textNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_full_text]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _full_text}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "full_text"}
	// text EOF
	// text
	if !_node(parser, _textNode, node, &pos) {
		goto fail
	}
	// EOF
	if !_node(parser, _EOFNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _full_textFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _full_text, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "full_text",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _full_text}
	// text EOF
	// text
	if !_fail(parser, _textFail, errPos, failure, &pos) {
		goto fail
	}
	// EOF
	if !_fail(parser, _EOFFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _full_textAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_full_text]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _full_text}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// text EOF
	{
		var node0 string
		// text
		if p, n := _textAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// EOF
		if p, n := _EOFAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _textAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _text, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// spaces? freemod* spaces? discourse? spaces? EOF?
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// freemod*
	for {
		pos6 := pos
		// freemod
		if !_accept(parser, _freemodAccepts, &pos, &perr) {
			goto fail8
		}
		continue
	fail8:
		pos = pos6
		break
	}
	// spaces?
	{
		pos10 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail11
		}
		goto ok12
	fail11:
		pos = pos10
	ok12:
	}
	// discourse?
	{
		pos14 := pos
		// discourse
		if !_accept(parser, _discourseAccepts, &pos, &perr) {
			goto fail15
		}
		goto ok16
	fail15:
		pos = pos14
	ok16:
	}
	// spaces?
	{
		pos18 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail19
		}
		goto ok20
	fail19:
		pos = pos18
	ok20:
	}
	// EOF?
	{
		pos22 := pos
		// EOF
		if !_accept(parser, _EOFAccepts, &pos, &perr) {
			goto fail23
		}
		goto ok24
	fail23:
		pos = pos22
	ok24:
	}
	return _memoize(parser, _text, start, pos, perr)
}

func _textNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_text]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _text}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "text"}
	// spaces? freemod* spaces? discourse? spaces? EOF?
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// freemod*
	for {
		nkids5 := len(node.Kids)
		pos6 := pos
		// freemod
		if !_node(parser, _freemodNode, node, &pos) {
			goto fail8
		}
		continue
	fail8:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
		break
	}
	// spaces?
	{
		nkids9 := len(node.Kids)
		pos10 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail11
		}
		goto ok12
	fail11:
		node.Kids = node.Kids[:nkids9]
		pos = pos10
	ok12:
	}
	// discourse?
	{
		nkids13 := len(node.Kids)
		pos14 := pos
		// discourse
		if !_node(parser, _discourseNode, node, &pos) {
			goto fail15
		}
		goto ok16
	fail15:
		node.Kids = node.Kids[:nkids13]
		pos = pos14
	ok16:
	}
	// spaces?
	{
		nkids17 := len(node.Kids)
		pos18 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail19
		}
		goto ok20
	fail19:
		node.Kids = node.Kids[:nkids17]
		pos = pos18
	ok20:
	}
	// EOF?
	{
		nkids21 := len(node.Kids)
		pos22 := pos
		// EOF
		if !_node(parser, _EOFNode, node, &pos) {
			goto fail23
		}
		goto ok24
	fail23:
		node.Kids = node.Kids[:nkids21]
		pos = pos22
	ok24:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
}

func _textFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _text, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "text",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _text}
	// spaces? freemod* spaces? discourse? spaces? EOF?
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// freemod*
	for {
		pos6 := pos
		// freemod
		if !_fail(parser, _freemodFail, errPos, failure, &pos) {
			goto fail8
		}
		continue
	fail8:
		pos = pos6
		break
	}
	// spaces?
	{
		pos10 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail11
		}
		goto ok12
	fail11:
		pos = pos10
	ok12:
	}
	// discourse?
	{
		pos14 := pos
		// discourse
		if !_fail(parser, _discourseFail, errPos, failure, &pos) {
			goto fail15
		}
		goto ok16
	fail15:
		pos = pos14
	ok16:
	}
	// spaces?
	{
		pos18 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail19
		}
		goto ok20
	fail19:
		pos = pos18
	ok20:
	}
	// EOF?
	{
		pos22 := pos
		// EOF
		if !_fail(parser, _EOFFail, errPos, failure, &pos) {
			goto fail23
		}
		goto ok24
	fail23:
		pos = pos22
	ok24:
	}
	parser.fail[key] = failure
	return pos, failure
}

func _textAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_text]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _text}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// spaces? freemod* spaces? discourse? spaces? EOF?
	{
		var node0 string
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// freemod*
		for {
			pos6 := pos
			var node7 string
			// freemod
			if p, n := _freemodAction(parser, pos); n == nil {
				goto fail8
			} else {
				node7 = *n
				pos = p
			}
			node0 += node7
			continue
		fail8:
			pos = pos6
			break
		}
		node += node0
		// spaces?
		{
			pos10 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail11
			} else {
				node0 = *n
				pos = p
			}
			goto ok12
		fail11:
			node0 = ""
			pos = pos10
		ok12:
		}
		node += node0
		// discourse?
		{
			pos14 := pos
			// discourse
			if p, n := _discourseAction(parser, pos); n == nil {
				goto fail15
			} else {
				node0 = *n
				pos = p
			}
			goto ok16
		fail15:
			node0 = ""
			pos = pos14
		ok16:
		}
		node += node0
		// spaces?
		{
			pos18 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail19
			} else {
				node0 = *n
				pos = p
			}
			goto ok20
		fail19:
			node0 = ""
			pos = pos18
		ok20:
		}
		node += node0
		// EOF?
		{
			pos22 := pos
			// EOF
			if p, n := _EOFAction(parser, pos); n == nil {
				goto fail23
			} else {
				node0 = *n
				pos = p
			}
			goto ok24
		fail23:
			node0 = ""
			pos = pos22
		ok24:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
}

func _discourseAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _discourse, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// (sentence/fragment)+
	// (sentence/fragment)
	// sentence/fragment
	{
		pos6 := pos
		// sentence
		if !_accept(parser, _sentenceAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok4
	fail7:
		pos = pos6
		// fragment
		if !_accept(parser, _fragmentAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok4
	fail8:
		pos = pos6
		goto fail
	ok4:
	}
	for {
		pos1 := pos
		// (sentence/fragment)
		// sentence/fragment
		{
			pos11 := pos
			// sentence
			if !_accept(parser, _sentenceAccepts, &pos, &perr) {
				goto fail12
			}
			goto ok9
		fail12:
			pos = pos11
			// fragment
			if !_accept(parser, _fragmentAccepts, &pos, &perr) {
				goto fail13
			}
			goto ok9
		fail13:
			pos = pos11
			goto fail3
		ok9:
		}
		continue
	fail3:
		pos = pos1
		break
	}
	return _memoize(parser, _discourse, start, pos, perr)
fail:
	return _memoize(parser, _discourse, start, -1, perr)
}

func _discourseNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_discourse]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _discourse}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "discourse"}
	// (sentence/fragment)+
	// (sentence/fragment)
	{
		nkids4 := len(node.Kids)
		pos05 := pos
		// sentence/fragment
		{
			pos8 := pos
			nkids7 := len(node.Kids)
			// sentence
			if !_node(parser, _sentenceNode, node, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			node.Kids = node.Kids[:nkids7]
			pos = pos8
			// fragment
			if !_node(parser, _fragmentNode, node, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			node.Kids = node.Kids[:nkids7]
			pos = pos8
			goto fail
		ok6:
		}
		sub := _sub(parser, pos05, pos, node.Kids[nkids4:])
		node.Kids = append(node.Kids[:nkids4], sub)
	}
	for {
		nkids0 := len(node.Kids)
		pos1 := pos
		// (sentence/fragment)
		{
			nkids11 := len(node.Kids)
			pos012 := pos
			// sentence/fragment
			{
				pos15 := pos
				nkids14 := len(node.Kids)
				// sentence
				if !_node(parser, _sentenceNode, node, &pos) {
					goto fail16
				}
				goto ok13
			fail16:
				node.Kids = node.Kids[:nkids14]
				pos = pos15
				// fragment
				if !_node(parser, _fragmentNode, node, &pos) {
					goto fail17
				}
				goto ok13
			fail17:
				node.Kids = node.Kids[:nkids14]
				pos = pos15
				goto fail3
			ok13:
			}
			sub := _sub(parser, pos012, pos, node.Kids[nkids11:])
			node.Kids = append(node.Kids[:nkids11], sub)
		}
		continue
	fail3:
		node.Kids = node.Kids[:nkids0]
		pos = pos1
		break
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _discourseFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _discourse, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "discourse",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _discourse}
	// (sentence/fragment)+
	// (sentence/fragment)
	// sentence/fragment
	{
		pos6 := pos
		// sentence
		if !_fail(parser, _sentenceFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok4
	fail7:
		pos = pos6
		// fragment
		if !_fail(parser, _fragmentFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok4
	fail8:
		pos = pos6
		goto fail
	ok4:
	}
	for {
		pos1 := pos
		// (sentence/fragment)
		// sentence/fragment
		{
			pos11 := pos
			// sentence
			if !_fail(parser, _sentenceFail, errPos, failure, &pos) {
				goto fail12
			}
			goto ok9
		fail12:
			pos = pos11
			// fragment
			if !_fail(parser, _fragmentFail, errPos, failure, &pos) {
				goto fail13
			}
			goto ok9
		fail13:
			pos = pos11
			goto fail3
		ok9:
		}
		continue
	fail3:
		pos = pos1
		break
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _discourseAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_discourse]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _discourse}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// (sentence/fragment)+
	{
		var node2 string
		// (sentence/fragment)
		// sentence/fragment
		{
			pos6 := pos
			// sentence
			if p, n := _sentenceAction(parser, pos); n == nil {
				goto fail7
			} else {
				node2 = *n
				pos = p
			}
			goto ok4
		fail7:
			pos = pos6
			// fragment
			if p, n := _fragmentAction(parser, pos); n == nil {
				goto fail8
			} else {
				node2 = *n
				pos = p
			}
			goto ok4
		fail8:
			pos = pos6
			goto fail
		ok4:
		}
		node += node2
	}
	for {
		pos1 := pos
		var node2 string
		// (sentence/fragment)
		// sentence/fragment
		{
			pos11 := pos
			// sentence
			if p, n := _sentenceAction(parser, pos); n == nil {
				goto fail12
			} else {
				node2 = *n
				pos = p
			}
			goto ok9
		fail12:
			pos = pos11
			// fragment
			if p, n := _fragmentAction(parser, pos); n == nil {
				goto fail13
			} else {
				node2 = *n
				pos = p
			}
			goto ok9
		fail13:
			pos = pos11
			goto fail3
		ok9:
		}
		node += node2
		continue
	fail3:
		pos = pos1
		break
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _sentenceAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _sentence, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// coP_sentence/sentence_1
	{
		pos2 := pos
		// coP_sentence
		if !_accept(parser, _coP_sentenceAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// sentence_1
		if !_accept(parser, _sentence_1Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _sentence, start, pos, perr)
fail:
	return _memoize(parser, _sentence, start, -1, perr)
}

func _sentenceNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_sentence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _sentence}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "sentence"}
	// coP_sentence/sentence_1
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// coP_sentence
		if !_node(parser, _coP_sentenceNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// sentence_1
		if !_node(parser, _sentence_1Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _sentenceFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _sentence, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "sentence",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _sentence}
	// coP_sentence/sentence_1
	{
		pos2 := pos
		// coP_sentence
		if !_fail(parser, _coP_sentenceFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// sentence_1
		if !_fail(parser, _sentence_1Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _sentenceAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_sentence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _sentence}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// coP_sentence/sentence_1
	{
		pos2 := pos
		// coP_sentence
		if p, n := _coP_sentenceAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// sentence_1
		if p, n := _sentence_1Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _sentence_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _sentence_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_coP_sentence/sentence_2
	{
		pos2 := pos
		// forethought_coP_sentence
		if !_accept(parser, _forethought_coP_sentenceAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// sentence_2
		if !_accept(parser, _sentence_2Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _sentence_1, start, pos, perr)
fail:
	return _memoize(parser, _sentence_1, start, -1, perr)
}

func _sentence_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_sentence_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _sentence_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "sentence_1"}
	// forethought_coP_sentence/sentence_2
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// forethought_coP_sentence
		if !_node(parser, _forethought_coP_sentenceNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// sentence_2
		if !_node(parser, _sentence_2Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _sentence_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _sentence_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "sentence_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _sentence_1}
	// forethought_coP_sentence/sentence_2
	{
		pos2 := pos
		// forethought_coP_sentence
		if !_fail(parser, _forethought_coP_sentenceFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// sentence_2
		if !_fail(parser, _sentence_2Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _sentence_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_sentence_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _sentence_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_coP_sentence/sentence_2
	{
		pos2 := pos
		// forethought_coP_sentence
		if p, n := _forethought_coP_sentenceAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// sentence_2
		if p, n := _sentence_2Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _sentence_2Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _sentence_2, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// spaces? sentence_prefix? sentence_3
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// sentence_prefix?
	{
		pos6 := pos
		// sentence_prefix
		if !_accept(parser, _sentence_prefixAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	// sentence_3
	if !_accept(parser, _sentence_3Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _sentence_2, start, pos, perr)
fail:
	return _memoize(parser, _sentence_2, start, -1, perr)
}

func _sentence_2Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_sentence_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _sentence_2}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "sentence_2"}
	// spaces? sentence_prefix? sentence_3
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// sentence_prefix?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// sentence_prefix
		if !_node(parser, _sentence_prefixNode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	// sentence_3
	if !_node(parser, _sentence_3Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _sentence_2Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _sentence_2, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "sentence_2",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _sentence_2}
	// spaces? sentence_prefix? sentence_3
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// sentence_prefix?
	{
		pos6 := pos
		// sentence_prefix
		if !_fail(parser, _sentence_prefixFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	// sentence_3
	if !_fail(parser, _sentence_3Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _sentence_2Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_sentence_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _sentence_2}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// spaces? sentence_prefix? sentence_3
	{
		var node0 string
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// sentence_prefix?
		{
			pos6 := pos
			// sentence_prefix
			if p, n := _sentence_prefixAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
		// sentence_3
		if p, n := _sentence_3Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _sentence_3Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _sentence_3, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// spaces? statement spaces? illocutionary?
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// statement
	if !_accept(parser, _statementAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos6 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	// illocutionary?
	{
		pos10 := pos
		// illocutionary
		if !_accept(parser, _illocutionaryAccepts, &pos, &perr) {
			goto fail11
		}
		goto ok12
	fail11:
		pos = pos10
	ok12:
	}
	return _memoize(parser, _sentence_3, start, pos, perr)
fail:
	return _memoize(parser, _sentence_3, start, -1, perr)
}

func _sentence_3Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_sentence_3]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _sentence_3}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "sentence_3"}
	// spaces? statement spaces? illocutionary?
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// statement
	if !_node(parser, _statementNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	// illocutionary?
	{
		nkids9 := len(node.Kids)
		pos10 := pos
		// illocutionary
		if !_node(parser, _illocutionaryNode, node, &pos) {
			goto fail11
		}
		goto ok12
	fail11:
		node.Kids = node.Kids[:nkids9]
		pos = pos10
	ok12:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _sentence_3Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _sentence_3, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "sentence_3",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _sentence_3}
	// spaces? statement spaces? illocutionary?
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// statement
	if !_fail(parser, _statementFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos6 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	// illocutionary?
	{
		pos10 := pos
		// illocutionary
		if !_fail(parser, _illocutionaryFail, errPos, failure, &pos) {
			goto fail11
		}
		goto ok12
	fail11:
		pos = pos10
	ok12:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _sentence_3Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_sentence_3]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _sentence_3}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// spaces? statement spaces? illocutionary?
	{
		var node0 string
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// statement
		if p, n := _statementAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos6 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
		// illocutionary?
		{
			pos10 := pos
			// illocutionary
			if p, n := _illocutionaryAction(parser, pos); n == nil {
				goto fail11
			} else {
				node0 = *n
				pos = p
			}
			goto ok12
		fail11:
			node0 = ""
			pos = pos10
		ok12:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _fragmentAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _fragment, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// spaces? coP_rel/spaces? relative_clause/spaces? prenex/spaces? terms
	{
		pos2 := pos
		// spaces? coP_rel
		// spaces?
		{
			pos6 := pos
			// spaces
			if !_accept(parser, _spacesAccepts, &pos, &perr) {
				goto fail7
			}
			goto ok8
		fail7:
			pos = pos6
		ok8:
		}
		// coP_rel
		if !_accept(parser, _coP_relAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// spaces? relative_clause
		// spaces?
		{
			pos12 := pos
			// spaces
			if !_accept(parser, _spacesAccepts, &pos, &perr) {
				goto fail13
			}
			goto ok14
		fail13:
			pos = pos12
		ok14:
		}
		// relative_clause
		if !_accept(parser, _relative_clauseAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// spaces? prenex
		// spaces?
		{
			pos18 := pos
			// spaces
			if !_accept(parser, _spacesAccepts, &pos, &perr) {
				goto fail19
			}
			goto ok20
		fail19:
			pos = pos18
		ok20:
		}
		// prenex
		if !_accept(parser, _prenexAccepts, &pos, &perr) {
			goto fail15
		}
		goto ok0
	fail15:
		pos = pos2
		// spaces? terms
		// spaces?
		{
			pos24 := pos
			// spaces
			if !_accept(parser, _spacesAccepts, &pos, &perr) {
				goto fail25
			}
			goto ok26
		fail25:
			pos = pos24
		ok26:
		}
		// terms
		if !_accept(parser, _termsAccepts, &pos, &perr) {
			goto fail21
		}
		goto ok0
	fail21:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _fragment, start, pos, perr)
fail:
	return _memoize(parser, _fragment, start, -1, perr)
}

func _fragmentNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_fragment]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _fragment}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "fragment"}
	// spaces? coP_rel/spaces? relative_clause/spaces? prenex/spaces? terms
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// spaces? coP_rel
		// spaces?
		{
			nkids5 := len(node.Kids)
			pos6 := pos
			// spaces
			if !_node(parser, _spacesNode, node, &pos) {
				goto fail7
			}
			goto ok8
		fail7:
			node.Kids = node.Kids[:nkids5]
			pos = pos6
		ok8:
		}
		// coP_rel
		if !_node(parser, _coP_relNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// spaces? relative_clause
		// spaces?
		{
			nkids11 := len(node.Kids)
			pos12 := pos
			// spaces
			if !_node(parser, _spacesNode, node, &pos) {
				goto fail13
			}
			goto ok14
		fail13:
			node.Kids = node.Kids[:nkids11]
			pos = pos12
		ok14:
		}
		// relative_clause
		if !_node(parser, _relative_clauseNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// spaces? prenex
		// spaces?
		{
			nkids17 := len(node.Kids)
			pos18 := pos
			// spaces
			if !_node(parser, _spacesNode, node, &pos) {
				goto fail19
			}
			goto ok20
		fail19:
			node.Kids = node.Kids[:nkids17]
			pos = pos18
		ok20:
		}
		// prenex
		if !_node(parser, _prenexNode, node, &pos) {
			goto fail15
		}
		goto ok0
	fail15:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// spaces? terms
		// spaces?
		{
			nkids23 := len(node.Kids)
			pos24 := pos
			// spaces
			if !_node(parser, _spacesNode, node, &pos) {
				goto fail25
			}
			goto ok26
		fail25:
			node.Kids = node.Kids[:nkids23]
			pos = pos24
		ok26:
		}
		// terms
		if !_node(parser, _termsNode, node, &pos) {
			goto fail21
		}
		goto ok0
	fail21:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _fragmentFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _fragment, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "fragment",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _fragment}
	// spaces? coP_rel/spaces? relative_clause/spaces? prenex/spaces? terms
	{
		pos2 := pos
		// spaces? coP_rel
		// spaces?
		{
			pos6 := pos
			// spaces
			if !_fail(parser, _spacesFail, errPos, failure, &pos) {
				goto fail7
			}
			goto ok8
		fail7:
			pos = pos6
		ok8:
		}
		// coP_rel
		if !_fail(parser, _coP_relFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// spaces? relative_clause
		// spaces?
		{
			pos12 := pos
			// spaces
			if !_fail(parser, _spacesFail, errPos, failure, &pos) {
				goto fail13
			}
			goto ok14
		fail13:
			pos = pos12
		ok14:
		}
		// relative_clause
		if !_fail(parser, _relative_clauseFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// spaces? prenex
		// spaces?
		{
			pos18 := pos
			// spaces
			if !_fail(parser, _spacesFail, errPos, failure, &pos) {
				goto fail19
			}
			goto ok20
		fail19:
			pos = pos18
		ok20:
		}
		// prenex
		if !_fail(parser, _prenexFail, errPos, failure, &pos) {
			goto fail15
		}
		goto ok0
	fail15:
		pos = pos2
		// spaces? terms
		// spaces?
		{
			pos24 := pos
			// spaces
			if !_fail(parser, _spacesFail, errPos, failure, &pos) {
				goto fail25
			}
			goto ok26
		fail25:
			pos = pos24
		ok26:
		}
		// terms
		if !_fail(parser, _termsFail, errPos, failure, &pos) {
			goto fail21
		}
		goto ok0
	fail21:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _fragmentAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_fragment]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _fragment}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// spaces? coP_rel/spaces? relative_clause/spaces? prenex/spaces? terms
	{
		pos2 := pos
		// spaces? coP_rel
		{
			var node4 string
			// spaces?
			{
				pos6 := pos
				// spaces
				if p, n := _spacesAction(parser, pos); n == nil {
					goto fail7
				} else {
					node4 = *n
					pos = p
				}
				goto ok8
			fail7:
				node4 = ""
				pos = pos6
			ok8:
			}
			node += node4
			// coP_rel
			if p, n := _coP_relAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
		}
		goto ok0
	fail3:
		pos = pos2
		// spaces? relative_clause
		{
			var node10 string
			// spaces?
			{
				pos12 := pos
				// spaces
				if p, n := _spacesAction(parser, pos); n == nil {
					goto fail13
				} else {
					node10 = *n
					pos = p
				}
				goto ok14
			fail13:
				node10 = ""
				pos = pos12
			ok14:
			}
			node += node10
			// relative_clause
			if p, n := _relative_clauseAction(parser, pos); n == nil {
				goto fail9
			} else {
				node10 = *n
				pos = p
			}
			node += node10
		}
		goto ok0
	fail9:
		pos = pos2
		// spaces? prenex
		{
			var node16 string
			// spaces?
			{
				pos18 := pos
				// spaces
				if p, n := _spacesAction(parser, pos); n == nil {
					goto fail19
				} else {
					node16 = *n
					pos = p
				}
				goto ok20
			fail19:
				node16 = ""
				pos = pos18
			ok20:
			}
			node += node16
			// prenex
			if p, n := _prenexAction(parser, pos); n == nil {
				goto fail15
			} else {
				node16 = *n
				pos = p
			}
			node += node16
		}
		goto ok0
	fail15:
		pos = pos2
		// spaces? terms
		{
			var node22 string
			// spaces?
			{
				pos24 := pos
				// spaces
				if p, n := _spacesAction(parser, pos); n == nil {
					goto fail25
				} else {
					node22 = *n
					pos = p
				}
				goto ok26
			fail25:
				node22 = ""
				pos = pos24
			ok26:
			}
			node += node22
			// terms
			if p, n := _termsAction(parser, pos); n == nil {
				goto fail21
			} else {
				node22 = *n
				pos = p
			}
			node += node22
		}
		goto ok0
	fail21:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _coP_sentenceAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _coP_sentence, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// sentence_1 spaces? co_bar_sentence
	// sentence_1
	if !_accept(parser, _sentence_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_sentence
	if !_accept(parser, _co_bar_sentenceAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _coP_sentence, start, pos, perr)
fail:
	return _memoize(parser, _coP_sentence, start, -1, perr)
}

func _coP_sentenceNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_coP_sentence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_sentence}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "coP_sentence"}
	// sentence_1 spaces? co_bar_sentence
	// sentence_1
	if !_node(parser, _sentence_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// co_bar_sentence
	if !_node(parser, _co_bar_sentenceNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _coP_sentenceFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _coP_sentence, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "coP_sentence",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _coP_sentence}
	// sentence_1 spaces? co_bar_sentence
	// sentence_1
	if !_fail(parser, _sentence_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_sentence
	if !_fail(parser, _co_bar_sentenceFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _coP_sentenceAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_coP_sentence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_sentence}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// sentence_1 spaces? co_bar_sentence
	{
		var node0 string
		// sentence_1
		if p, n := _sentence_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// co_bar_sentence
		if p, n := _co_bar_sentenceAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _co_bar_sentenceAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _co_bar_sentence, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// connective spaces? sentence_1
	// connective
	if !_accept(parser, _connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// sentence_1
	if !_accept(parser, _sentence_1Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _co_bar_sentence, start, pos, perr)
fail:
	return _memoize(parser, _co_bar_sentence, start, -1, perr)
}

func _co_bar_sentenceNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_co_bar_sentence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _co_bar_sentence}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "co_bar_sentence"}
	// connective spaces? sentence_1
	// connective
	if !_node(parser, _connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// sentence_1
	if !_node(parser, _sentence_1Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _co_bar_sentenceFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _co_bar_sentence, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "co_bar_sentence",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _co_bar_sentence}
	// connective spaces? sentence_1
	// connective
	if !_fail(parser, _connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// sentence_1
	if !_fail(parser, _sentence_1Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _co_bar_sentenceAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_co_bar_sentence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _co_bar_sentence}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// connective spaces? sentence_1
	{
		var node0 string
		// connective
		if p, n := _connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// sentence_1
		if p, n := _sentence_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_sentenceAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_sentence, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_connective spaces? forethought_coP_sentence_1
	// forethought_connective
	if !_accept(parser, _forethought_connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_sentence_1
	if !_accept(parser, _forethought_coP_sentence_1Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_sentence, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_sentence, start, -1, perr)
}

func _forethought_coP_sentenceNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_sentence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_sentence}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_sentence"}
	// forethought_connective spaces? forethought_coP_sentence_1
	// forethought_connective
	if !_node(parser, _forethought_connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_coP_sentence_1
	if !_node(parser, _forethought_coP_sentence_1Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_sentenceFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_sentence, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_sentence",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_sentence}
	// forethought_connective spaces? forethought_coP_sentence_1
	// forethought_connective
	if !_fail(parser, _forethought_connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_sentence_1
	if !_fail(parser, _forethought_coP_sentence_1Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_sentenceAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_sentence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_sentence}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_connective spaces? forethought_coP_sentence_1
	{
		var node0 string
		// forethought_connective
		if p, n := _forethought_connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_coP_sentence_1
		if p, n := _forethought_coP_sentence_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_sentence_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_sentence_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// sentence spaces? forethought_co_bar_sentence
	// sentence
	if !_accept(parser, _sentenceAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_sentence
	if !_accept(parser, _forethought_co_bar_sentenceAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_sentence_1, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_sentence_1, start, -1, perr)
}

func _forethought_coP_sentence_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_sentence_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_sentence_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_sentence_1"}
	// sentence spaces? forethought_co_bar_sentence
	// sentence
	if !_node(parser, _sentenceNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_co_bar_sentence
	if !_node(parser, _forethought_co_bar_sentenceNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_sentence_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_sentence_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_sentence_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_sentence_1}
	// sentence spaces? forethought_co_bar_sentence
	// sentence
	if !_fail(parser, _sentenceFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_sentence
	if !_fail(parser, _forethought_co_bar_sentenceFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_sentence_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_sentence_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_sentence_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// sentence spaces? forethought_co_bar_sentence
	{
		var node0 string
		// sentence
		if p, n := _sentenceAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_co_bar_sentence
		if p, n := _forethought_co_bar_sentenceAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_co_bar_sentenceAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_co_bar_sentence, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// gik spaces? sentence
	// gik
	if !_accept(parser, _gikAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// sentence
	if !_accept(parser, _sentenceAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_co_bar_sentence, start, pos, perr)
fail:
	return _memoize(parser, _forethought_co_bar_sentence, start, -1, perr)
}

func _forethought_co_bar_sentenceNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_co_bar_sentence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_sentence}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_co_bar_sentence"}
	// gik spaces? sentence
	// gik
	if !_node(parser, _gikNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// sentence
	if !_node(parser, _sentenceNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_co_bar_sentenceFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_co_bar_sentence, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_co_bar_sentence",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_co_bar_sentence}
	// gik spaces? sentence
	// gik
	if !_fail(parser, _gikFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// sentence
	if !_fail(parser, _sentenceFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_co_bar_sentenceAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_co_bar_sentence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_sentence}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// gik spaces? sentence
	{
		var node0 string
		// gik
		if p, n := _gikAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// sentence
		if p, n := _sentenceAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _sentence_prefixAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _sentence_prefix, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// k e o &boundary/j e &boundary
	{
		pos2 := pos
		// k e o &boundary
		// k
		if !_accept(parser, _kAccepts, &pos, &perr) {
			goto fail3
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail3
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail3
		}
		// &boundary
		{
			pos6 := pos
			perr8 := perr
			// boundary
			if !_accept(parser, _boundaryAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok5
		fail9:
			pos = pos6
			perr = _max(perr8, pos)
			goto fail3
		ok5:
			pos = pos6
			perr = perr8
		}
		goto ok0
	fail3:
		pos = pos2
		// j e &boundary
		// j
		if !_accept(parser, _jAccepts, &pos, &perr) {
			goto fail10
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail10
		}
		// &boundary
		{
			pos13 := pos
			perr15 := perr
			// boundary
			if !_accept(parser, _boundaryAccepts, &pos, &perr) {
				goto fail16
			}
			goto ok12
		fail16:
			pos = pos13
			perr = _max(perr15, pos)
			goto fail10
		ok12:
			pos = pos13
			perr = perr15
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _sentence_prefix, start, pos, perr)
fail:
	return _memoize(parser, _sentence_prefix, start, -1, perr)
}

func _sentence_prefixNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_sentence_prefix]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _sentence_prefix}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "sentence_prefix"}
	// k e o &boundary/j e &boundary
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// k e o &boundary
		// k
		if !_node(parser, _kNode, node, &pos) {
			goto fail3
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail3
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail3
		}
		// &boundary
		{
			pos6 := pos
			nkids7 := len(node.Kids)
			// boundary
			if !_node(parser, _boundaryNode, node, &pos) {
				goto fail9
			}
			goto ok5
		fail9:
			pos = pos6
			goto fail3
		ok5:
			pos = pos6
			node.Kids = node.Kids[:nkids7]
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// j e &boundary
		// j
		if !_node(parser, _jNode, node, &pos) {
			goto fail10
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail10
		}
		// &boundary
		{
			pos13 := pos
			nkids14 := len(node.Kids)
			// boundary
			if !_node(parser, _boundaryNode, node, &pos) {
				goto fail16
			}
			goto ok12
		fail16:
			pos = pos13
			goto fail10
		ok12:
			pos = pos13
			node.Kids = node.Kids[:nkids14]
		}
		goto ok0
	fail10:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _sentence_prefixFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _sentence_prefix, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "sentence_prefix",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _sentence_prefix}
	// k e o &boundary/j e &boundary
	{
		pos2 := pos
		// k e o &boundary
		// k
		if !_fail(parser, _kFail, errPos, failure, &pos) {
			goto fail3
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail3
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail3
		}
		// &boundary
		{
			pos6 := pos
			nkids7 := len(failure.Kids)
			// boundary
			if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok5
		fail9:
			pos = pos6
			failure.Kids = failure.Kids[:nkids7]
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "&boundary",
				})
			}
			goto fail3
		ok5:
			pos = pos6
			failure.Kids = failure.Kids[:nkids7]
		}
		goto ok0
	fail3:
		pos = pos2
		// j e &boundary
		// j
		if !_fail(parser, _jFail, errPos, failure, &pos) {
			goto fail10
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail10
		}
		// &boundary
		{
			pos13 := pos
			nkids14 := len(failure.Kids)
			// boundary
			if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
				goto fail16
			}
			goto ok12
		fail16:
			pos = pos13
			failure.Kids = failure.Kids[:nkids14]
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "&boundary",
				})
			}
			goto fail10
		ok12:
			pos = pos13
			failure.Kids = failure.Kids[:nkids14]
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _sentence_prefixAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_sentence_prefix]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _sentence_prefix}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// k e o &boundary/j e &boundary
	{
		pos2 := pos
		// k e o &boundary
		{
			var node4 string
			// k
			if p, n := _kAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
			// &boundary
			{
				pos6 := pos
				// boundary
				if p, n := _boundaryAction(parser, pos); n == nil {
					goto fail9
				} else {
					pos = p
				}
				goto ok5
			fail9:
				pos = pos6
				goto fail3
			ok5:
				pos = pos6
				node = ""
			}
			node += node4
		}
		goto ok0
	fail3:
		pos = pos2
		// j e &boundary
		{
			var node11 string
			// j
			if p, n := _jAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
			// &boundary
			{
				pos13 := pos
				// boundary
				if p, n := _boundaryAction(parser, pos); n == nil {
					goto fail16
				} else {
					pos = p
				}
				goto ok12
			fail16:
				pos = pos13
				goto fail10
			ok12:
				pos = pos13
				node = ""
			}
			node += node11
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _statementAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _statement, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// coP_statement/statement_1
	{
		pos2 := pos
		// coP_statement
		if !_accept(parser, _coP_statementAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// statement_1
		if !_accept(parser, _statement_1Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _statement, start, pos, perr)
fail:
	return _memoize(parser, _statement, start, -1, perr)
}

func _statementNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_statement]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _statement}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "statement"}
	// coP_statement/statement_1
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// coP_statement
		if !_node(parser, _coP_statementNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// statement_1
		if !_node(parser, _statement_1Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _statementFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _statement, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "statement",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _statement}
	// coP_statement/statement_1
	{
		pos2 := pos
		// coP_statement
		if !_fail(parser, _coP_statementFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// statement_1
		if !_fail(parser, _statement_1Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _statementAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_statement]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _statement}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// coP_statement/statement_1
	{
		pos2 := pos
		// coP_statement
		if p, n := _coP_statementAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// statement_1
		if p, n := _statement_1Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _statement_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _statement_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_coP_statement/statement_2
	{
		pos2 := pos
		// forethought_coP_statement
		if !_accept(parser, _forethought_coP_statementAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// statement_2
		if !_accept(parser, _statement_2Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _statement_1, start, pos, perr)
fail:
	return _memoize(parser, _statement_1, start, -1, perr)
}

func _statement_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_statement_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _statement_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "statement_1"}
	// forethought_coP_statement/statement_2
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// forethought_coP_statement
		if !_node(parser, _forethought_coP_statementNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// statement_2
		if !_node(parser, _statement_2Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _statement_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _statement_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "statement_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _statement_1}
	// forethought_coP_statement/statement_2
	{
		pos2 := pos
		// forethought_coP_statement
		if !_fail(parser, _forethought_coP_statementFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// statement_2
		if !_fail(parser, _statement_2Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _statement_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_statement_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _statement_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_coP_statement/statement_2
	{
		pos2 := pos
		// forethought_coP_statement
		if p, n := _forethought_coP_statementAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// statement_2
		if p, n := _statement_2Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _statement_2Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _statement_2, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// statement_3 end_statement?
	// statement_3
	if !_accept(parser, _statement_3Accepts, &pos, &perr) {
		goto fail
	}
	// end_statement?
	{
		pos2 := pos
		// end_statement
		if !_accept(parser, _end_statementAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	return _memoize(parser, _statement_2, start, pos, perr)
fail:
	return _memoize(parser, _statement_2, start, -1, perr)
}

func _statement_2Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_statement_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _statement_2}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "statement_2"}
	// statement_3 end_statement?
	// statement_3
	if !_node(parser, _statement_3Node, node, &pos) {
		goto fail
	}
	// end_statement?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// end_statement
		if !_node(parser, _end_statementNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _statement_2Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _statement_2, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "statement_2",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _statement_2}
	// statement_3 end_statement?
	// statement_3
	if !_fail(parser, _statement_3Fail, errPos, failure, &pos) {
		goto fail
	}
	// end_statement?
	{
		pos2 := pos
		// end_statement
		if !_fail(parser, _end_statementFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _statement_2Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_statement_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _statement_2}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// statement_3 end_statement?
	{
		var node0 string
		// statement_3
		if p, n := _statement_3Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// end_statement?
		{
			pos2 := pos
			// end_statement
			if p, n := _end_statementAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _statement_3Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _statement_3, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// prenex? spaces? predication
	// prenex?
	{
		pos2 := pos
		// prenex
		if !_accept(parser, _prenexAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// spaces?
	{
		pos6 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	// predication
	if !_accept(parser, _predicationAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _statement_3, start, pos, perr)
fail:
	return _memoize(parser, _statement_3, start, -1, perr)
}

func _statement_3Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_statement_3]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _statement_3}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "statement_3"}
	// prenex? spaces? predication
	// prenex?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// prenex
		if !_node(parser, _prenexNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// spaces?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	// predication
	if !_node(parser, _predicationNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _statement_3Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _statement_3, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "statement_3",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _statement_3}
	// prenex? spaces? predication
	// prenex?
	{
		pos2 := pos
		// prenex
		if !_fail(parser, _prenexFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// spaces?
	{
		pos6 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	// predication
	if !_fail(parser, _predicationFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _statement_3Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_statement_3]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _statement_3}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// prenex? spaces? predication
	{
		var node0 string
		// prenex?
		{
			pos2 := pos
			// prenex
			if p, n := _prenexAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// spaces?
		{
			pos6 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
		// predication
		if p, n := _predicationAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _end_statementAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _end_statement, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// NA freemod?
	// NA
	if !_accept(parser, _NAAccepts, &pos, &perr) {
		goto fail
	}
	// freemod?
	{
		pos2 := pos
		// freemod
		if !_accept(parser, _freemodAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	return _memoize(parser, _end_statement, start, pos, perr)
fail:
	return _memoize(parser, _end_statement, start, -1, perr)
}

func _end_statementNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_end_statement]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _end_statement}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "end_statement"}
	// NA freemod?
	// NA
	if !_node(parser, _NANode, node, &pos) {
		goto fail
	}
	// freemod?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// freemod
		if !_node(parser, _freemodNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _end_statementFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _end_statement, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "end_statement",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _end_statement}
	// NA freemod?
	// NA
	if !_fail(parser, _NAFail, errPos, failure, &pos) {
		goto fail
	}
	// freemod?
	{
		pos2 := pos
		// freemod
		if !_fail(parser, _freemodFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _end_statementAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_end_statement]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _end_statement}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// NA freemod?
	{
		var node0 string
		// NA
		if p, n := _NAAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// freemod?
		{
			pos2 := pos
			// freemod
			if p, n := _freemodAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _prenexAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _prenex, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// terms spaces? end_prenex
	// terms
	if !_accept(parser, _termsAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// end_prenex
	if !_accept(parser, _end_prenexAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _prenex, start, pos, perr)
fail:
	return _memoize(parser, _prenex, start, -1, perr)
}

func _prenexNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_prenex]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _prenex}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "prenex"}
	// terms spaces? end_prenex
	// terms
	if !_node(parser, _termsNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// end_prenex
	if !_node(parser, _end_prenexNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _prenexFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _prenex, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "prenex",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _prenex}
	// terms spaces? end_prenex
	// terms
	if !_fail(parser, _termsFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// end_prenex
	if !_fail(parser, _end_prenexFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _prenexAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_prenex]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _prenex}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// terms spaces? end_prenex
	{
		var node0 string
		// terms
		if p, n := _termsAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// end_prenex
		if p, n := _end_prenexAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _predicationAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _predication, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// predicate spaces? terms?
	// predicate
	if !_accept(parser, _predicateAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms?
	{
		pos6 := pos
		// terms
		if !_accept(parser, _termsAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	return _memoize(parser, _predication, start, pos, perr)
fail:
	return _memoize(parser, _predication, start, -1, perr)
}

func _predicationNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_predication]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _predication}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "predication"}
	// predicate spaces? terms?
	// predicate
	if !_node(parser, _predicateNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// terms?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// terms
		if !_node(parser, _termsNode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _predicationFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _predication, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "predication",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _predication}
	// predicate spaces? terms?
	// predicate
	if !_fail(parser, _predicateFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms?
	{
		pos6 := pos
		// terms
		if !_fail(parser, _termsFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _predicationAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_predication]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _predication}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// predicate spaces? terms?
	{
		var node0 string
		// predicate
		if p, n := _predicateAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// terms?
		{
			pos6 := pos
			// terms
			if p, n := _termsAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _coP_statementAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _coP_statement, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// statement_1 spaces? co_bar_statement
	// statement_1
	if !_accept(parser, _statement_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_statement
	if !_accept(parser, _co_bar_statementAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _coP_statement, start, pos, perr)
fail:
	return _memoize(parser, _coP_statement, start, -1, perr)
}

func _coP_statementNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_coP_statement]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_statement}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "coP_statement"}
	// statement_1 spaces? co_bar_statement
	// statement_1
	if !_node(parser, _statement_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// co_bar_statement
	if !_node(parser, _co_bar_statementNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _coP_statementFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _coP_statement, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "coP_statement",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _coP_statement}
	// statement_1 spaces? co_bar_statement
	// statement_1
	if !_fail(parser, _statement_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_statement
	if !_fail(parser, _co_bar_statementFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _coP_statementAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_coP_statement]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_statement}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// statement_1 spaces? co_bar_statement
	{
		var node0 string
		// statement_1
		if p, n := _statement_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// co_bar_statement
		if p, n := _co_bar_statementAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _co_bar_statementAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _co_bar_statement, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// connective spaces? statement_1
	// connective
	if !_accept(parser, _connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// statement_1
	if !_accept(parser, _statement_1Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _co_bar_statement, start, pos, perr)
fail:
	return _memoize(parser, _co_bar_statement, start, -1, perr)
}

func _co_bar_statementNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_co_bar_statement]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _co_bar_statement}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "co_bar_statement"}
	// connective spaces? statement_1
	// connective
	if !_node(parser, _connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// statement_1
	if !_node(parser, _statement_1Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _co_bar_statementFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _co_bar_statement, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "co_bar_statement",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _co_bar_statement}
	// connective spaces? statement_1
	// connective
	if !_fail(parser, _connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// statement_1
	if !_fail(parser, _statement_1Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _co_bar_statementAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_co_bar_statement]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _co_bar_statement}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// connective spaces? statement_1
	{
		var node0 string
		// connective
		if p, n := _connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// statement_1
		if p, n := _statement_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_statementAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_statement, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_connective spaces? forethought_coP_statement_1
	// forethought_connective
	if !_accept(parser, _forethought_connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_statement_1
	if !_accept(parser, _forethought_coP_statement_1Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_statement, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_statement, start, -1, perr)
}

func _forethought_coP_statementNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_statement]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_statement}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_statement"}
	// forethought_connective spaces? forethought_coP_statement_1
	// forethought_connective
	if !_node(parser, _forethought_connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_coP_statement_1
	if !_node(parser, _forethought_coP_statement_1Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_statementFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_statement, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_statement",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_statement}
	// forethought_connective spaces? forethought_coP_statement_1
	// forethought_connective
	if !_fail(parser, _forethought_connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_statement_1
	if !_fail(parser, _forethought_coP_statement_1Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_statementAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_statement]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_statement}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_connective spaces? forethought_coP_statement_1
	{
		var node0 string
		// forethought_connective
		if p, n := _forethought_connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_coP_statement_1
		if p, n := _forethought_coP_statement_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_statement_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_statement_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// statement spaces? forethought_co_bar_statement
	// statement
	if !_accept(parser, _statementAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_statement
	if !_accept(parser, _forethought_co_bar_statementAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_statement_1, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_statement_1, start, -1, perr)
}

func _forethought_coP_statement_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_statement_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_statement_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_statement_1"}
	// statement spaces? forethought_co_bar_statement
	// statement
	if !_node(parser, _statementNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_co_bar_statement
	if !_node(parser, _forethought_co_bar_statementNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_statement_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_statement_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_statement_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_statement_1}
	// statement spaces? forethought_co_bar_statement
	// statement
	if !_fail(parser, _statementFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_statement
	if !_fail(parser, _forethought_co_bar_statementFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_statement_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_statement_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_statement_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// statement spaces? forethought_co_bar_statement
	{
		var node0 string
		// statement
		if p, n := _statementAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_co_bar_statement
		if p, n := _forethought_co_bar_statementAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_co_bar_statementAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_co_bar_statement, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// gik spaces? statement
	// gik
	if !_accept(parser, _gikAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// statement
	if !_accept(parser, _statementAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_co_bar_statement, start, pos, perr)
fail:
	return _memoize(parser, _forethought_co_bar_statement, start, -1, perr)
}

func _forethought_co_bar_statementNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_co_bar_statement]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_statement}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_co_bar_statement"}
	// gik spaces? statement
	// gik
	if !_node(parser, _gikNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// statement
	if !_node(parser, _statementNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_co_bar_statementFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_co_bar_statement, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_co_bar_statement",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_co_bar_statement}
	// gik spaces? statement
	// gik
	if !_fail(parser, _gikFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// statement
	if !_fail(parser, _statementFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_co_bar_statementAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_co_bar_statement]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_statement}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// gik spaces? statement
	{
		var node0 string
		// gik
		if p, n := _gikAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// statement
		if p, n := _statementAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// serial_predicate
	if !_accept(parser, _serial_predicateAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _predicate, start, pos, perr)
fail:
	return _memoize(parser, _predicate, start, -1, perr)
}

func _predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "predicate"}
	// serial_predicate
	if !_node(parser, _serial_predicateNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _predicate}
	// serial_predicate
	if !_fail(parser, _serial_predicateFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// serial_predicate
	if p, n := _serial_predicateAction(parser, pos); n == nil {
		goto fail
	} else {
		node = *n
		pos = p
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _predicate_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _predicate_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// coP_pred/predicate_2
	{
		pos2 := pos
		// coP_pred
		if !_accept(parser, _coP_predAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// predicate_2
		if !_accept(parser, _predicate_2Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _predicate_1, start, pos, perr)
fail:
	return _memoize(parser, _predicate_1, start, -1, perr)
}

func _predicate_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _predicate_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "predicate_1"}
	// coP_pred/predicate_2
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// coP_pred
		if !_node(parser, _coP_predNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// predicate_2
		if !_node(parser, _predicate_2Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _predicate_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _predicate_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "predicate_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _predicate_1}
	// coP_pred/predicate_2
	{
		pos2 := pos
		// coP_pred
		if !_fail(parser, _coP_predFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// predicate_2
		if !_fail(parser, _predicate_2Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _predicate_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _predicate_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// coP_pred/predicate_2
	{
		pos2 := pos
		// coP_pred
		if p, n := _coP_predAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// predicate_2
		if p, n := _predicate_2Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _predicate_2Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _predicate_2, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_coP_pred/LU_predicate/MI_predicate/PO_predicate/quotation_predicate/prefix spaces? predicate_2/predicate_3
	{
		pos2 := pos
		// forethought_coP_pred
		if !_accept(parser, _forethought_coP_predAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// LU_predicate
		if !_accept(parser, _LU_predicateAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// MI_predicate
		if !_accept(parser, _MI_predicateAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// PO_predicate
		if !_accept(parser, _PO_predicateAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// quotation_predicate
		if !_accept(parser, _quotation_predicateAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// prefix spaces? predicate_2
		// prefix
		if !_accept(parser, _prefixAccepts, &pos, &perr) {
			goto fail8
		}
		// spaces?
		{
			pos11 := pos
			// spaces
			if !_accept(parser, _spacesAccepts, &pos, &perr) {
				goto fail12
			}
			goto ok13
		fail12:
			pos = pos11
		ok13:
		}
		// predicate_2
		if !_accept(parser, _predicate_2Accepts, &pos, &perr) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// predicate_3
		if !_accept(parser, _predicate_3Accepts, &pos, &perr) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _predicate_2, start, pos, perr)
fail:
	return _memoize(parser, _predicate_2, start, -1, perr)
}

func _predicate_2Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_predicate_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _predicate_2}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "predicate_2"}
	// forethought_coP_pred/LU_predicate/MI_predicate/PO_predicate/quotation_predicate/prefix spaces? predicate_2/predicate_3
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// forethought_coP_pred
		if !_node(parser, _forethought_coP_predNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// LU_predicate
		if !_node(parser, _LU_predicateNode, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// MI_predicate
		if !_node(parser, _MI_predicateNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// PO_predicate
		if !_node(parser, _PO_predicateNode, node, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// quotation_predicate
		if !_node(parser, _quotation_predicateNode, node, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// prefix spaces? predicate_2
		// prefix
		if !_node(parser, _prefixNode, node, &pos) {
			goto fail8
		}
		// spaces?
		{
			nkids10 := len(node.Kids)
			pos11 := pos
			// spaces
			if !_node(parser, _spacesNode, node, &pos) {
				goto fail12
			}
			goto ok13
		fail12:
			node.Kids = node.Kids[:nkids10]
			pos = pos11
		ok13:
		}
		// predicate_2
		if !_node(parser, _predicate_2Node, node, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// predicate_3
		if !_node(parser, _predicate_3Node, node, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _predicate_2Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _predicate_2, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "predicate_2",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _predicate_2}
	// forethought_coP_pred/LU_predicate/MI_predicate/PO_predicate/quotation_predicate/prefix spaces? predicate_2/predicate_3
	{
		pos2 := pos
		// forethought_coP_pred
		if !_fail(parser, _forethought_coP_predFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// LU_predicate
		if !_fail(parser, _LU_predicateFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// MI_predicate
		if !_fail(parser, _MI_predicateFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// PO_predicate
		if !_fail(parser, _PO_predicateFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// quotation_predicate
		if !_fail(parser, _quotation_predicateFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// prefix spaces? predicate_2
		// prefix
		if !_fail(parser, _prefixFail, errPos, failure, &pos) {
			goto fail8
		}
		// spaces?
		{
			pos11 := pos
			// spaces
			if !_fail(parser, _spacesFail, errPos, failure, &pos) {
				goto fail12
			}
			goto ok13
		fail12:
			pos = pos11
		ok13:
		}
		// predicate_2
		if !_fail(parser, _predicate_2Fail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// predicate_3
		if !_fail(parser, _predicate_3Fail, errPos, failure, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _predicate_2Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_predicate_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _predicate_2}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_coP_pred/LU_predicate/MI_predicate/PO_predicate/quotation_predicate/prefix spaces? predicate_2/predicate_3
	{
		pos2 := pos
		// forethought_coP_pred
		if p, n := _forethought_coP_predAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// LU_predicate
		if p, n := _LU_predicateAction(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		// MI_predicate
		if p, n := _MI_predicateAction(parser, pos); n == nil {
			goto fail5
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail5:
		pos = pos2
		// PO_predicate
		if p, n := _PO_predicateAction(parser, pos); n == nil {
			goto fail6
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail6:
		pos = pos2
		// quotation_predicate
		if p, n := _quotation_predicateAction(parser, pos); n == nil {
			goto fail7
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail7:
		pos = pos2
		// prefix spaces? predicate_2
		{
			var node9 string
			// prefix
			if p, n := _prefixAction(parser, pos); n == nil {
				goto fail8
			} else {
				node9 = *n
				pos = p
			}
			node += node9
			// spaces?
			{
				pos11 := pos
				// spaces
				if p, n := _spacesAction(parser, pos); n == nil {
					goto fail12
				} else {
					node9 = *n
					pos = p
				}
				goto ok13
			fail12:
				node9 = ""
				pos = pos11
			ok13:
			}
			node += node9
			// predicate_2
			if p, n := _predicate_2Action(parser, pos); n == nil {
				goto fail8
			} else {
				node9 = *n
				pos = p
			}
			node += node9
		}
		goto ok0
	fail8:
		pos = pos2
		// predicate_3
		if p, n := _predicate_3Action(parser, pos); n == nil {
			goto fail14
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail14:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _predicate_3Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _predicate_3, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// predicate_4 spaces? freemod?
	// predicate_4
	if !_accept(parser, _predicate_4Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// freemod?
	{
		pos6 := pos
		// freemod
		if !_accept(parser, _freemodAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	return _memoize(parser, _predicate_3, start, pos, perr)
fail:
	return _memoize(parser, _predicate_3, start, -1, perr)
}

func _predicate_3Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_predicate_3]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _predicate_3}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "predicate_3"}
	// predicate_4 spaces? freemod?
	// predicate_4
	if !_node(parser, _predicate_4Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// freemod?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// freemod
		if !_node(parser, _freemodNode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _predicate_3Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _predicate_3, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "predicate_3",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _predicate_3}
	// predicate_4 spaces? freemod?
	// predicate_4
	if !_fail(parser, _predicate_4Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// freemod?
	{
		pos6 := pos
		// freemod
		if !_fail(parser, _freemodFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _predicate_3Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_predicate_3]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _predicate_3}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// predicate_4 spaces? freemod?
	{
		var node0 string
		// predicate_4
		if p, n := _predicate_4Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// freemod?
		{
			pos6 := pos
			// freemod
			if p, n := _freemodAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _predicate_4Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _predicate_4, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// verb_syllable compound_syllable+/!function_word verb_syllable
	{
		pos2 := pos
		// verb_syllable compound_syllable+
		// verb_syllable
		if !_accept(parser, _verb_syllableAccepts, &pos, &perr) {
			goto fail3
		}
		// compound_syllable+
		// compound_syllable
		if !_accept(parser, _compound_syllableAccepts, &pos, &perr) {
			goto fail3
		}
		for {
			pos6 := pos
			// compound_syllable
			if !_accept(parser, _compound_syllableAccepts, &pos, &perr) {
				goto fail8
			}
			continue
		fail8:
			pos = pos6
			break
		}
		goto ok0
	fail3:
		pos = pos2
		// !function_word verb_syllable
		// !function_word
		{
			pos12 := pos
			perr14 := perr
			// function_word
			if !_accept(parser, _function_wordAccepts, &pos, &perr) {
				goto ok11
			}
			pos = pos12
			perr = _max(perr14, pos)
			goto fail9
		ok11:
			pos = pos12
			perr = perr14
		}
		// verb_syllable
		if !_accept(parser, _verb_syllableAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _predicate_4, start, pos, perr)
fail:
	return _memoize(parser, _predicate_4, start, -1, perr)
}

func _predicate_4Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_predicate_4]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _predicate_4}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "predicate_4"}
	// verb_syllable compound_syllable+/!function_word verb_syllable
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// verb_syllable compound_syllable+
		// verb_syllable
		if !_node(parser, _verb_syllableNode, node, &pos) {
			goto fail3
		}
		// compound_syllable+
		// compound_syllable
		if !_node(parser, _compound_syllableNode, node, &pos) {
			goto fail3
		}
		for {
			nkids5 := len(node.Kids)
			pos6 := pos
			// compound_syllable
			if !_node(parser, _compound_syllableNode, node, &pos) {
				goto fail8
			}
			continue
		fail8:
			node.Kids = node.Kids[:nkids5]
			pos = pos6
			break
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// !function_word verb_syllable
		// !function_word
		{
			pos12 := pos
			nkids13 := len(node.Kids)
			// function_word
			if !_node(parser, _function_wordNode, node, &pos) {
				goto ok11
			}
			pos = pos12
			node.Kids = node.Kids[:nkids13]
			goto fail9
		ok11:
			pos = pos12
			node.Kids = node.Kids[:nkids13]
		}
		// verb_syllable
		if !_node(parser, _verb_syllableNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _predicate_4Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _predicate_4, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "predicate_4",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _predicate_4}
	// verb_syllable compound_syllable+/!function_word verb_syllable
	{
		pos2 := pos
		// verb_syllable compound_syllable+
		// verb_syllable
		if !_fail(parser, _verb_syllableFail, errPos, failure, &pos) {
			goto fail3
		}
		// compound_syllable+
		// compound_syllable
		if !_fail(parser, _compound_syllableFail, errPos, failure, &pos) {
			goto fail3
		}
		for {
			pos6 := pos
			// compound_syllable
			if !_fail(parser, _compound_syllableFail, errPos, failure, &pos) {
				goto fail8
			}
			continue
		fail8:
			pos = pos6
			break
		}
		goto ok0
	fail3:
		pos = pos2
		// !function_word verb_syllable
		// !function_word
		{
			pos12 := pos
			nkids13 := len(failure.Kids)
			// function_word
			if !_fail(parser, _function_wordFail, errPos, failure, &pos) {
				goto ok11
			}
			pos = pos12
			failure.Kids = failure.Kids[:nkids13]
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "!function_word",
				})
			}
			goto fail9
		ok11:
			pos = pos12
			failure.Kids = failure.Kids[:nkids13]
		}
		// verb_syllable
		if !_fail(parser, _verb_syllableFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _predicate_4Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_predicate_4]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _predicate_4}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// verb_syllable compound_syllable+/!function_word verb_syllable
	{
		pos2 := pos
		// verb_syllable compound_syllable+
		{
			var node4 string
			// verb_syllable
			if p, n := _verb_syllableAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
			// compound_syllable+
			{
				var node7 string
				// compound_syllable
				if p, n := _compound_syllableAction(parser, pos); n == nil {
					goto fail3
				} else {
					node7 = *n
					pos = p
				}
				node4 += node7
			}
			for {
				pos6 := pos
				var node7 string
				// compound_syllable
				if p, n := _compound_syllableAction(parser, pos); n == nil {
					goto fail8
				} else {
					node7 = *n
					pos = p
				}
				node4 += node7
				continue
			fail8:
				pos = pos6
				break
			}
			node += node4
		}
		goto ok0
	fail3:
		pos = pos2
		// !function_word verb_syllable
		{
			var node10 string
			// !function_word
			{
				pos12 := pos
				// function_word
				if p, n := _function_wordAction(parser, pos); n == nil {
					goto ok11
				} else {
					pos = p
				}
				pos = pos12
				goto fail9
			ok11:
				pos = pos12
				node = ""
			}
			node += node10
			// verb_syllable
			if p, n := _verb_syllableAction(parser, pos); n == nil {
				goto fail9
			} else {
				node10 = *n
				pos = p
			}
			node += node10
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _serial_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _serial_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// serial_predicate_2/predicate_1
	{
		pos2 := pos
		// serial_predicate_2
		if !_accept(parser, _serial_predicate_2Accepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// predicate_1
		if !_accept(parser, _predicate_1Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _serial_predicate, start, pos, perr)
fail:
	return _memoize(parser, _serial_predicate, start, -1, perr)
}

func _serial_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_serial_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _serial_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "serial_predicate"}
	// serial_predicate_2/predicate_1
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// serial_predicate_2
		if !_node(parser, _serial_predicate_2Node, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// predicate_1
		if !_node(parser, _predicate_1Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _serial_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _serial_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "serial_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _serial_predicate}
	// serial_predicate_2/predicate_1
	{
		pos2 := pos
		// serial_predicate_2
		if !_fail(parser, _serial_predicate_2Fail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// predicate_1
		if !_fail(parser, _predicate_1Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _serial_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_serial_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _serial_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// serial_predicate_2/predicate_1
	{
		pos2 := pos
		// serial_predicate_2
		if p, n := _serial_predicate_2Action(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// predicate_1
		if p, n := _predicate_1Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _serial_predicate_2Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _serial_predicate_2, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// predicate_1 spaces? serial_predicate
	// predicate_1
	if !_accept(parser, _predicate_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// serial_predicate
	if !_accept(parser, _serial_predicateAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _serial_predicate_2, start, pos, perr)
fail:
	return _memoize(parser, _serial_predicate_2, start, -1, perr)
}

func _serial_predicate_2Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_serial_predicate_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _serial_predicate_2}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "serial_predicate_2"}
	// predicate_1 spaces? serial_predicate
	// predicate_1
	if !_node(parser, _predicate_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// serial_predicate
	if !_node(parser, _serial_predicateNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _serial_predicate_2Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _serial_predicate_2, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "serial_predicate_2",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _serial_predicate_2}
	// predicate_1 spaces? serial_predicate
	// predicate_1
	if !_fail(parser, _predicate_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// serial_predicate
	if !_fail(parser, _serial_predicateFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _serial_predicate_2Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_serial_predicate_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _serial_predicate_2}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// predicate_1 spaces? serial_predicate
	{
		var node0 string
		// predicate_1
		if p, n := _predicate_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// serial_predicate
		if p, n := _serial_predicateAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _coP_predAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _coP_pred, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// predicate_2 spaces? co_bar_pred
	// predicate_2
	if !_accept(parser, _predicate_2Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_pred
	if !_accept(parser, _co_bar_predAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _coP_pred, start, pos, perr)
fail:
	return _memoize(parser, _coP_pred, start, -1, perr)
}

func _coP_predNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_coP_pred]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_pred}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "coP_pred"}
	// predicate_2 spaces? co_bar_pred
	// predicate_2
	if !_node(parser, _predicate_2Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// co_bar_pred
	if !_node(parser, _co_bar_predNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _coP_predFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _coP_pred, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "coP_pred",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _coP_pred}
	// predicate_2 spaces? co_bar_pred
	// predicate_2
	if !_fail(parser, _predicate_2Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_pred
	if !_fail(parser, _co_bar_predFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _coP_predAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_coP_pred]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_pred}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// predicate_2 spaces? co_bar_pred
	{
		var node0 string
		// predicate_2
		if p, n := _predicate_2Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// co_bar_pred
		if p, n := _co_bar_predAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _co_bar_predAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _co_bar_pred, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// connective spaces? predicate_1
	// connective
	if !_accept(parser, _connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// predicate_1
	if !_accept(parser, _predicate_1Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _co_bar_pred, start, pos, perr)
fail:
	return _memoize(parser, _co_bar_pred, start, -1, perr)
}

func _co_bar_predNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_co_bar_pred]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _co_bar_pred}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "co_bar_pred"}
	// connective spaces? predicate_1
	// connective
	if !_node(parser, _connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// predicate_1
	if !_node(parser, _predicate_1Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _co_bar_predFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _co_bar_pred, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "co_bar_pred",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _co_bar_pred}
	// connective spaces? predicate_1
	// connective
	if !_fail(parser, _connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// predicate_1
	if !_fail(parser, _predicate_1Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _co_bar_predAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_co_bar_pred]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _co_bar_pred}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// connective spaces? predicate_1
	{
		var node0 string
		// connective
		if p, n := _connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// predicate_1
		if p, n := _predicate_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_predAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_pred, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_connective spaces? forethought_coP_pred_1
	// forethought_connective
	if !_accept(parser, _forethought_connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_pred_1
	if !_accept(parser, _forethought_coP_pred_1Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_pred, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_pred, start, -1, perr)
}

func _forethought_coP_predNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_pred]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_pred"}
	// forethought_connective spaces? forethought_coP_pred_1
	// forethought_connective
	if !_node(parser, _forethought_connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_coP_pred_1
	if !_node(parser, _forethought_coP_pred_1Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_predFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_pred, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_pred",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_pred}
	// forethought_connective spaces? forethought_coP_pred_1
	// forethought_connective
	if !_fail(parser, _forethought_connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_pred_1
	if !_fail(parser, _forethought_coP_pred_1Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_predAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_pred]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_connective spaces? forethought_coP_pred_1
	{
		var node0 string
		// forethought_connective
		if p, n := _forethought_connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_coP_pred_1
		if p, n := _forethought_coP_pred_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_pred_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_pred_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// predicate spaces? forethought_co_bar_pred
	// predicate
	if !_accept(parser, _predicateAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_pred
	if !_accept(parser, _forethought_co_bar_predAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_pred_1, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_pred_1, start, -1, perr)
}

func _forethought_coP_pred_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_pred_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_pred_1"}
	// predicate spaces? forethought_co_bar_pred
	// predicate
	if !_node(parser, _predicateNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_co_bar_pred
	if !_node(parser, _forethought_co_bar_predNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_pred_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_pred_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_pred_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_pred_1}
	// predicate spaces? forethought_co_bar_pred
	// predicate
	if !_fail(parser, _predicateFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_pred
	if !_fail(parser, _forethought_co_bar_predFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_pred_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_pred_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// predicate spaces? forethought_co_bar_pred
	{
		var node0 string
		// predicate
		if p, n := _predicateAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_co_bar_pred
		if p, n := _forethought_co_bar_predAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_co_bar_predAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_co_bar_pred, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// gik spaces? predicate
	// gik
	if !_accept(parser, _gikAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// predicate
	if !_accept(parser, _predicateAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_co_bar_pred, start, pos, perr)
fail:
	return _memoize(parser, _forethought_co_bar_pred, start, -1, perr)
}

func _forethought_co_bar_predNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_co_bar_pred]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_pred}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_co_bar_pred"}
	// gik spaces? predicate
	// gik
	if !_node(parser, _gikNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// predicate
	if !_node(parser, _predicateNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_co_bar_predFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_co_bar_pred, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_co_bar_pred",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_co_bar_pred}
	// gik spaces? predicate
	// gik
	if !_fail(parser, _gikFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// predicate
	if !_fail(parser, _predicateFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_co_bar_predAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_co_bar_pred]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_pred}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// gik spaces? predicate
	{
		var node0 string
		// gik
		if p, n := _gikAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// predicate
		if p, n := _predicateAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _LU_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _LU_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// LU_predicate_tone spaces? statement
	// LU_predicate_tone
	if !_accept(parser, _LU_predicate_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// statement
	if !_accept(parser, _statementAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _LU_predicate, start, pos, perr)
fail:
	return _memoize(parser, _LU_predicate, start, -1, perr)
}

func _LU_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_LU_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "LU_predicate"}
	// LU_predicate_tone spaces? statement
	// LU_predicate_tone
	if !_node(parser, _LU_predicate_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// statement
	if !_node(parser, _statementNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _LU_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _LU_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "LU_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _LU_predicate}
	// LU_predicate_tone spaces? statement
	// LU_predicate_tone
	if !_fail(parser, _LU_predicate_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// statement
	if !_fail(parser, _statementFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _LU_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_LU_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// LU_predicate_tone spaces? statement
	{
		var node0 string
		// LU_predicate_tone
		if p, n := _LU_predicate_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// statement
		if p, n := _statementAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _LU_predicate_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _LU_predicate_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &LU verb_syllable
	// &LU
	{
		pos2 := pos
		perr4 := perr
		// LU
		if !_accept(parser, _LUAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// verb_syllable
	if !_accept(parser, _verb_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _LU_predicate_tone, start, pos, perr)
fail:
	return _memoize(parser, _LU_predicate_tone, start, -1, perr)
}

func _LU_predicate_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_LU_predicate_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_predicate_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "LU_predicate_tone"}
	// &LU verb_syllable
	// &LU
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// LU
		if !_node(parser, _LUNode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// verb_syllable
	if !_node(parser, _verb_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _LU_predicate_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _LU_predicate_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "LU_predicate_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _LU_predicate_tone}
	// &LU verb_syllable
	// &LU
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// LU
		if !_fail(parser, _LUFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&LU",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// verb_syllable
	if !_fail(parser, _verb_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _LU_predicate_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_LU_predicate_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_predicate_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &LU verb_syllable
	{
		var node0 string
		// &LU
		{
			pos2 := pos
			// LU
			if p, n := _LUAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// verb_syllable
		if p, n := _verb_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MI_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MI_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MI_predicate_1 spaces? GA?
	// MI_predicate_1
	if !_accept(parser, _MI_predicate_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_accept(parser, _GAAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	return _memoize(parser, _MI_predicate, start, pos, perr)
fail:
	return _memoize(parser, _MI_predicate, start, -1, perr)
}

func _MI_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MI_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MI_predicate"}
	// MI_predicate_1 spaces? GA?
	// MI_predicate_1
	if !_node(parser, _MI_predicate_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// GA?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// GA
		if !_node(parser, _GANode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MI_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MI_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MI_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MI_predicate}
	// MI_predicate_1 spaces? GA?
	// MI_predicate_1
	if !_fail(parser, _MI_predicate_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_fail(parser, _GAFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MI_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MI_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MI_predicate_1 spaces? GA?
	{
		var node0 string
		// MI_predicate_1
		if p, n := _MI_predicate_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// GA?
		{
			pos6 := pos
			// GA
			if p, n := _GAAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MI_predicate_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MI_predicate_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MI_predicate_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	// MI_predicate_tone
	if !_accept(parser, _MI_predicate_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// (predicate/argument/adverb/prepositional_phrase)
	// predicate/argument/adverb/prepositional_phrase
	{
		pos7 := pos
		// predicate
		if !_accept(parser, _predicateAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok5
	fail8:
		pos = pos7
		// argument
		if !_accept(parser, _argumentAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok5
	fail9:
		pos = pos7
		// adverb
		if !_accept(parser, _adverbAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok5
	fail10:
		pos = pos7
		// prepositional_phrase
		if !_accept(parser, _prepositional_phraseAccepts, &pos, &perr) {
			goto fail11
		}
		goto ok5
	fail11:
		pos = pos7
		goto fail
	ok5:
	}
	return _memoize(parser, _MI_predicate_1, start, pos, perr)
fail:
	return _memoize(parser, _MI_predicate_1, start, -1, perr)
}

func _MI_predicate_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MI_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_predicate_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MI_predicate_1"}
	// MI_predicate_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	// MI_predicate_tone
	if !_node(parser, _MI_predicate_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// (predicate/argument/adverb/prepositional_phrase)
	{
		nkids5 := len(node.Kids)
		pos06 := pos
		// predicate/argument/adverb/prepositional_phrase
		{
			pos9 := pos
			nkids8 := len(node.Kids)
			// predicate
			if !_node(parser, _predicateNode, node, &pos) {
				goto fail10
			}
			goto ok7
		fail10:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// argument
			if !_node(parser, _argumentNode, node, &pos) {
				goto fail11
			}
			goto ok7
		fail11:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// adverb
			if !_node(parser, _adverbNode, node, &pos) {
				goto fail12
			}
			goto ok7
		fail12:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// prepositional_phrase
			if !_node(parser, _prepositional_phraseNode, node, &pos) {
				goto fail13
			}
			goto ok7
		fail13:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			goto fail
		ok7:
		}
		sub := _sub(parser, pos06, pos, node.Kids[nkids5:])
		node.Kids = append(node.Kids[:nkids5], sub)
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MI_predicate_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MI_predicate_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MI_predicate_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MI_predicate_1}
	// MI_predicate_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	// MI_predicate_tone
	if !_fail(parser, _MI_predicate_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// (predicate/argument/adverb/prepositional_phrase)
	// predicate/argument/adverb/prepositional_phrase
	{
		pos7 := pos
		// predicate
		if !_fail(parser, _predicateFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok5
	fail8:
		pos = pos7
		// argument
		if !_fail(parser, _argumentFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok5
	fail9:
		pos = pos7
		// adverb
		if !_fail(parser, _adverbFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok5
	fail10:
		pos = pos7
		// prepositional_phrase
		if !_fail(parser, _prepositional_phraseFail, errPos, failure, &pos) {
			goto fail11
		}
		goto ok5
	fail11:
		pos = pos7
		goto fail
	ok5:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MI_predicate_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MI_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_predicate_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MI_predicate_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	{
		var node0 string
		// MI_predicate_tone
		if p, n := _MI_predicate_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// (predicate/argument/adverb/prepositional_phrase)
		// predicate/argument/adverb/prepositional_phrase
		{
			pos7 := pos
			// predicate
			if p, n := _predicateAction(parser, pos); n == nil {
				goto fail8
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail8:
			pos = pos7
			// argument
			if p, n := _argumentAction(parser, pos); n == nil {
				goto fail9
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail9:
			pos = pos7
			// adverb
			if p, n := _adverbAction(parser, pos); n == nil {
				goto fail10
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail10:
			pos = pos7
			// prepositional_phrase
			if p, n := _prepositional_phraseAction(parser, pos); n == nil {
				goto fail11
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail11:
			pos = pos7
			goto fail
		ok5:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MI_predicate_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MI_predicate_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &MI verb_syllable
	// &MI
	{
		pos2 := pos
		perr4 := perr
		// MI
		if !_accept(parser, _MIAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// verb_syllable
	if !_accept(parser, _verb_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _MI_predicate_tone, start, pos, perr)
fail:
	return _memoize(parser, _MI_predicate_tone, start, -1, perr)
}

func _MI_predicate_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MI_predicate_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_predicate_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MI_predicate_tone"}
	// &MI verb_syllable
	// &MI
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// MI
		if !_node(parser, _MINode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// verb_syllable
	if !_node(parser, _verb_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MI_predicate_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MI_predicate_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MI_predicate_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MI_predicate_tone}
	// &MI verb_syllable
	// &MI
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// MI
		if !_fail(parser, _MIFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&MI",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// verb_syllable
	if !_fail(parser, _verb_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MI_predicate_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MI_predicate_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_predicate_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &MI verb_syllable
	{
		var node0 string
		// &MI
		{
			pos2 := pos
			// MI
			if p, n := _MIAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// verb_syllable
		if p, n := _verb_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _PO_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _PO_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// PO_predicate_1 spaces? GA?
	// PO_predicate_1
	if !_accept(parser, _PO_predicate_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_accept(parser, _GAAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	return _memoize(parser, _PO_predicate, start, pos, perr)
fail:
	return _memoize(parser, _PO_predicate, start, -1, perr)
}

func _PO_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_PO_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "PO_predicate"}
	// PO_predicate_1 spaces? GA?
	// PO_predicate_1
	if !_node(parser, _PO_predicate_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// GA?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// GA
		if !_node(parser, _GANode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _PO_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _PO_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "PO_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _PO_predicate}
	// PO_predicate_1 spaces? GA?
	// PO_predicate_1
	if !_fail(parser, _PO_predicate_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_fail(parser, _GAFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _PO_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_PO_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// PO_predicate_1 spaces? GA?
	{
		var node0 string
		// PO_predicate_1
		if p, n := _PO_predicate_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// GA?
		{
			pos6 := pos
			// GA
			if p, n := _GAAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _PO_predicate_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _PO_predicate_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// PO_predicate_tone spaces? argument
	// PO_predicate_tone
	if !_accept(parser, _PO_predicate_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// argument
	if !_accept(parser, _argumentAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _PO_predicate_1, start, pos, perr)
fail:
	return _memoize(parser, _PO_predicate_1, start, -1, perr)
}

func _PO_predicate_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_PO_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_predicate_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "PO_predicate_1"}
	// PO_predicate_tone spaces? argument
	// PO_predicate_tone
	if !_node(parser, _PO_predicate_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// argument
	if !_node(parser, _argumentNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _PO_predicate_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _PO_predicate_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "PO_predicate_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _PO_predicate_1}
	// PO_predicate_tone spaces? argument
	// PO_predicate_tone
	if !_fail(parser, _PO_predicate_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// argument
	if !_fail(parser, _argumentFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _PO_predicate_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_PO_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_predicate_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// PO_predicate_tone spaces? argument
	{
		var node0 string
		// PO_predicate_tone
		if p, n := _PO_predicate_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// argument
		if p, n := _argumentAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _PO_predicate_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _PO_predicate_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &PO verb_syllable
	// &PO
	{
		pos2 := pos
		perr4 := perr
		// PO
		if !_accept(parser, _POAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// verb_syllable
	if !_accept(parser, _verb_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _PO_predicate_tone, start, pos, perr)
fail:
	return _memoize(parser, _PO_predicate_tone, start, -1, perr)
}

func _PO_predicate_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_PO_predicate_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_predicate_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "PO_predicate_tone"}
	// &PO verb_syllable
	// &PO
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// PO
		if !_node(parser, _PONode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// verb_syllable
	if !_node(parser, _verb_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _PO_predicate_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _PO_predicate_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "PO_predicate_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _PO_predicate_tone}
	// &PO verb_syllable
	// &PO
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// PO
		if !_fail(parser, _POFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&PO",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// verb_syllable
	if !_fail(parser, _verb_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _PO_predicate_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_PO_predicate_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_predicate_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &PO verb_syllable
	{
		var node0 string
		// &PO
		{
			pos2 := pos
			// PO
			if p, n := _POAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// verb_syllable
		if p, n := _verb_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _quotation_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _quotation_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MO_predicate spaces? TEO
	// MO_predicate
	if !_accept(parser, _MO_predicateAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// TEO
	if !_accept(parser, _TEOAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _quotation_predicate, start, pos, perr)
fail:
	return _memoize(parser, _quotation_predicate, start, -1, perr)
}

func _quotation_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_quotation_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _quotation_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "quotation_predicate"}
	// MO_predicate spaces? TEO
	// MO_predicate
	if !_node(parser, _MO_predicateNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// TEO
	if !_node(parser, _TEONode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _quotation_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _quotation_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "quotation_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _quotation_predicate}
	// MO_predicate spaces? TEO
	// MO_predicate
	if !_fail(parser, _MO_predicateFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// TEO
	if !_fail(parser, _TEOFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _quotation_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_quotation_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _quotation_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MO_predicate spaces? TEO
	{
		var node0 string
		// MO_predicate
		if p, n := _MO_predicateAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// TEO
		if p, n := _TEOAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MO_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MO_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MO_predicate_tone spaces? discourse
	// MO_predicate_tone
	if !_accept(parser, _MO_predicate_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// discourse
	if !_accept(parser, _discourseAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _MO_predicate, start, pos, perr)
fail:
	return _memoize(parser, _MO_predicate, start, -1, perr)
}

func _MO_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MO_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MO_predicate"}
	// MO_predicate_tone spaces? discourse
	// MO_predicate_tone
	if !_node(parser, _MO_predicate_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// discourse
	if !_node(parser, _discourseNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MO_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MO_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MO_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MO_predicate}
	// MO_predicate_tone spaces? discourse
	// MO_predicate_tone
	if !_fail(parser, _MO_predicate_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// discourse
	if !_fail(parser, _discourseFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MO_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MO_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MO_predicate_tone spaces? discourse
	{
		var node0 string
		// MO_predicate_tone
		if p, n := _MO_predicate_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// discourse
		if p, n := _discourseAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MO_predicate_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MO_predicate_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &MO verb_syllable
	// &MO
	{
		pos2 := pos
		perr4 := perr
		// MO
		if !_accept(parser, _MOAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// verb_syllable
	if !_accept(parser, _verb_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _MO_predicate_tone, start, pos, perr)
fail:
	return _memoize(parser, _MO_predicate_tone, start, -1, perr)
}

func _MO_predicate_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MO_predicate_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_predicate_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MO_predicate_tone"}
	// &MO verb_syllable
	// &MO
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// MO
		if !_node(parser, _MONode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// verb_syllable
	if !_node(parser, _verb_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MO_predicate_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MO_predicate_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MO_predicate_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MO_predicate_tone}
	// &MO verb_syllable
	// &MO
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// MO
		if !_fail(parser, _MOFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&MO",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// verb_syllable
	if !_fail(parser, _verb_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MO_predicate_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MO_predicate_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_predicate_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &MO verb_syllable
	{
		var node0 string
		// &MO
		{
			pos2 := pos
			// MO
			if p, n := _MOAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// verb_syllable
		if p, n := _verb_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _termsAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _terms, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// terms_2/term
	{
		pos2 := pos
		// terms_2
		if !_accept(parser, _terms_2Accepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// term
		if !_accept(parser, _termAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _terms, start, pos, perr)
fail:
	return _memoize(parser, _terms, start, -1, perr)
}

func _termsNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_terms]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _terms}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "terms"}
	// terms_2/term
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// terms_2
		if !_node(parser, _terms_2Node, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// term
		if !_node(parser, _termNode, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _termsFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _terms, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "terms",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _terms}
	// terms_2/term
	{
		pos2 := pos
		// terms_2
		if !_fail(parser, _terms_2Fail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// term
		if !_fail(parser, _termFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _termsAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_terms]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _terms}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// terms_2/term
	{
		pos2 := pos
		// terms_2
		if p, n := _terms_2Action(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// term
		if p, n := _termAction(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _terms_2Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _terms_2, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// term spaces? terms
	// term
	if !_accept(parser, _termAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms
	if !_accept(parser, _termsAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _terms_2, start, pos, perr)
fail:
	return _memoize(parser, _terms_2, start, -1, perr)
}

func _terms_2Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_terms_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _terms_2}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "terms_2"}
	// term spaces? terms
	// term
	if !_node(parser, _termNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// terms
	if !_node(parser, _termsNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _terms_2Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _terms_2, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "terms_2",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _terms_2}
	// term spaces? terms
	// term
	if !_fail(parser, _termFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms
	if !_fail(parser, _termsFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _terms_2Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_terms_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _terms_2}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// term spaces? terms
	{
		var node0 string
		// term
		if p, n := _termAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// terms
		if p, n := _termsAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _termAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _term, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// (linking_word? spaces? argument)/adverb/termset/prepositional_phrase
	{
		pos2 := pos
		// (linking_word? spaces? argument)
		// linking_word? spaces? argument
		// linking_word?
		{
			pos6 := pos
			// linking_word
			if !_accept(parser, _linking_wordAccepts, &pos, &perr) {
				goto fail7
			}
			goto ok8
		fail7:
			pos = pos6
		ok8:
		}
		// spaces?
		{
			pos10 := pos
			// spaces
			if !_accept(parser, _spacesAccepts, &pos, &perr) {
				goto fail11
			}
			goto ok12
		fail11:
			pos = pos10
		ok12:
		}
		// argument
		if !_accept(parser, _argumentAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// adverb
		if !_accept(parser, _adverbAccepts, &pos, &perr) {
			goto fail13
		}
		goto ok0
	fail13:
		pos = pos2
		// termset
		if !_accept(parser, _termsetAccepts, &pos, &perr) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// prepositional_phrase
		if !_accept(parser, _prepositional_phraseAccepts, &pos, &perr) {
			goto fail15
		}
		goto ok0
	fail15:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _term, start, pos, perr)
fail:
	return _memoize(parser, _term, start, -1, perr)
}

func _termNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_term]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _term}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "term"}
	// (linking_word? spaces? argument)/adverb/termset/prepositional_phrase
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// (linking_word? spaces? argument)
		{
			nkids4 := len(node.Kids)
			pos05 := pos
			// linking_word? spaces? argument
			// linking_word?
			{
				nkids7 := len(node.Kids)
				pos8 := pos
				// linking_word
				if !_node(parser, _linking_wordNode, node, &pos) {
					goto fail9
				}
				goto ok10
			fail9:
				node.Kids = node.Kids[:nkids7]
				pos = pos8
			ok10:
			}
			// spaces?
			{
				nkids11 := len(node.Kids)
				pos12 := pos
				// spaces
				if !_node(parser, _spacesNode, node, &pos) {
					goto fail13
				}
				goto ok14
			fail13:
				node.Kids = node.Kids[:nkids11]
				pos = pos12
			ok14:
			}
			// argument
			if !_node(parser, _argumentNode, node, &pos) {
				goto fail3
			}
			sub := _sub(parser, pos05, pos, node.Kids[nkids4:])
			node.Kids = append(node.Kids[:nkids4], sub)
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// adverb
		if !_node(parser, _adverbNode, node, &pos) {
			goto fail15
		}
		goto ok0
	fail15:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// termset
		if !_node(parser, _termsetNode, node, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// prepositional_phrase
		if !_node(parser, _prepositional_phraseNode, node, &pos) {
			goto fail17
		}
		goto ok0
	fail17:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _termFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _term, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "term",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _term}
	// (linking_word? spaces? argument)/adverb/termset/prepositional_phrase
	{
		pos2 := pos
		// (linking_word? spaces? argument)
		// linking_word? spaces? argument
		// linking_word?
		{
			pos6 := pos
			// linking_word
			if !_fail(parser, _linking_wordFail, errPos, failure, &pos) {
				goto fail7
			}
			goto ok8
		fail7:
			pos = pos6
		ok8:
		}
		// spaces?
		{
			pos10 := pos
			// spaces
			if !_fail(parser, _spacesFail, errPos, failure, &pos) {
				goto fail11
			}
			goto ok12
		fail11:
			pos = pos10
		ok12:
		}
		// argument
		if !_fail(parser, _argumentFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// adverb
		if !_fail(parser, _adverbFail, errPos, failure, &pos) {
			goto fail13
		}
		goto ok0
	fail13:
		pos = pos2
		// termset
		if !_fail(parser, _termsetFail, errPos, failure, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// prepositional_phrase
		if !_fail(parser, _prepositional_phraseFail, errPos, failure, &pos) {
			goto fail15
		}
		goto ok0
	fail15:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _termAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_term]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _term}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// (linking_word? spaces? argument)/adverb/termset/prepositional_phrase
	{
		pos2 := pos
		// (linking_word? spaces? argument)
		// linking_word? spaces? argument
		{
			var node4 string
			// linking_word?
			{
				pos6 := pos
				// linking_word
				if p, n := _linking_wordAction(parser, pos); n == nil {
					goto fail7
				} else {
					node4 = *n
					pos = p
				}
				goto ok8
			fail7:
				node4 = ""
				pos = pos6
			ok8:
			}
			node += node4
			// spaces?
			{
				pos10 := pos
				// spaces
				if p, n := _spacesAction(parser, pos); n == nil {
					goto fail11
				} else {
					node4 = *n
					pos = p
				}
				goto ok12
			fail11:
				node4 = ""
				pos = pos10
			ok12:
			}
			node += node4
			// argument
			if p, n := _argumentAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
		}
		goto ok0
	fail3:
		pos = pos2
		// adverb
		if p, n := _adverbAction(parser, pos); n == nil {
			goto fail13
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail13:
		pos = pos2
		// termset
		if p, n := _termsetAction(parser, pos); n == nil {
			goto fail14
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail14:
		pos = pos2
		// prepositional_phrase
		if p, n := _prepositional_phraseAction(parser, pos); n == nil {
			goto fail15
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail15:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _argumentAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _argument, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// coP_arg/arg_1
	{
		pos2 := pos
		// coP_arg
		if !_accept(parser, _coP_argAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// arg_1
		if !_accept(parser, _arg_1Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _argument, start, pos, perr)
fail:
	return _memoize(parser, _argument, start, -1, perr)
}

func _argumentNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_argument]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _argument}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "argument"}
	// coP_arg/arg_1
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// coP_arg
		if !_node(parser, _coP_argNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// arg_1
		if !_node(parser, _arg_1Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _argumentFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _argument, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "argument",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _argument}
	// coP_arg/arg_1
	{
		pos2 := pos
		// coP_arg
		if !_fail(parser, _coP_argFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// arg_1
		if !_fail(parser, _arg_1Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _argumentAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_argument]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _argument}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// coP_arg/arg_1
	{
		pos2 := pos
		// coP_arg
		if p, n := _coP_argAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// arg_1
		if p, n := _arg_1Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _arg_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _arg_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_coP_arg/arg_2
	{
		pos2 := pos
		// forethought_coP_arg
		if !_accept(parser, _forethought_coP_argAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// arg_2
		if !_accept(parser, _arg_2Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _arg_1, start, pos, perr)
fail:
	return _memoize(parser, _arg_1, start, -1, perr)
}

func _arg_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_arg_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _arg_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "arg_1"}
	// forethought_coP_arg/arg_2
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// forethought_coP_arg
		if !_node(parser, _forethought_coP_argNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// arg_2
		if !_node(parser, _arg_2Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _arg_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _arg_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "arg_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _arg_1}
	// forethought_coP_arg/arg_2
	{
		pos2 := pos
		// forethought_coP_arg
		if !_fail(parser, _forethought_coP_argFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// arg_2
		if !_fail(parser, _arg_2Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _arg_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_arg_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _arg_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_coP_arg/arg_2
	{
		pos2 := pos
		// forethought_coP_arg
		if p, n := _forethought_coP_argAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// arg_2
		if p, n := _arg_2Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _arg_2Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _arg_2, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// focus? spaces? arg_3
	// focus?
	{
		pos2 := pos
		// focus
		if !_accept(parser, _focusAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// spaces?
	{
		pos6 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	// arg_3
	if !_accept(parser, _arg_3Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _arg_2, start, pos, perr)
fail:
	return _memoize(parser, _arg_2, start, -1, perr)
}

func _arg_2Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_arg_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _arg_2}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "arg_2"}
	// focus? spaces? arg_3
	// focus?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// focus
		if !_node(parser, _focusNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// spaces?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	// arg_3
	if !_node(parser, _arg_3Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _arg_2Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _arg_2, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "arg_2",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _arg_2}
	// focus? spaces? arg_3
	// focus?
	{
		pos2 := pos
		// focus
		if !_fail(parser, _focusFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// spaces?
	{
		pos6 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	// arg_3
	if !_fail(parser, _arg_3Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _arg_2Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_arg_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _arg_2}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// focus? spaces? arg_3
	{
		var node0 string
		// focus?
		{
			pos2 := pos
			// focus
			if p, n := _focusAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// spaces?
		{
			pos6 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
		// arg_3
		if p, n := _arg_3Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _arg_3Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _arg_3, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// quantifier? spaces? arg_4
	// quantifier?
	{
		pos2 := pos
		// quantifier
		if !_accept(parser, _quantifierAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// spaces?
	{
		pos6 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	// arg_4
	if !_accept(parser, _arg_4Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _arg_3, start, pos, perr)
fail:
	return _memoize(parser, _arg_3, start, -1, perr)
}

func _arg_3Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_arg_3]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _arg_3}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "arg_3"}
	// quantifier? spaces? arg_4
	// quantifier?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// quantifier
		if !_node(parser, _quantifierNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// spaces?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	// arg_4
	if !_node(parser, _arg_4Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _arg_3Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _arg_3, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "arg_3",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _arg_3}
	// quantifier? spaces? arg_4
	// quantifier?
	{
		pos2 := pos
		// quantifier
		if !_fail(parser, _quantifierFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// spaces?
	{
		pos6 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	// arg_4
	if !_fail(parser, _arg_4Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _arg_3Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_arg_3]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _arg_3}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// quantifier? spaces? arg_4
	{
		var node0 string
		// quantifier?
		{
			pos2 := pos
			// quantifier
			if p, n := _quantifierAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// spaces?
		{
			pos6 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
		// arg_4
		if p, n := _arg_4Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _arg_4Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _arg_4, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// arg_5 spaces? (relative_clause/freemod)?
	// arg_5
	if !_accept(parser, _arg_5Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// (relative_clause/freemod)?
	{
		pos6 := pos
		// (relative_clause/freemod)
		// relative_clause/freemod
		{
			pos10 := pos
			// relative_clause
			if !_accept(parser, _relative_clauseAccepts, &pos, &perr) {
				goto fail11
			}
			goto ok8
		fail11:
			pos = pos10
			// freemod
			if !_accept(parser, _freemodAccepts, &pos, &perr) {
				goto fail12
			}
			goto ok8
		fail12:
			pos = pos10
			goto fail7
		ok8:
		}
		goto ok13
	fail7:
		pos = pos6
	ok13:
	}
	return _memoize(parser, _arg_4, start, pos, perr)
fail:
	return _memoize(parser, _arg_4, start, -1, perr)
}

func _arg_4Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_arg_4]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _arg_4}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "arg_4"}
	// arg_5 spaces? (relative_clause/freemod)?
	// arg_5
	if !_node(parser, _arg_5Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// (relative_clause/freemod)?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// (relative_clause/freemod)
		{
			nkids8 := len(node.Kids)
			pos09 := pos
			// relative_clause/freemod
			{
				pos12 := pos
				nkids11 := len(node.Kids)
				// relative_clause
				if !_node(parser, _relative_clauseNode, node, &pos) {
					goto fail13
				}
				goto ok10
			fail13:
				node.Kids = node.Kids[:nkids11]
				pos = pos12
				// freemod
				if !_node(parser, _freemodNode, node, &pos) {
					goto fail14
				}
				goto ok10
			fail14:
				node.Kids = node.Kids[:nkids11]
				pos = pos12
				goto fail7
			ok10:
			}
			sub := _sub(parser, pos09, pos, node.Kids[nkids8:])
			node.Kids = append(node.Kids[:nkids8], sub)
		}
		goto ok15
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok15:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _arg_4Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _arg_4, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "arg_4",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _arg_4}
	// arg_5 spaces? (relative_clause/freemod)?
	// arg_5
	if !_fail(parser, _arg_5Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// (relative_clause/freemod)?
	{
		pos6 := pos
		// (relative_clause/freemod)
		// relative_clause/freemod
		{
			pos10 := pos
			// relative_clause
			if !_fail(parser, _relative_clauseFail, errPos, failure, &pos) {
				goto fail11
			}
			goto ok8
		fail11:
			pos = pos10
			// freemod
			if !_fail(parser, _freemodFail, errPos, failure, &pos) {
				goto fail12
			}
			goto ok8
		fail12:
			pos = pos10
			goto fail7
		ok8:
		}
		goto ok13
	fail7:
		pos = pos6
	ok13:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _arg_4Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_arg_4]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _arg_4}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// arg_5 spaces? (relative_clause/freemod)?
	{
		var node0 string
		// arg_5
		if p, n := _arg_5Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// (relative_clause/freemod)?
		{
			pos6 := pos
			// (relative_clause/freemod)
			// relative_clause/freemod
			{
				pos10 := pos
				// relative_clause
				if p, n := _relative_clauseAction(parser, pos); n == nil {
					goto fail11
				} else {
					node0 = *n
					pos = p
				}
				goto ok8
			fail11:
				pos = pos10
				// freemod
				if p, n := _freemodAction(parser, pos); n == nil {
					goto fail12
				} else {
					node0 = *n
					pos = p
				}
				goto ok8
			fail12:
				pos = pos10
				goto fail7
			ok8:
			}
			goto ok13
		fail7:
			node0 = ""
			pos = pos6
		ok13:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _arg_5Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _arg_5, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// serial_argument/arg_6
	{
		pos2 := pos
		// serial_argument
		if !_accept(parser, _serial_argumentAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// arg_6
		if !_accept(parser, _arg_6Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _arg_5, start, pos, perr)
fail:
	return _memoize(parser, _arg_5, start, -1, perr)
}

func _arg_5Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_arg_5]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _arg_5}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "arg_5"}
	// serial_argument/arg_6
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// serial_argument
		if !_node(parser, _serial_argumentNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// arg_6
		if !_node(parser, _arg_6Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _arg_5Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _arg_5, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "arg_5",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _arg_5}
	// serial_argument/arg_6
	{
		pos2 := pos
		// serial_argument
		if !_fail(parser, _serial_argumentFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// arg_6
		if !_fail(parser, _arg_6Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _arg_5Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_arg_5]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _arg_5}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// serial_argument/arg_6
	{
		pos2 := pos
		// serial_argument
		if p, n := _serial_argumentAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// arg_6
		if p, n := _arg_6Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _arg_6Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _arg_6, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// content_clause/coP_pred_arg/forethought_coP_pred_arg/LU_arg/MI_arg/PO_arg/quotation_argument/arg_7
	{
		pos2 := pos
		// content_clause
		if !_accept(parser, _content_clauseAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// coP_pred_arg
		if !_accept(parser, _coP_pred_argAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// forethought_coP_pred_arg
		if !_accept(parser, _forethought_coP_pred_argAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// LU_arg
		if !_accept(parser, _LU_argAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// MI_arg
		if !_accept(parser, _MI_argAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// PO_arg
		if !_accept(parser, _PO_argAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// quotation_argument
		if !_accept(parser, _quotation_argumentAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// arg_7
		if !_accept(parser, _arg_7Accepts, &pos, &perr) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _arg_6, start, pos, perr)
fail:
	return _memoize(parser, _arg_6, start, -1, perr)
}

func _arg_6Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_arg_6]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _arg_6}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "arg_6"}
	// content_clause/coP_pred_arg/forethought_coP_pred_arg/LU_arg/MI_arg/PO_arg/quotation_argument/arg_7
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// content_clause
		if !_node(parser, _content_clauseNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// coP_pred_arg
		if !_node(parser, _coP_pred_argNode, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// forethought_coP_pred_arg
		if !_node(parser, _forethought_coP_pred_argNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// LU_arg
		if !_node(parser, _LU_argNode, node, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// MI_arg
		if !_node(parser, _MI_argNode, node, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// PO_arg
		if !_node(parser, _PO_argNode, node, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// quotation_argument
		if !_node(parser, _quotation_argumentNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// arg_7
		if !_node(parser, _arg_7Node, node, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _arg_6Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _arg_6, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "arg_6",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _arg_6}
	// content_clause/coP_pred_arg/forethought_coP_pred_arg/LU_arg/MI_arg/PO_arg/quotation_argument/arg_7
	{
		pos2 := pos
		// content_clause
		if !_fail(parser, _content_clauseFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// coP_pred_arg
		if !_fail(parser, _coP_pred_argFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// forethought_coP_pred_arg
		if !_fail(parser, _forethought_coP_pred_argFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// LU_arg
		if !_fail(parser, _LU_argFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// MI_arg
		if !_fail(parser, _MI_argFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// PO_arg
		if !_fail(parser, _PO_argFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// quotation_argument
		if !_fail(parser, _quotation_argumentFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// arg_7
		if !_fail(parser, _arg_7Fail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _arg_6Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_arg_6]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _arg_6}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// content_clause/coP_pred_arg/forethought_coP_pred_arg/LU_arg/MI_arg/PO_arg/quotation_argument/arg_7
	{
		pos2 := pos
		// content_clause
		if p, n := _content_clauseAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// coP_pred_arg
		if p, n := _coP_pred_argAction(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		// forethought_coP_pred_arg
		if p, n := _forethought_coP_pred_argAction(parser, pos); n == nil {
			goto fail5
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail5:
		pos = pos2
		// LU_arg
		if p, n := _LU_argAction(parser, pos); n == nil {
			goto fail6
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail6:
		pos = pos2
		// MI_arg
		if p, n := _MI_argAction(parser, pos); n == nil {
			goto fail7
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail7:
		pos = pos2
		// PO_arg
		if p, n := _PO_argAction(parser, pos); n == nil {
			goto fail8
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail8:
		pos = pos2
		// quotation_argument
		if p, n := _quotation_argumentAction(parser, pos); n == nil {
			goto fail9
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail9:
		pos = pos2
		// arg_7
		if p, n := _arg_7Action(parser, pos); n == nil {
			goto fail10
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _arg_7Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _arg_7, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// arg_syllable compound_syllable+/!function_word arg_syllable
	{
		pos2 := pos
		// arg_syllable compound_syllable+
		// arg_syllable
		if !_accept(parser, _arg_syllableAccepts, &pos, &perr) {
			goto fail3
		}
		// compound_syllable+
		// compound_syllable
		if !_accept(parser, _compound_syllableAccepts, &pos, &perr) {
			goto fail3
		}
		for {
			pos6 := pos
			// compound_syllable
			if !_accept(parser, _compound_syllableAccepts, &pos, &perr) {
				goto fail8
			}
			continue
		fail8:
			pos = pos6
			break
		}
		goto ok0
	fail3:
		pos = pos2
		// !function_word arg_syllable
		// !function_word
		{
			pos12 := pos
			perr14 := perr
			// function_word
			if !_accept(parser, _function_wordAccepts, &pos, &perr) {
				goto ok11
			}
			pos = pos12
			perr = _max(perr14, pos)
			goto fail9
		ok11:
			pos = pos12
			perr = perr14
		}
		// arg_syllable
		if !_accept(parser, _arg_syllableAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _arg_7, start, pos, perr)
fail:
	return _memoize(parser, _arg_7, start, -1, perr)
}

func _arg_7Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_arg_7]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _arg_7}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "arg_7"}
	// arg_syllable compound_syllable+/!function_word arg_syllable
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// arg_syllable compound_syllable+
		// arg_syllable
		if !_node(parser, _arg_syllableNode, node, &pos) {
			goto fail3
		}
		// compound_syllable+
		// compound_syllable
		if !_node(parser, _compound_syllableNode, node, &pos) {
			goto fail3
		}
		for {
			nkids5 := len(node.Kids)
			pos6 := pos
			// compound_syllable
			if !_node(parser, _compound_syllableNode, node, &pos) {
				goto fail8
			}
			continue
		fail8:
			node.Kids = node.Kids[:nkids5]
			pos = pos6
			break
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// !function_word arg_syllable
		// !function_word
		{
			pos12 := pos
			nkids13 := len(node.Kids)
			// function_word
			if !_node(parser, _function_wordNode, node, &pos) {
				goto ok11
			}
			pos = pos12
			node.Kids = node.Kids[:nkids13]
			goto fail9
		ok11:
			pos = pos12
			node.Kids = node.Kids[:nkids13]
		}
		// arg_syllable
		if !_node(parser, _arg_syllableNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _arg_7Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _arg_7, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "arg_7",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _arg_7}
	// arg_syllable compound_syllable+/!function_word arg_syllable
	{
		pos2 := pos
		// arg_syllable compound_syllable+
		// arg_syllable
		if !_fail(parser, _arg_syllableFail, errPos, failure, &pos) {
			goto fail3
		}
		// compound_syllable+
		// compound_syllable
		if !_fail(parser, _compound_syllableFail, errPos, failure, &pos) {
			goto fail3
		}
		for {
			pos6 := pos
			// compound_syllable
			if !_fail(parser, _compound_syllableFail, errPos, failure, &pos) {
				goto fail8
			}
			continue
		fail8:
			pos = pos6
			break
		}
		goto ok0
	fail3:
		pos = pos2
		// !function_word arg_syllable
		// !function_word
		{
			pos12 := pos
			nkids13 := len(failure.Kids)
			// function_word
			if !_fail(parser, _function_wordFail, errPos, failure, &pos) {
				goto ok11
			}
			pos = pos12
			failure.Kids = failure.Kids[:nkids13]
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "!function_word",
				})
			}
			goto fail9
		ok11:
			pos = pos12
			failure.Kids = failure.Kids[:nkids13]
		}
		// arg_syllable
		if !_fail(parser, _arg_syllableFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _arg_7Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_arg_7]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _arg_7}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// arg_syllable compound_syllable+/!function_word arg_syllable
	{
		pos2 := pos
		// arg_syllable compound_syllable+
		{
			var node4 string
			// arg_syllable
			if p, n := _arg_syllableAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
			// compound_syllable+
			{
				var node7 string
				// compound_syllable
				if p, n := _compound_syllableAction(parser, pos); n == nil {
					goto fail3
				} else {
					node7 = *n
					pos = p
				}
				node4 += node7
			}
			for {
				pos6 := pos
				var node7 string
				// compound_syllable
				if p, n := _compound_syllableAction(parser, pos); n == nil {
					goto fail8
				} else {
					node7 = *n
					pos = p
				}
				node4 += node7
				continue
			fail8:
				pos = pos6
				break
			}
			node += node4
		}
		goto ok0
	fail3:
		pos = pos2
		// !function_word arg_syllable
		{
			var node10 string
			// !function_word
			{
				pos12 := pos
				// function_word
				if p, n := _function_wordAction(parser, pos); n == nil {
					goto ok11
				} else {
					pos = p
				}
				pos = pos12
				goto fail9
			ok11:
				pos = pos12
				node = ""
			}
			node += node10
			// arg_syllable
			if p, n := _arg_syllableAction(parser, pos); n == nil {
				goto fail9
			} else {
				node10 = *n
				pos = p
			}
			node += node10
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _serial_argumentAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _serial_argument, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// arg_6 spaces? serial_predicate
	// arg_6
	if !_accept(parser, _arg_6Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// serial_predicate
	if !_accept(parser, _serial_predicateAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _serial_argument, start, pos, perr)
fail:
	return _memoize(parser, _serial_argument, start, -1, perr)
}

func _serial_argumentNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_serial_argument]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _serial_argument}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "serial_argument"}
	// arg_6 spaces? serial_predicate
	// arg_6
	if !_node(parser, _arg_6Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// serial_predicate
	if !_node(parser, _serial_predicateNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _serial_argumentFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _serial_argument, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "serial_argument",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _serial_argument}
	// arg_6 spaces? serial_predicate
	// arg_6
	if !_fail(parser, _arg_6Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// serial_predicate
	if !_fail(parser, _serial_predicateFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _serial_argumentAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_serial_argument]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _serial_argument}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// arg_6 spaces? serial_predicate
	{
		var node0 string
		// arg_6
		if p, n := _arg_6Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// serial_predicate
		if p, n := _serial_predicateAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _coP_argAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _coP_arg, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// arg_1 spaces? co_bar_arg
	// arg_1
	if !_accept(parser, _arg_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_arg
	if !_accept(parser, _co_bar_argAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _coP_arg, start, pos, perr)
fail:
	return _memoize(parser, _coP_arg, start, -1, perr)
}

func _coP_argNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_coP_arg]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_arg}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "coP_arg"}
	// arg_1 spaces? co_bar_arg
	// arg_1
	if !_node(parser, _arg_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// co_bar_arg
	if !_node(parser, _co_bar_argNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _coP_argFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _coP_arg, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "coP_arg",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _coP_arg}
	// arg_1 spaces? co_bar_arg
	// arg_1
	if !_fail(parser, _arg_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_arg
	if !_fail(parser, _co_bar_argFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _coP_argAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_coP_arg]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_arg}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// arg_1 spaces? co_bar_arg
	{
		var node0 string
		// arg_1
		if p, n := _arg_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// co_bar_arg
		if p, n := _co_bar_argAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _co_bar_argAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _co_bar_arg, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// connective spaces? arg_1
	// connective
	if !_accept(parser, _connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// arg_1
	if !_accept(parser, _arg_1Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _co_bar_arg, start, pos, perr)
fail:
	return _memoize(parser, _co_bar_arg, start, -1, perr)
}

func _co_bar_argNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_co_bar_arg]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _co_bar_arg}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "co_bar_arg"}
	// connective spaces? arg_1
	// connective
	if !_node(parser, _connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// arg_1
	if !_node(parser, _arg_1Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _co_bar_argFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _co_bar_arg, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "co_bar_arg",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _co_bar_arg}
	// connective spaces? arg_1
	// connective
	if !_fail(parser, _connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// arg_1
	if !_fail(parser, _arg_1Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _co_bar_argAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_co_bar_arg]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _co_bar_arg}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// connective spaces? arg_1
	{
		var node0 string
		// connective
		if p, n := _connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// arg_1
		if p, n := _arg_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_argAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_arg, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_connective spaces? forethought_coP_arg_1
	// forethought_connective
	if !_accept(parser, _forethought_connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_arg_1
	if !_accept(parser, _forethought_coP_arg_1Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_arg, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_arg, start, -1, perr)
}

func _forethought_coP_argNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_arg]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_arg}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_arg"}
	// forethought_connective spaces? forethought_coP_arg_1
	// forethought_connective
	if !_node(parser, _forethought_connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_coP_arg_1
	if !_node(parser, _forethought_coP_arg_1Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_argFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_arg, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_arg",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_arg}
	// forethought_connective spaces? forethought_coP_arg_1
	// forethought_connective
	if !_fail(parser, _forethought_connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_arg_1
	if !_fail(parser, _forethought_coP_arg_1Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_argAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_arg]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_arg}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_connective spaces? forethought_coP_arg_1
	{
		var node0 string
		// forethought_connective
		if p, n := _forethought_connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_coP_arg_1
		if p, n := _forethought_coP_arg_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_arg_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_arg_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// argument spaces? forethought_co_bar_arg
	// argument
	if !_accept(parser, _argumentAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_arg
	if !_accept(parser, _forethought_co_bar_argAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_arg_1, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_arg_1, start, -1, perr)
}

func _forethought_coP_arg_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_arg_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_arg_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_arg_1"}
	// argument spaces? forethought_co_bar_arg
	// argument
	if !_node(parser, _argumentNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_co_bar_arg
	if !_node(parser, _forethought_co_bar_argNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_arg_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_arg_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_arg_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_arg_1}
	// argument spaces? forethought_co_bar_arg
	// argument
	if !_fail(parser, _argumentFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_arg
	if !_fail(parser, _forethought_co_bar_argFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_arg_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_arg_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_arg_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// argument spaces? forethought_co_bar_arg
	{
		var node0 string
		// argument
		if p, n := _argumentAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_co_bar_arg
		if p, n := _forethought_co_bar_argAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_co_bar_argAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_co_bar_arg, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// gik spaces? argument
	// gik
	if !_accept(parser, _gikAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// argument
	if !_accept(parser, _argumentAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_co_bar_arg, start, pos, perr)
fail:
	return _memoize(parser, _forethought_co_bar_arg, start, -1, perr)
}

func _forethought_co_bar_argNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_co_bar_arg]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_arg}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_co_bar_arg"}
	// gik spaces? argument
	// gik
	if !_node(parser, _gikNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// argument
	if !_node(parser, _argumentNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_co_bar_argFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_co_bar_arg, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_co_bar_arg",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_co_bar_arg}
	// gik spaces? argument
	// gik
	if !_fail(parser, _gikFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// argument
	if !_fail(parser, _argumentFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_co_bar_argAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_co_bar_arg]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_arg}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// gik spaces? argument
	{
		var node0 string
		// gik
		if p, n := _gikAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// argument
		if p, n := _argumentAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _coP_pred_argAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _coP_pred_arg, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// arg_7 spaces? co_bar_pred
	// arg_7
	if !_accept(parser, _arg_7Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_pred
	if !_accept(parser, _co_bar_predAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _coP_pred_arg, start, pos, perr)
fail:
	return _memoize(parser, _coP_pred_arg, start, -1, perr)
}

func _coP_pred_argNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_coP_pred_arg]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_pred_arg}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "coP_pred_arg"}
	// arg_7 spaces? co_bar_pred
	// arg_7
	if !_node(parser, _arg_7Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// co_bar_pred
	if !_node(parser, _co_bar_predNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _coP_pred_argFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _coP_pred_arg, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "coP_pred_arg",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _coP_pred_arg}
	// arg_7 spaces? co_bar_pred
	// arg_7
	if !_fail(parser, _arg_7Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_pred
	if !_fail(parser, _co_bar_predFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _coP_pred_argAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_coP_pred_arg]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_pred_arg}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// arg_7 spaces? co_bar_pred
	{
		var node0 string
		// arg_7
		if p, n := _arg_7Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// co_bar_pred
		if p, n := _co_bar_predAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_pred_argAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_pred_arg, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_connective spaces? forethought_coP_pred_arg_1
	// forethought_connective
	if !_accept(parser, _forethought_connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_pred_arg_1
	if !_accept(parser, _forethought_coP_pred_arg_1Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_pred_arg, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_pred_arg, start, -1, perr)
}

func _forethought_coP_pred_argNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_pred_arg]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_arg}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_pred_arg"}
	// forethought_connective spaces? forethought_coP_pred_arg_1
	// forethought_connective
	if !_node(parser, _forethought_connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_coP_pred_arg_1
	if !_node(parser, _forethought_coP_pred_arg_1Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_pred_argFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_pred_arg, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_pred_arg",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_pred_arg}
	// forethought_connective spaces? forethought_coP_pred_arg_1
	// forethought_connective
	if !_fail(parser, _forethought_connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_pred_arg_1
	if !_fail(parser, _forethought_coP_pred_arg_1Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_pred_argAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_pred_arg]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_arg}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_connective spaces? forethought_coP_pred_arg_1
	{
		var node0 string
		// forethought_connective
		if p, n := _forethought_connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_coP_pred_arg_1
		if p, n := _forethought_coP_pred_arg_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_pred_arg_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_pred_arg_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// argument spaces? forethought_co_bar_pred
	// argument
	if !_accept(parser, _argumentAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_pred
	if !_accept(parser, _forethought_co_bar_predAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_pred_arg_1, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_pred_arg_1, start, -1, perr)
}

func _forethought_coP_pred_arg_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_pred_arg_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_arg_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_pred_arg_1"}
	// argument spaces? forethought_co_bar_pred
	// argument
	if !_node(parser, _argumentNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_co_bar_pred
	if !_node(parser, _forethought_co_bar_predNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_pred_arg_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_pred_arg_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_pred_arg_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_pred_arg_1}
	// argument spaces? forethought_co_bar_pred
	// argument
	if !_fail(parser, _argumentFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_pred
	if !_fail(parser, _forethought_co_bar_predFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_pred_arg_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_pred_arg_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_arg_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// argument spaces? forethought_co_bar_pred
	{
		var node0 string
		// argument
		if p, n := _argumentAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_co_bar_pred
		if p, n := _forethought_co_bar_predAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _LU_argAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _LU_arg, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// LU_arg_tone spaces? statement
	// LU_arg_tone
	if !_accept(parser, _LU_arg_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// statement
	if !_accept(parser, _statementAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _LU_arg, start, pos, perr)
fail:
	return _memoize(parser, _LU_arg, start, -1, perr)
}

func _LU_argNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_LU_arg]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_arg}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "LU_arg"}
	// LU_arg_tone spaces? statement
	// LU_arg_tone
	if !_node(parser, _LU_arg_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// statement
	if !_node(parser, _statementNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _LU_argFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _LU_arg, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "LU_arg",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _LU_arg}
	// LU_arg_tone spaces? statement
	// LU_arg_tone
	if !_fail(parser, _LU_arg_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// statement
	if !_fail(parser, _statementFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _LU_argAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_LU_arg]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_arg}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// LU_arg_tone spaces? statement
	{
		var node0 string
		// LU_arg_tone
		if p, n := _LU_arg_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// statement
		if p, n := _statementAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _LU_arg_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _LU_arg_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &LU arg_syllable
	// &LU
	{
		pos2 := pos
		perr4 := perr
		// LU
		if !_accept(parser, _LUAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// arg_syllable
	if !_accept(parser, _arg_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _LU_arg_tone, start, pos, perr)
fail:
	return _memoize(parser, _LU_arg_tone, start, -1, perr)
}

func _LU_arg_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_LU_arg_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_arg_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "LU_arg_tone"}
	// &LU arg_syllable
	// &LU
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// LU
		if !_node(parser, _LUNode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// arg_syllable
	if !_node(parser, _arg_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _LU_arg_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _LU_arg_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "LU_arg_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _LU_arg_tone}
	// &LU arg_syllable
	// &LU
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// LU
		if !_fail(parser, _LUFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&LU",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// arg_syllable
	if !_fail(parser, _arg_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _LU_arg_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_LU_arg_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_arg_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &LU arg_syllable
	{
		var node0 string
		// &LU
		{
			pos2 := pos
			// LU
			if p, n := _LUAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// arg_syllable
		if p, n := _arg_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MI_argAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MI_arg, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MI_arg_1 spaces? GA?
	// MI_arg_1
	if !_accept(parser, _MI_arg_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_accept(parser, _GAAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	return _memoize(parser, _MI_arg, start, pos, perr)
fail:
	return _memoize(parser, _MI_arg, start, -1, perr)
}

func _MI_argNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MI_arg]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_arg}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MI_arg"}
	// MI_arg_1 spaces? GA?
	// MI_arg_1
	if !_node(parser, _MI_arg_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// GA?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// GA
		if !_node(parser, _GANode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MI_argFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MI_arg, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MI_arg",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MI_arg}
	// MI_arg_1 spaces? GA?
	// MI_arg_1
	if !_fail(parser, _MI_arg_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_fail(parser, _GAFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MI_argAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MI_arg]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_arg}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MI_arg_1 spaces? GA?
	{
		var node0 string
		// MI_arg_1
		if p, n := _MI_arg_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// GA?
		{
			pos6 := pos
			// GA
			if p, n := _GAAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MI_arg_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MI_arg_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MI_arg_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	// MI_arg_tone
	if !_accept(parser, _MI_arg_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// (predicate/argument/adverb/prepositional_phrase)
	// predicate/argument/adverb/prepositional_phrase
	{
		pos7 := pos
		// predicate
		if !_accept(parser, _predicateAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok5
	fail8:
		pos = pos7
		// argument
		if !_accept(parser, _argumentAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok5
	fail9:
		pos = pos7
		// adverb
		if !_accept(parser, _adverbAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok5
	fail10:
		pos = pos7
		// prepositional_phrase
		if !_accept(parser, _prepositional_phraseAccepts, &pos, &perr) {
			goto fail11
		}
		goto ok5
	fail11:
		pos = pos7
		goto fail
	ok5:
	}
	return _memoize(parser, _MI_arg_1, start, pos, perr)
fail:
	return _memoize(parser, _MI_arg_1, start, -1, perr)
}

func _MI_arg_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MI_arg_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_arg_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MI_arg_1"}
	// MI_arg_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	// MI_arg_tone
	if !_node(parser, _MI_arg_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// (predicate/argument/adverb/prepositional_phrase)
	{
		nkids5 := len(node.Kids)
		pos06 := pos
		// predicate/argument/adverb/prepositional_phrase
		{
			pos9 := pos
			nkids8 := len(node.Kids)
			// predicate
			if !_node(parser, _predicateNode, node, &pos) {
				goto fail10
			}
			goto ok7
		fail10:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// argument
			if !_node(parser, _argumentNode, node, &pos) {
				goto fail11
			}
			goto ok7
		fail11:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// adverb
			if !_node(parser, _adverbNode, node, &pos) {
				goto fail12
			}
			goto ok7
		fail12:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// prepositional_phrase
			if !_node(parser, _prepositional_phraseNode, node, &pos) {
				goto fail13
			}
			goto ok7
		fail13:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			goto fail
		ok7:
		}
		sub := _sub(parser, pos06, pos, node.Kids[nkids5:])
		node.Kids = append(node.Kids[:nkids5], sub)
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MI_arg_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MI_arg_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MI_arg_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MI_arg_1}
	// MI_arg_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	// MI_arg_tone
	if !_fail(parser, _MI_arg_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// (predicate/argument/adverb/prepositional_phrase)
	// predicate/argument/adverb/prepositional_phrase
	{
		pos7 := pos
		// predicate
		if !_fail(parser, _predicateFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok5
	fail8:
		pos = pos7
		// argument
		if !_fail(parser, _argumentFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok5
	fail9:
		pos = pos7
		// adverb
		if !_fail(parser, _adverbFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok5
	fail10:
		pos = pos7
		// prepositional_phrase
		if !_fail(parser, _prepositional_phraseFail, errPos, failure, &pos) {
			goto fail11
		}
		goto ok5
	fail11:
		pos = pos7
		goto fail
	ok5:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MI_arg_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MI_arg_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_arg_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MI_arg_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	{
		var node0 string
		// MI_arg_tone
		if p, n := _MI_arg_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// (predicate/argument/adverb/prepositional_phrase)
		// predicate/argument/adverb/prepositional_phrase
		{
			pos7 := pos
			// predicate
			if p, n := _predicateAction(parser, pos); n == nil {
				goto fail8
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail8:
			pos = pos7
			// argument
			if p, n := _argumentAction(parser, pos); n == nil {
				goto fail9
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail9:
			pos = pos7
			// adverb
			if p, n := _adverbAction(parser, pos); n == nil {
				goto fail10
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail10:
			pos = pos7
			// prepositional_phrase
			if p, n := _prepositional_phraseAction(parser, pos); n == nil {
				goto fail11
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail11:
			pos = pos7
			goto fail
		ok5:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MI_arg_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MI_arg_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &MI arg_syllable
	// &MI
	{
		pos2 := pos
		perr4 := perr
		// MI
		if !_accept(parser, _MIAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// arg_syllable
	if !_accept(parser, _arg_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _MI_arg_tone, start, pos, perr)
fail:
	return _memoize(parser, _MI_arg_tone, start, -1, perr)
}

func _MI_arg_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MI_arg_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_arg_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MI_arg_tone"}
	// &MI arg_syllable
	// &MI
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// MI
		if !_node(parser, _MINode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// arg_syllable
	if !_node(parser, _arg_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MI_arg_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MI_arg_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MI_arg_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MI_arg_tone}
	// &MI arg_syllable
	// &MI
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// MI
		if !_fail(parser, _MIFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&MI",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// arg_syllable
	if !_fail(parser, _arg_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MI_arg_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MI_arg_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_arg_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &MI arg_syllable
	{
		var node0 string
		// &MI
		{
			pos2 := pos
			// MI
			if p, n := _MIAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// arg_syllable
		if p, n := _arg_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _PO_argAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _PO_arg, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// PO_arg_1 spaces? GA?
	// PO_arg_1
	if !_accept(parser, _PO_arg_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_accept(parser, _GAAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	return _memoize(parser, _PO_arg, start, pos, perr)
fail:
	return _memoize(parser, _PO_arg, start, -1, perr)
}

func _PO_argNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_PO_arg]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_arg}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "PO_arg"}
	// PO_arg_1 spaces? GA?
	// PO_arg_1
	if !_node(parser, _PO_arg_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// GA?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// GA
		if !_node(parser, _GANode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _PO_argFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _PO_arg, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "PO_arg",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _PO_arg}
	// PO_arg_1 spaces? GA?
	// PO_arg_1
	if !_fail(parser, _PO_arg_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_fail(parser, _GAFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _PO_argAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_PO_arg]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_arg}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// PO_arg_1 spaces? GA?
	{
		var node0 string
		// PO_arg_1
		if p, n := _PO_arg_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// GA?
		{
			pos6 := pos
			// GA
			if p, n := _GAAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _PO_arg_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _PO_arg_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// PO_arg_tone spaces? argument
	// PO_arg_tone
	if !_accept(parser, _PO_arg_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// argument
	if !_accept(parser, _argumentAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _PO_arg_1, start, pos, perr)
fail:
	return _memoize(parser, _PO_arg_1, start, -1, perr)
}

func _PO_arg_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_PO_arg_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_arg_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "PO_arg_1"}
	// PO_arg_tone spaces? argument
	// PO_arg_tone
	if !_node(parser, _PO_arg_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// argument
	if !_node(parser, _argumentNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _PO_arg_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _PO_arg_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "PO_arg_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _PO_arg_1}
	// PO_arg_tone spaces? argument
	// PO_arg_tone
	if !_fail(parser, _PO_arg_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// argument
	if !_fail(parser, _argumentFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _PO_arg_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_PO_arg_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_arg_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// PO_arg_tone spaces? argument
	{
		var node0 string
		// PO_arg_tone
		if p, n := _PO_arg_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// argument
		if p, n := _argumentAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _PO_arg_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _PO_arg_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &PO arg_syllable
	// &PO
	{
		pos2 := pos
		perr4 := perr
		// PO
		if !_accept(parser, _POAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// arg_syllable
	if !_accept(parser, _arg_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _PO_arg_tone, start, pos, perr)
fail:
	return _memoize(parser, _PO_arg_tone, start, -1, perr)
}

func _PO_arg_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_PO_arg_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_arg_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "PO_arg_tone"}
	// &PO arg_syllable
	// &PO
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// PO
		if !_node(parser, _PONode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// arg_syllable
	if !_node(parser, _arg_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _PO_arg_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _PO_arg_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "PO_arg_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _PO_arg_tone}
	// &PO arg_syllable
	// &PO
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// PO
		if !_fail(parser, _POFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&PO",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// arg_syllable
	if !_fail(parser, _arg_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _PO_arg_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_PO_arg_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_arg_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &PO arg_syllable
	{
		var node0 string
		// &PO
		{
			pos2 := pos
			// PO
			if p, n := _POAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// arg_syllable
		if p, n := _arg_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _quotation_argumentAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _quotation_argument, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MO_argument spaces? TEO
	// MO_argument
	if !_accept(parser, _MO_argumentAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// TEO
	if !_accept(parser, _TEOAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _quotation_argument, start, pos, perr)
fail:
	return _memoize(parser, _quotation_argument, start, -1, perr)
}

func _quotation_argumentNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_quotation_argument]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _quotation_argument}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "quotation_argument"}
	// MO_argument spaces? TEO
	// MO_argument
	if !_node(parser, _MO_argumentNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// TEO
	if !_node(parser, _TEONode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _quotation_argumentFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _quotation_argument, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "quotation_argument",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _quotation_argument}
	// MO_argument spaces? TEO
	// MO_argument
	if !_fail(parser, _MO_argumentFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// TEO
	if !_fail(parser, _TEOFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _quotation_argumentAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_quotation_argument]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _quotation_argument}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MO_argument spaces? TEO
	{
		var node0 string
		// MO_argument
		if p, n := _MO_argumentAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// TEO
		if p, n := _TEOAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MO_argumentAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MO_argument, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MO_argument_tone spaces? discourse
	// MO_argument_tone
	if !_accept(parser, _MO_argument_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// discourse
	if !_accept(parser, _discourseAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _MO_argument, start, pos, perr)
fail:
	return _memoize(parser, _MO_argument, start, -1, perr)
}

func _MO_argumentNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MO_argument]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_argument}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MO_argument"}
	// MO_argument_tone spaces? discourse
	// MO_argument_tone
	if !_node(parser, _MO_argument_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// discourse
	if !_node(parser, _discourseNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MO_argumentFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MO_argument, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MO_argument",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MO_argument}
	// MO_argument_tone spaces? discourse
	// MO_argument_tone
	if !_fail(parser, _MO_argument_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// discourse
	if !_fail(parser, _discourseFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MO_argumentAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MO_argument]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_argument}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MO_argument_tone spaces? discourse
	{
		var node0 string
		// MO_argument_tone
		if p, n := _MO_argument_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// discourse
		if p, n := _discourseAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MO_argument_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MO_argument_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &MO arg_syllable
	// &MO
	{
		pos2 := pos
		perr4 := perr
		// MO
		if !_accept(parser, _MOAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// arg_syllable
	if !_accept(parser, _arg_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _MO_argument_tone, start, pos, perr)
fail:
	return _memoize(parser, _MO_argument_tone, start, -1, perr)
}

func _MO_argument_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MO_argument_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_argument_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MO_argument_tone"}
	// &MO arg_syllable
	// &MO
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// MO
		if !_node(parser, _MONode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// arg_syllable
	if !_node(parser, _arg_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MO_argument_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MO_argument_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MO_argument_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MO_argument_tone}
	// &MO arg_syllable
	// &MO
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// MO
		if !_fail(parser, _MOFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&MO",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// arg_syllable
	if !_fail(parser, _arg_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MO_argument_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MO_argument_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_argument_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &MO arg_syllable
	{
		var node0 string
		// &MO
		{
			pos2 := pos
			// MO
			if p, n := _MOAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// arg_syllable
		if p, n := _arg_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _relative_clauseAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _relative_clause, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// coP_rel/LU_relative/relative_clause_1
	{
		pos2 := pos
		// coP_rel
		if !_accept(parser, _coP_relAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// LU_relative
		if !_accept(parser, _LU_relativeAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// relative_clause_1
		if !_accept(parser, _relative_clause_1Accepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _relative_clause, start, pos, perr)
fail:
	return _memoize(parser, _relative_clause, start, -1, perr)
}

func _relative_clauseNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_relative_clause]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_clause}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "relative_clause"}
	// coP_rel/LU_relative/relative_clause_1
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// coP_rel
		if !_node(parser, _coP_relNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// LU_relative
		if !_node(parser, _LU_relativeNode, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// relative_clause_1
		if !_node(parser, _relative_clause_1Node, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _relative_clauseFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _relative_clause, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "relative_clause",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _relative_clause}
	// coP_rel/LU_relative/relative_clause_1
	{
		pos2 := pos
		// coP_rel
		if !_fail(parser, _coP_relFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// LU_relative
		if !_fail(parser, _LU_relativeFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// relative_clause_1
		if !_fail(parser, _relative_clause_1Fail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _relative_clauseAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_relative_clause]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_clause}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// coP_rel/LU_relative/relative_clause_1
	{
		pos2 := pos
		// coP_rel
		if p, n := _coP_relAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// LU_relative
		if p, n := _LU_relativeAction(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		// relative_clause_1
		if p, n := _relative_clause_1Action(parser, pos); n == nil {
			goto fail5
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail5:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _relative_clause_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _relative_clause_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_coP_rel/relative_clause_2
	{
		pos2 := pos
		// forethought_coP_rel
		if !_accept(parser, _forethought_coP_relAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// relative_clause_2
		if !_accept(parser, _relative_clause_2Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _relative_clause_1, start, pos, perr)
fail:
	return _memoize(parser, _relative_clause_1, start, -1, perr)
}

func _relative_clause_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_relative_clause_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_clause_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "relative_clause_1"}
	// forethought_coP_rel/relative_clause_2
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// forethought_coP_rel
		if !_node(parser, _forethought_coP_relNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// relative_clause_2
		if !_node(parser, _relative_clause_2Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _relative_clause_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _relative_clause_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "relative_clause_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _relative_clause_1}
	// forethought_coP_rel/relative_clause_2
	{
		pos2 := pos
		// forethought_coP_rel
		if !_fail(parser, _forethought_coP_relFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// relative_clause_2
		if !_fail(parser, _relative_clause_2Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _relative_clause_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_relative_clause_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_clause_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_coP_rel/relative_clause_2
	{
		pos2 := pos
		// forethought_coP_rel
		if p, n := _forethought_coP_relAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// relative_clause_2
		if p, n := _relative_clause_2Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _relative_clause_2Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _relative_clause_2, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// coP_rel_statement/relative_clause_3
	{
		pos2 := pos
		// coP_rel_statement
		if !_accept(parser, _coP_rel_statementAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// relative_clause_3
		if !_accept(parser, _relative_clause_3Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _relative_clause_2, start, pos, perr)
fail:
	return _memoize(parser, _relative_clause_2, start, -1, perr)
}

func _relative_clause_2Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_relative_clause_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_clause_2}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "relative_clause_2"}
	// coP_rel_statement/relative_clause_3
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// coP_rel_statement
		if !_node(parser, _coP_rel_statementNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// relative_clause_3
		if !_node(parser, _relative_clause_3Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _relative_clause_2Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _relative_clause_2, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "relative_clause_2",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _relative_clause_2}
	// coP_rel_statement/relative_clause_3
	{
		pos2 := pos
		// coP_rel_statement
		if !_fail(parser, _coP_rel_statementFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// relative_clause_3
		if !_fail(parser, _relative_clause_3Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _relative_clause_2Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_relative_clause_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_clause_2}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// coP_rel_statement/relative_clause_3
	{
		pos2 := pos
		// coP_rel_statement
		if p, n := _coP_rel_statementAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// relative_clause_3
		if p, n := _relative_clause_3Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _relative_clause_3Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _relative_clause_3, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// relative_predication spaces? end_statement?
	// relative_predication
	if !_accept(parser, _relative_predicationAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// end_statement?
	{
		pos6 := pos
		// end_statement
		if !_accept(parser, _end_statementAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	return _memoize(parser, _relative_clause_3, start, pos, perr)
fail:
	return _memoize(parser, _relative_clause_3, start, -1, perr)
}

func _relative_clause_3Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_relative_clause_3]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_clause_3}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "relative_clause_3"}
	// relative_predication spaces? end_statement?
	// relative_predication
	if !_node(parser, _relative_predicationNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// end_statement?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// end_statement
		if !_node(parser, _end_statementNode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _relative_clause_3Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _relative_clause_3, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "relative_clause_3",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _relative_clause_3}
	// relative_predication spaces? end_statement?
	// relative_predication
	if !_fail(parser, _relative_predicationFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// end_statement?
	{
		pos6 := pos
		// end_statement
		if !_fail(parser, _end_statementFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _relative_clause_3Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_relative_clause_3]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_clause_3}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// relative_predication spaces? end_statement?
	{
		var node0 string
		// relative_predication
		if p, n := _relative_predicationAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// end_statement?
		{
			pos6 := pos
			// end_statement
			if p, n := _end_statementAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _relative_predicationAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _relative_predication, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// relative_predicate spaces? terms?
	// relative_predicate
	if !_accept(parser, _relative_predicateAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms?
	{
		pos6 := pos
		// terms
		if !_accept(parser, _termsAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	return _memoize(parser, _relative_predication, start, pos, perr)
fail:
	return _memoize(parser, _relative_predication, start, -1, perr)
}

func _relative_predicationNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_relative_predication]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_predication}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "relative_predication"}
	// relative_predicate spaces? terms?
	// relative_predicate
	if !_node(parser, _relative_predicateNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// terms?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// terms
		if !_node(parser, _termsNode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _relative_predicationFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _relative_predication, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "relative_predication",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _relative_predication}
	// relative_predicate spaces? terms?
	// relative_predicate
	if !_fail(parser, _relative_predicateFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms?
	{
		pos6 := pos
		// terms
		if !_fail(parser, _termsFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _relative_predicationAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_relative_predication]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_predication}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// relative_predicate spaces? terms?
	{
		var node0 string
		// relative_predicate
		if p, n := _relative_predicateAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// terms?
		{
			pos6 := pos
			// terms
			if p, n := _termsAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _coP_rel_statementAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _coP_rel_statement, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// relative_clause_3 spaces? co_bar_statement
	// relative_clause_3
	if !_accept(parser, _relative_clause_3Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_statement
	if !_accept(parser, _co_bar_statementAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _coP_rel_statement, start, pos, perr)
fail:
	return _memoize(parser, _coP_rel_statement, start, -1, perr)
}

func _coP_rel_statementNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_coP_rel_statement]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_rel_statement}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "coP_rel_statement"}
	// relative_clause_3 spaces? co_bar_statement
	// relative_clause_3
	if !_node(parser, _relative_clause_3Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// co_bar_statement
	if !_node(parser, _co_bar_statementNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _coP_rel_statementFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _coP_rel_statement, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "coP_rel_statement",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _coP_rel_statement}
	// relative_clause_3 spaces? co_bar_statement
	// relative_clause_3
	if !_fail(parser, _relative_clause_3Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_statement
	if !_fail(parser, _co_bar_statementFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _coP_rel_statementAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_coP_rel_statement]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_rel_statement}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// relative_clause_3 spaces? co_bar_statement
	{
		var node0 string
		// relative_clause_3
		if p, n := _relative_clause_3Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// co_bar_statement
		if p, n := _co_bar_statementAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _coP_relAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _coP_rel, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// relative_clause_1 spaces? co_bar_rel
	// relative_clause_1
	if !_accept(parser, _relative_clause_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_rel
	if !_accept(parser, _co_bar_relAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _coP_rel, start, pos, perr)
fail:
	return _memoize(parser, _coP_rel, start, -1, perr)
}

func _coP_relNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_coP_rel]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_rel}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "coP_rel"}
	// relative_clause_1 spaces? co_bar_rel
	// relative_clause_1
	if !_node(parser, _relative_clause_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// co_bar_rel
	if !_node(parser, _co_bar_relNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _coP_relFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _coP_rel, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "coP_rel",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _coP_rel}
	// relative_clause_1 spaces? co_bar_rel
	// relative_clause_1
	if !_fail(parser, _relative_clause_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_rel
	if !_fail(parser, _co_bar_relFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _coP_relAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_coP_rel]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_rel}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// relative_clause_1 spaces? co_bar_rel
	{
		var node0 string
		// relative_clause_1
		if p, n := _relative_clause_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// co_bar_rel
		if p, n := _co_bar_relAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _co_bar_relAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _co_bar_rel, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// connective spaces? relative_clause_1
	// connective
	if !_accept(parser, _connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// relative_clause_1
	if !_accept(parser, _relative_clause_1Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _co_bar_rel, start, pos, perr)
fail:
	return _memoize(parser, _co_bar_rel, start, -1, perr)
}

func _co_bar_relNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_co_bar_rel]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _co_bar_rel}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "co_bar_rel"}
	// connective spaces? relative_clause_1
	// connective
	if !_node(parser, _connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// relative_clause_1
	if !_node(parser, _relative_clause_1Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _co_bar_relFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _co_bar_rel, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "co_bar_rel",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _co_bar_rel}
	// connective spaces? relative_clause_1
	// connective
	if !_fail(parser, _connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// relative_clause_1
	if !_fail(parser, _relative_clause_1Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _co_bar_relAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_co_bar_rel]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _co_bar_rel}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// connective spaces? relative_clause_1
	{
		var node0 string
		// connective
		if p, n := _connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// relative_clause_1
		if p, n := _relative_clause_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_relAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_rel, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_connective spaces? forethought_coP_rel_1
	// forethought_connective
	if !_accept(parser, _forethought_connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_rel_1
	if !_accept(parser, _forethought_coP_rel_1Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_rel, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_rel, start, -1, perr)
}

func _forethought_coP_relNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_rel]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_rel}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_rel"}
	// forethought_connective spaces? forethought_coP_rel_1
	// forethought_connective
	if !_node(parser, _forethought_connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_coP_rel_1
	if !_node(parser, _forethought_coP_rel_1Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_relFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_rel, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_rel",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_rel}
	// forethought_connective spaces? forethought_coP_rel_1
	// forethought_connective
	if !_fail(parser, _forethought_connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_rel_1
	if !_fail(parser, _forethought_coP_rel_1Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_relAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_rel]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_rel}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_connective spaces? forethought_coP_rel_1
	{
		var node0 string
		// forethought_connective
		if p, n := _forethought_connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_coP_rel_1
		if p, n := _forethought_coP_rel_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_rel_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_rel_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// relative_clause spaces? forethought_co_bar_rel
	// relative_clause
	if !_accept(parser, _relative_clauseAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_rel
	if !_accept(parser, _forethought_co_bar_relAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_rel_1, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_rel_1, start, -1, perr)
}

func _forethought_coP_rel_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_rel_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_rel_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_rel_1"}
	// relative_clause spaces? forethought_co_bar_rel
	// relative_clause
	if !_node(parser, _relative_clauseNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_co_bar_rel
	if !_node(parser, _forethought_co_bar_relNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_rel_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_rel_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_rel_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_rel_1}
	// relative_clause spaces? forethought_co_bar_rel
	// relative_clause
	if !_fail(parser, _relative_clauseFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_rel
	if !_fail(parser, _forethought_co_bar_relFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_rel_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_rel_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_rel_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// relative_clause spaces? forethought_co_bar_rel
	{
		var node0 string
		// relative_clause
		if p, n := _relative_clauseAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_co_bar_rel
		if p, n := _forethought_co_bar_relAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_co_bar_relAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_co_bar_rel, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// gik spaces? relative_clause
	// gik
	if !_accept(parser, _gikAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// relative_clause
	if !_accept(parser, _relative_clauseAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_co_bar_rel, start, pos, perr)
fail:
	return _memoize(parser, _forethought_co_bar_rel, start, -1, perr)
}

func _forethought_co_bar_relNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_co_bar_rel]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_rel}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_co_bar_rel"}
	// gik spaces? relative_clause
	// gik
	if !_node(parser, _gikNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// relative_clause
	if !_node(parser, _relative_clauseNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_co_bar_relFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_co_bar_rel, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_co_bar_rel",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_co_bar_rel}
	// gik spaces? relative_clause
	// gik
	if !_fail(parser, _gikFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// relative_clause
	if !_fail(parser, _relative_clauseFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_co_bar_relAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_co_bar_rel]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_rel}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// gik spaces? relative_clause
	{
		var node0 string
		// gik
		if p, n := _gikAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// relative_clause
		if p, n := _relative_clauseAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _relative_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _relative_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// serial_relative_predicate/relative_predicate_1
	{
		pos2 := pos
		// serial_relative_predicate
		if !_accept(parser, _serial_relative_predicateAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// relative_predicate_1
		if !_accept(parser, _relative_predicate_1Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _relative_predicate, start, pos, perr)
fail:
	return _memoize(parser, _relative_predicate, start, -1, perr)
}

func _relative_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_relative_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "relative_predicate"}
	// serial_relative_predicate/relative_predicate_1
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// serial_relative_predicate
		if !_node(parser, _serial_relative_predicateNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// relative_predicate_1
		if !_node(parser, _relative_predicate_1Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _relative_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _relative_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "relative_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _relative_predicate}
	// serial_relative_predicate/relative_predicate_1
	{
		pos2 := pos
		// serial_relative_predicate
		if !_fail(parser, _serial_relative_predicateFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// relative_predicate_1
		if !_fail(parser, _relative_predicate_1Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _relative_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_relative_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// serial_relative_predicate/relative_predicate_1
	{
		pos2 := pos
		// serial_relative_predicate
		if p, n := _serial_relative_predicateAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// relative_predicate_1
		if p, n := _relative_predicate_1Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _relative_predicate_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _relative_predicate_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// coP_pred_relative_predicate/forethought_coP_pred_relative_predicate/relative_predicate_2
	{
		pos2 := pos
		// coP_pred_relative_predicate
		if !_accept(parser, _coP_pred_relative_predicateAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// forethought_coP_pred_relative_predicate
		if !_accept(parser, _forethought_coP_pred_relative_predicateAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// relative_predicate_2
		if !_accept(parser, _relative_predicate_2Accepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _relative_predicate_1, start, pos, perr)
fail:
	return _memoize(parser, _relative_predicate_1, start, -1, perr)
}

func _relative_predicate_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_relative_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_predicate_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "relative_predicate_1"}
	// coP_pred_relative_predicate/forethought_coP_pred_relative_predicate/relative_predicate_2
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// coP_pred_relative_predicate
		if !_node(parser, _coP_pred_relative_predicateNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// forethought_coP_pred_relative_predicate
		if !_node(parser, _forethought_coP_pred_relative_predicateNode, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// relative_predicate_2
		if !_node(parser, _relative_predicate_2Node, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _relative_predicate_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _relative_predicate_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "relative_predicate_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _relative_predicate_1}
	// coP_pred_relative_predicate/forethought_coP_pred_relative_predicate/relative_predicate_2
	{
		pos2 := pos
		// coP_pred_relative_predicate
		if !_fail(parser, _coP_pred_relative_predicateFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// forethought_coP_pred_relative_predicate
		if !_fail(parser, _forethought_coP_pred_relative_predicateFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// relative_predicate_2
		if !_fail(parser, _relative_predicate_2Fail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _relative_predicate_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_relative_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_predicate_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// coP_pred_relative_predicate/forethought_coP_pred_relative_predicate/relative_predicate_2
	{
		pos2 := pos
		// coP_pred_relative_predicate
		if p, n := _coP_pred_relative_predicateAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// forethought_coP_pred_relative_predicate
		if p, n := _forethought_coP_pred_relative_predicateAction(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		// relative_predicate_2
		if p, n := _relative_predicate_2Action(parser, pos); n == nil {
			goto fail5
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail5:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _relative_predicate_2Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _relative_predicate_2, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MI_relative_predicate/PO_relative_predicate/quotation_relative_predicate/relative_predicate_3
	{
		pos2 := pos
		// MI_relative_predicate
		if !_accept(parser, _MI_relative_predicateAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// PO_relative_predicate
		if !_accept(parser, _PO_relative_predicateAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// quotation_relative_predicate
		if !_accept(parser, _quotation_relative_predicateAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// relative_predicate_3
		if !_accept(parser, _relative_predicate_3Accepts, &pos, &perr) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _relative_predicate_2, start, pos, perr)
fail:
	return _memoize(parser, _relative_predicate_2, start, -1, perr)
}

func _relative_predicate_2Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_relative_predicate_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_predicate_2}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "relative_predicate_2"}
	// MI_relative_predicate/PO_relative_predicate/quotation_relative_predicate/relative_predicate_3
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// MI_relative_predicate
		if !_node(parser, _MI_relative_predicateNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// PO_relative_predicate
		if !_node(parser, _PO_relative_predicateNode, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// quotation_relative_predicate
		if !_node(parser, _quotation_relative_predicateNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// relative_predicate_3
		if !_node(parser, _relative_predicate_3Node, node, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _relative_predicate_2Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _relative_predicate_2, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "relative_predicate_2",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _relative_predicate_2}
	// MI_relative_predicate/PO_relative_predicate/quotation_relative_predicate/relative_predicate_3
	{
		pos2 := pos
		// MI_relative_predicate
		if !_fail(parser, _MI_relative_predicateFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// PO_relative_predicate
		if !_fail(parser, _PO_relative_predicateFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// quotation_relative_predicate
		if !_fail(parser, _quotation_relative_predicateFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// relative_predicate_3
		if !_fail(parser, _relative_predicate_3Fail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _relative_predicate_2Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_relative_predicate_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_predicate_2}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MI_relative_predicate/PO_relative_predicate/quotation_relative_predicate/relative_predicate_3
	{
		pos2 := pos
		// MI_relative_predicate
		if p, n := _MI_relative_predicateAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// PO_relative_predicate
		if p, n := _PO_relative_predicateAction(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		// quotation_relative_predicate
		if p, n := _quotation_relative_predicateAction(parser, pos); n == nil {
			goto fail5
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail5:
		pos = pos2
		// relative_predicate_3
		if p, n := _relative_predicate_3Action(parser, pos); n == nil {
			goto fail6
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail6:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _relative_predicate_3Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _relative_predicate_3, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// relative_syllable compound_syllable+/!function_word relative_syllable
	{
		pos2 := pos
		// relative_syllable compound_syllable+
		// relative_syllable
		if !_accept(parser, _relative_syllableAccepts, &pos, &perr) {
			goto fail3
		}
		// compound_syllable+
		// compound_syllable
		if !_accept(parser, _compound_syllableAccepts, &pos, &perr) {
			goto fail3
		}
		for {
			pos6 := pos
			// compound_syllable
			if !_accept(parser, _compound_syllableAccepts, &pos, &perr) {
				goto fail8
			}
			continue
		fail8:
			pos = pos6
			break
		}
		goto ok0
	fail3:
		pos = pos2
		// !function_word relative_syllable
		// !function_word
		{
			pos12 := pos
			perr14 := perr
			// function_word
			if !_accept(parser, _function_wordAccepts, &pos, &perr) {
				goto ok11
			}
			pos = pos12
			perr = _max(perr14, pos)
			goto fail9
		ok11:
			pos = pos12
			perr = perr14
		}
		// relative_syllable
		if !_accept(parser, _relative_syllableAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _relative_predicate_3, start, pos, perr)
fail:
	return _memoize(parser, _relative_predicate_3, start, -1, perr)
}

func _relative_predicate_3Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_relative_predicate_3]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_predicate_3}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "relative_predicate_3"}
	// relative_syllable compound_syllable+/!function_word relative_syllable
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// relative_syllable compound_syllable+
		// relative_syllable
		if !_node(parser, _relative_syllableNode, node, &pos) {
			goto fail3
		}
		// compound_syllable+
		// compound_syllable
		if !_node(parser, _compound_syllableNode, node, &pos) {
			goto fail3
		}
		for {
			nkids5 := len(node.Kids)
			pos6 := pos
			// compound_syllable
			if !_node(parser, _compound_syllableNode, node, &pos) {
				goto fail8
			}
			continue
		fail8:
			node.Kids = node.Kids[:nkids5]
			pos = pos6
			break
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// !function_word relative_syllable
		// !function_word
		{
			pos12 := pos
			nkids13 := len(node.Kids)
			// function_word
			if !_node(parser, _function_wordNode, node, &pos) {
				goto ok11
			}
			pos = pos12
			node.Kids = node.Kids[:nkids13]
			goto fail9
		ok11:
			pos = pos12
			node.Kids = node.Kids[:nkids13]
		}
		// relative_syllable
		if !_node(parser, _relative_syllableNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _relative_predicate_3Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _relative_predicate_3, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "relative_predicate_3",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _relative_predicate_3}
	// relative_syllable compound_syllable+/!function_word relative_syllable
	{
		pos2 := pos
		// relative_syllable compound_syllable+
		// relative_syllable
		if !_fail(parser, _relative_syllableFail, errPos, failure, &pos) {
			goto fail3
		}
		// compound_syllable+
		// compound_syllable
		if !_fail(parser, _compound_syllableFail, errPos, failure, &pos) {
			goto fail3
		}
		for {
			pos6 := pos
			// compound_syllable
			if !_fail(parser, _compound_syllableFail, errPos, failure, &pos) {
				goto fail8
			}
			continue
		fail8:
			pos = pos6
			break
		}
		goto ok0
	fail3:
		pos = pos2
		// !function_word relative_syllable
		// !function_word
		{
			pos12 := pos
			nkids13 := len(failure.Kids)
			// function_word
			if !_fail(parser, _function_wordFail, errPos, failure, &pos) {
				goto ok11
			}
			pos = pos12
			failure.Kids = failure.Kids[:nkids13]
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "!function_word",
				})
			}
			goto fail9
		ok11:
			pos = pos12
			failure.Kids = failure.Kids[:nkids13]
		}
		// relative_syllable
		if !_fail(parser, _relative_syllableFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _relative_predicate_3Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_relative_predicate_3]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_predicate_3}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// relative_syllable compound_syllable+/!function_word relative_syllable
	{
		pos2 := pos
		// relative_syllable compound_syllable+
		{
			var node4 string
			// relative_syllable
			if p, n := _relative_syllableAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
			// compound_syllable+
			{
				var node7 string
				// compound_syllable
				if p, n := _compound_syllableAction(parser, pos); n == nil {
					goto fail3
				} else {
					node7 = *n
					pos = p
				}
				node4 += node7
			}
			for {
				pos6 := pos
				var node7 string
				// compound_syllable
				if p, n := _compound_syllableAction(parser, pos); n == nil {
					goto fail8
				} else {
					node7 = *n
					pos = p
				}
				node4 += node7
				continue
			fail8:
				pos = pos6
				break
			}
			node += node4
		}
		goto ok0
	fail3:
		pos = pos2
		// !function_word relative_syllable
		{
			var node10 string
			// !function_word
			{
				pos12 := pos
				// function_word
				if p, n := _function_wordAction(parser, pos); n == nil {
					goto ok11
				} else {
					pos = p
				}
				pos = pos12
				goto fail9
			ok11:
				pos = pos12
				node = ""
			}
			node += node10
			// relative_syllable
			if p, n := _relative_syllableAction(parser, pos); n == nil {
				goto fail9
			} else {
				node10 = *n
				pos = p
			}
			node += node10
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _serial_relative_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _serial_relative_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// relative_predicate_1 spaces? serial_predicate
	// relative_predicate_1
	if !_accept(parser, _relative_predicate_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// serial_predicate
	if !_accept(parser, _serial_predicateAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _serial_relative_predicate, start, pos, perr)
fail:
	return _memoize(parser, _serial_relative_predicate, start, -1, perr)
}

func _serial_relative_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_serial_relative_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _serial_relative_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "serial_relative_predicate"}
	// relative_predicate_1 spaces? serial_predicate
	// relative_predicate_1
	if !_node(parser, _relative_predicate_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// serial_predicate
	if !_node(parser, _serial_predicateNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _serial_relative_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _serial_relative_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "serial_relative_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _serial_relative_predicate}
	// relative_predicate_1 spaces? serial_predicate
	// relative_predicate_1
	if !_fail(parser, _relative_predicate_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// serial_predicate
	if !_fail(parser, _serial_predicateFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _serial_relative_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_serial_relative_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _serial_relative_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// relative_predicate_1 spaces? serial_predicate
	{
		var node0 string
		// relative_predicate_1
		if p, n := _relative_predicate_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// serial_predicate
		if p, n := _serial_predicateAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _coP_pred_relative_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _coP_pred_relative_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// relative_predicate_2 spaces? co_bar_pred
	// relative_predicate_2
	if !_accept(parser, _relative_predicate_2Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_pred
	if !_accept(parser, _co_bar_predAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _coP_pred_relative_predicate, start, pos, perr)
fail:
	return _memoize(parser, _coP_pred_relative_predicate, start, -1, perr)
}

func _coP_pred_relative_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_coP_pred_relative_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_pred_relative_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "coP_pred_relative_predicate"}
	// relative_predicate_2 spaces? co_bar_pred
	// relative_predicate_2
	if !_node(parser, _relative_predicate_2Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// co_bar_pred
	if !_node(parser, _co_bar_predNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _coP_pred_relative_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _coP_pred_relative_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "coP_pred_relative_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _coP_pred_relative_predicate}
	// relative_predicate_2 spaces? co_bar_pred
	// relative_predicate_2
	if !_fail(parser, _relative_predicate_2Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_pred
	if !_fail(parser, _co_bar_predFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _coP_pred_relative_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_coP_pred_relative_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_pred_relative_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// relative_predicate_2 spaces? co_bar_pred
	{
		var node0 string
		// relative_predicate_2
		if p, n := _relative_predicate_2Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// co_bar_pred
		if p, n := _co_bar_predAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_pred_relative_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_pred_relative_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_connective spaces? forethought_coP_pred_relative_predicate_1
	// forethought_connective
	if !_accept(parser, _forethought_connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_pred_relative_predicate_1
	if !_accept(parser, _forethought_coP_pred_relative_predicate_1Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_pred_relative_predicate, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_pred_relative_predicate, start, -1, perr)
}

func _forethought_coP_pred_relative_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_pred_relative_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_relative_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_pred_relative_predicate"}
	// forethought_connective spaces? forethought_coP_pred_relative_predicate_1
	// forethought_connective
	if !_node(parser, _forethought_connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_coP_pred_relative_predicate_1
	if !_node(parser, _forethought_coP_pred_relative_predicate_1Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_pred_relative_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_pred_relative_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_pred_relative_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_pred_relative_predicate}
	// forethought_connective spaces? forethought_coP_pred_relative_predicate_1
	// forethought_connective
	if !_fail(parser, _forethought_connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_pred_relative_predicate_1
	if !_fail(parser, _forethought_coP_pred_relative_predicate_1Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_pred_relative_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_pred_relative_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_relative_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_connective spaces? forethought_coP_pred_relative_predicate_1
	{
		var node0 string
		// forethought_connective
		if p, n := _forethought_connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_coP_pred_relative_predicate_1
		if p, n := _forethought_coP_pred_relative_predicate_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_pred_relative_predicate_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_pred_relative_predicate_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// relative_predicate spaces? forethought_co_bar_pred
	// relative_predicate
	if !_accept(parser, _relative_predicateAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_pred
	if !_accept(parser, _forethought_co_bar_predAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_pred_relative_predicate_1, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_pred_relative_predicate_1, start, -1, perr)
}

func _forethought_coP_pred_relative_predicate_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_pred_relative_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_relative_predicate_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_pred_relative_predicate_1"}
	// relative_predicate spaces? forethought_co_bar_pred
	// relative_predicate
	if !_node(parser, _relative_predicateNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_co_bar_pred
	if !_node(parser, _forethought_co_bar_predNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_pred_relative_predicate_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_pred_relative_predicate_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_pred_relative_predicate_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_pred_relative_predicate_1}
	// relative_predicate spaces? forethought_co_bar_pred
	// relative_predicate
	if !_fail(parser, _relative_predicateFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_pred
	if !_fail(parser, _forethought_co_bar_predFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_pred_relative_predicate_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_pred_relative_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_relative_predicate_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// relative_predicate spaces? forethought_co_bar_pred
	{
		var node0 string
		// relative_predicate
		if p, n := _relative_predicateAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_co_bar_pred
		if p, n := _forethought_co_bar_predAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _LU_relativeAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _LU_relative, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// LU_relative_tone spaces? statement
	// LU_relative_tone
	if !_accept(parser, _LU_relative_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// statement
	if !_accept(parser, _statementAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _LU_relative, start, pos, perr)
fail:
	return _memoize(parser, _LU_relative, start, -1, perr)
}

func _LU_relativeNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_LU_relative]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_relative}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "LU_relative"}
	// LU_relative_tone spaces? statement
	// LU_relative_tone
	if !_node(parser, _LU_relative_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// statement
	if !_node(parser, _statementNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _LU_relativeFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _LU_relative, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "LU_relative",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _LU_relative}
	// LU_relative_tone spaces? statement
	// LU_relative_tone
	if !_fail(parser, _LU_relative_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// statement
	if !_fail(parser, _statementFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _LU_relativeAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_LU_relative]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_relative}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// LU_relative_tone spaces? statement
	{
		var node0 string
		// LU_relative_tone
		if p, n := _LU_relative_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// statement
		if p, n := _statementAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _LU_relative_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _LU_relative_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &LU relative_syllable
	// &LU
	{
		pos2 := pos
		perr4 := perr
		// LU
		if !_accept(parser, _LUAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// relative_syllable
	if !_accept(parser, _relative_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _LU_relative_tone, start, pos, perr)
fail:
	return _memoize(parser, _LU_relative_tone, start, -1, perr)
}

func _LU_relative_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_LU_relative_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_relative_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "LU_relative_tone"}
	// &LU relative_syllable
	// &LU
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// LU
		if !_node(parser, _LUNode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// relative_syllable
	if !_node(parser, _relative_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _LU_relative_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _LU_relative_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "LU_relative_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _LU_relative_tone}
	// &LU relative_syllable
	// &LU
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// LU
		if !_fail(parser, _LUFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&LU",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// relative_syllable
	if !_fail(parser, _relative_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _LU_relative_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_LU_relative_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_relative_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &LU relative_syllable
	{
		var node0 string
		// &LU
		{
			pos2 := pos
			// LU
			if p, n := _LUAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// relative_syllable
		if p, n := _relative_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MI_relative_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MI_relative_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MI_relative_predicate_1 spaces? GA?
	// MI_relative_predicate_1
	if !_accept(parser, _MI_relative_predicate_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_accept(parser, _GAAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	return _memoize(parser, _MI_relative_predicate, start, pos, perr)
fail:
	return _memoize(parser, _MI_relative_predicate, start, -1, perr)
}

func _MI_relative_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MI_relative_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_relative_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MI_relative_predicate"}
	// MI_relative_predicate_1 spaces? GA?
	// MI_relative_predicate_1
	if !_node(parser, _MI_relative_predicate_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// GA?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// GA
		if !_node(parser, _GANode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MI_relative_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MI_relative_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MI_relative_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MI_relative_predicate}
	// MI_relative_predicate_1 spaces? GA?
	// MI_relative_predicate_1
	if !_fail(parser, _MI_relative_predicate_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_fail(parser, _GAFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MI_relative_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MI_relative_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_relative_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MI_relative_predicate_1 spaces? GA?
	{
		var node0 string
		// MI_relative_predicate_1
		if p, n := _MI_relative_predicate_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// GA?
		{
			pos6 := pos
			// GA
			if p, n := _GAAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MI_relative_predicate_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MI_relative_predicate_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MI_relative_predicate_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	// MI_relative_predicate_tone
	if !_accept(parser, _MI_relative_predicate_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// (predicate/argument/adverb/prepositional_phrase)
	// predicate/argument/adverb/prepositional_phrase
	{
		pos7 := pos
		// predicate
		if !_accept(parser, _predicateAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok5
	fail8:
		pos = pos7
		// argument
		if !_accept(parser, _argumentAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok5
	fail9:
		pos = pos7
		// adverb
		if !_accept(parser, _adverbAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok5
	fail10:
		pos = pos7
		// prepositional_phrase
		if !_accept(parser, _prepositional_phraseAccepts, &pos, &perr) {
			goto fail11
		}
		goto ok5
	fail11:
		pos = pos7
		goto fail
	ok5:
	}
	return _memoize(parser, _MI_relative_predicate_1, start, pos, perr)
fail:
	return _memoize(parser, _MI_relative_predicate_1, start, -1, perr)
}

func _MI_relative_predicate_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MI_relative_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_relative_predicate_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MI_relative_predicate_1"}
	// MI_relative_predicate_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	// MI_relative_predicate_tone
	if !_node(parser, _MI_relative_predicate_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// (predicate/argument/adverb/prepositional_phrase)
	{
		nkids5 := len(node.Kids)
		pos06 := pos
		// predicate/argument/adverb/prepositional_phrase
		{
			pos9 := pos
			nkids8 := len(node.Kids)
			// predicate
			if !_node(parser, _predicateNode, node, &pos) {
				goto fail10
			}
			goto ok7
		fail10:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// argument
			if !_node(parser, _argumentNode, node, &pos) {
				goto fail11
			}
			goto ok7
		fail11:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// adverb
			if !_node(parser, _adverbNode, node, &pos) {
				goto fail12
			}
			goto ok7
		fail12:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// prepositional_phrase
			if !_node(parser, _prepositional_phraseNode, node, &pos) {
				goto fail13
			}
			goto ok7
		fail13:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			goto fail
		ok7:
		}
		sub := _sub(parser, pos06, pos, node.Kids[nkids5:])
		node.Kids = append(node.Kids[:nkids5], sub)
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MI_relative_predicate_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MI_relative_predicate_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MI_relative_predicate_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MI_relative_predicate_1}
	// MI_relative_predicate_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	// MI_relative_predicate_tone
	if !_fail(parser, _MI_relative_predicate_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// (predicate/argument/adverb/prepositional_phrase)
	// predicate/argument/adverb/prepositional_phrase
	{
		pos7 := pos
		// predicate
		if !_fail(parser, _predicateFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok5
	fail8:
		pos = pos7
		// argument
		if !_fail(parser, _argumentFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok5
	fail9:
		pos = pos7
		// adverb
		if !_fail(parser, _adverbFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok5
	fail10:
		pos = pos7
		// prepositional_phrase
		if !_fail(parser, _prepositional_phraseFail, errPos, failure, &pos) {
			goto fail11
		}
		goto ok5
	fail11:
		pos = pos7
		goto fail
	ok5:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MI_relative_predicate_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MI_relative_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_relative_predicate_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MI_relative_predicate_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	{
		var node0 string
		// MI_relative_predicate_tone
		if p, n := _MI_relative_predicate_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// (predicate/argument/adverb/prepositional_phrase)
		// predicate/argument/adverb/prepositional_phrase
		{
			pos7 := pos
			// predicate
			if p, n := _predicateAction(parser, pos); n == nil {
				goto fail8
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail8:
			pos = pos7
			// argument
			if p, n := _argumentAction(parser, pos); n == nil {
				goto fail9
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail9:
			pos = pos7
			// adverb
			if p, n := _adverbAction(parser, pos); n == nil {
				goto fail10
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail10:
			pos = pos7
			// prepositional_phrase
			if p, n := _prepositional_phraseAction(parser, pos); n == nil {
				goto fail11
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail11:
			pos = pos7
			goto fail
		ok5:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MI_relative_predicate_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MI_relative_predicate_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &MI relative_syllable
	// &MI
	{
		pos2 := pos
		perr4 := perr
		// MI
		if !_accept(parser, _MIAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// relative_syllable
	if !_accept(parser, _relative_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _MI_relative_predicate_tone, start, pos, perr)
fail:
	return _memoize(parser, _MI_relative_predicate_tone, start, -1, perr)
}

func _MI_relative_predicate_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MI_relative_predicate_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_relative_predicate_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MI_relative_predicate_tone"}
	// &MI relative_syllable
	// &MI
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// MI
		if !_node(parser, _MINode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// relative_syllable
	if !_node(parser, _relative_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MI_relative_predicate_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MI_relative_predicate_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MI_relative_predicate_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MI_relative_predicate_tone}
	// &MI relative_syllable
	// &MI
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// MI
		if !_fail(parser, _MIFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&MI",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// relative_syllable
	if !_fail(parser, _relative_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MI_relative_predicate_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MI_relative_predicate_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_relative_predicate_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &MI relative_syllable
	{
		var node0 string
		// &MI
		{
			pos2 := pos
			// MI
			if p, n := _MIAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// relative_syllable
		if p, n := _relative_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _PO_relative_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _PO_relative_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// PO_relative_predicate_1 spaces? GA?
	// PO_relative_predicate_1
	if !_accept(parser, _PO_relative_predicate_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_accept(parser, _GAAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	return _memoize(parser, _PO_relative_predicate, start, pos, perr)
fail:
	return _memoize(parser, _PO_relative_predicate, start, -1, perr)
}

func _PO_relative_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_PO_relative_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_relative_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "PO_relative_predicate"}
	// PO_relative_predicate_1 spaces? GA?
	// PO_relative_predicate_1
	if !_node(parser, _PO_relative_predicate_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// GA?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// GA
		if !_node(parser, _GANode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _PO_relative_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _PO_relative_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "PO_relative_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _PO_relative_predicate}
	// PO_relative_predicate_1 spaces? GA?
	// PO_relative_predicate_1
	if !_fail(parser, _PO_relative_predicate_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_fail(parser, _GAFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _PO_relative_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_PO_relative_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_relative_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// PO_relative_predicate_1 spaces? GA?
	{
		var node0 string
		// PO_relative_predicate_1
		if p, n := _PO_relative_predicate_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// GA?
		{
			pos6 := pos
			// GA
			if p, n := _GAAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _PO_relative_predicate_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _PO_relative_predicate_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// PO_relative_predicate_tone spaces? argument
	// PO_relative_predicate_tone
	if !_accept(parser, _PO_relative_predicate_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// argument
	if !_accept(parser, _argumentAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _PO_relative_predicate_1, start, pos, perr)
fail:
	return _memoize(parser, _PO_relative_predicate_1, start, -1, perr)
}

func _PO_relative_predicate_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_PO_relative_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_relative_predicate_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "PO_relative_predicate_1"}
	// PO_relative_predicate_tone spaces? argument
	// PO_relative_predicate_tone
	if !_node(parser, _PO_relative_predicate_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// argument
	if !_node(parser, _argumentNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _PO_relative_predicate_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _PO_relative_predicate_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "PO_relative_predicate_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _PO_relative_predicate_1}
	// PO_relative_predicate_tone spaces? argument
	// PO_relative_predicate_tone
	if !_fail(parser, _PO_relative_predicate_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// argument
	if !_fail(parser, _argumentFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _PO_relative_predicate_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_PO_relative_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_relative_predicate_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// PO_relative_predicate_tone spaces? argument
	{
		var node0 string
		// PO_relative_predicate_tone
		if p, n := _PO_relative_predicate_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// argument
		if p, n := _argumentAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _PO_relative_predicate_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _PO_relative_predicate_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &PO relative_syllable
	// &PO
	{
		pos2 := pos
		perr4 := perr
		// PO
		if !_accept(parser, _POAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// relative_syllable
	if !_accept(parser, _relative_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _PO_relative_predicate_tone, start, pos, perr)
fail:
	return _memoize(parser, _PO_relative_predicate_tone, start, -1, perr)
}

func _PO_relative_predicate_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_PO_relative_predicate_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_relative_predicate_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "PO_relative_predicate_tone"}
	// &PO relative_syllable
	// &PO
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// PO
		if !_node(parser, _PONode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// relative_syllable
	if !_node(parser, _relative_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _PO_relative_predicate_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _PO_relative_predicate_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "PO_relative_predicate_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _PO_relative_predicate_tone}
	// &PO relative_syllable
	// &PO
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// PO
		if !_fail(parser, _POFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&PO",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// relative_syllable
	if !_fail(parser, _relative_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _PO_relative_predicate_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_PO_relative_predicate_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_relative_predicate_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &PO relative_syllable
	{
		var node0 string
		// &PO
		{
			pos2 := pos
			// PO
			if p, n := _POAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// relative_syllable
		if p, n := _relative_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _quotation_relative_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _quotation_relative_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MO_relative_predicate spaces? TEO
	// MO_relative_predicate
	if !_accept(parser, _MO_relative_predicateAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// TEO
	if !_accept(parser, _TEOAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _quotation_relative_predicate, start, pos, perr)
fail:
	return _memoize(parser, _quotation_relative_predicate, start, -1, perr)
}

func _quotation_relative_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_quotation_relative_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _quotation_relative_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "quotation_relative_predicate"}
	// MO_relative_predicate spaces? TEO
	// MO_relative_predicate
	if !_node(parser, _MO_relative_predicateNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// TEO
	if !_node(parser, _TEONode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _quotation_relative_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _quotation_relative_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "quotation_relative_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _quotation_relative_predicate}
	// MO_relative_predicate spaces? TEO
	// MO_relative_predicate
	if !_fail(parser, _MO_relative_predicateFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// TEO
	if !_fail(parser, _TEOFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _quotation_relative_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_quotation_relative_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _quotation_relative_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MO_relative_predicate spaces? TEO
	{
		var node0 string
		// MO_relative_predicate
		if p, n := _MO_relative_predicateAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// TEO
		if p, n := _TEOAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MO_relative_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MO_relative_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MO_relative_predicate_tone spaces? discourse
	// MO_relative_predicate_tone
	if !_accept(parser, _MO_relative_predicate_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// discourse
	if !_accept(parser, _discourseAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _MO_relative_predicate, start, pos, perr)
fail:
	return _memoize(parser, _MO_relative_predicate, start, -1, perr)
}

func _MO_relative_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MO_relative_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_relative_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MO_relative_predicate"}
	// MO_relative_predicate_tone spaces? discourse
	// MO_relative_predicate_tone
	if !_node(parser, _MO_relative_predicate_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// discourse
	if !_node(parser, _discourseNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MO_relative_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MO_relative_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MO_relative_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MO_relative_predicate}
	// MO_relative_predicate_tone spaces? discourse
	// MO_relative_predicate_tone
	if !_fail(parser, _MO_relative_predicate_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// discourse
	if !_fail(parser, _discourseFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MO_relative_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MO_relative_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_relative_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MO_relative_predicate_tone spaces? discourse
	{
		var node0 string
		// MO_relative_predicate_tone
		if p, n := _MO_relative_predicate_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// discourse
		if p, n := _discourseAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MO_relative_predicate_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MO_relative_predicate_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &MO relative_syllable
	// &MO
	{
		pos2 := pos
		perr4 := perr
		// MO
		if !_accept(parser, _MOAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// relative_syllable
	if !_accept(parser, _relative_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _MO_relative_predicate_tone, start, pos, perr)
fail:
	return _memoize(parser, _MO_relative_predicate_tone, start, -1, perr)
}

func _MO_relative_predicate_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MO_relative_predicate_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_relative_predicate_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MO_relative_predicate_tone"}
	// &MO relative_syllable
	// &MO
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// MO
		if !_node(parser, _MONode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// relative_syllable
	if !_node(parser, _relative_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MO_relative_predicate_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MO_relative_predicate_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MO_relative_predicate_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MO_relative_predicate_tone}
	// &MO relative_syllable
	// &MO
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// MO
		if !_fail(parser, _MOFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&MO",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// relative_syllable
	if !_fail(parser, _relative_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MO_relative_predicate_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MO_relative_predicate_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_relative_predicate_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &MO relative_syllable
	{
		var node0 string
		// &MO
		{
			pos2 := pos
			// MO
			if p, n := _MOAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// relative_syllable
		if p, n := _relative_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _termsetAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _termset, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// termset_V/termset_IV/termset_III/termset_II
	{
		pos2 := pos
		// termset_V
		if !_accept(parser, _termset_VAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// termset_IV
		if !_accept(parser, _termset_IVAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// termset_III
		if !_accept(parser, _termset_IIIAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// termset_II
		if !_accept(parser, _termset_IIAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _termset, start, pos, perr)
fail:
	return _memoize(parser, _termset, start, -1, perr)
}

func _termsetNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_termset]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _termset}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "termset"}
	// termset_V/termset_IV/termset_III/termset_II
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// termset_V
		if !_node(parser, _termset_VNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// termset_IV
		if !_node(parser, _termset_IVNode, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// termset_III
		if !_node(parser, _termset_IIINode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// termset_II
		if !_node(parser, _termset_IINode, node, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _termsetFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _termset, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "termset",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _termset}
	// termset_V/termset_IV/termset_III/termset_II
	{
		pos2 := pos
		// termset_V
		if !_fail(parser, _termset_VFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// termset_IV
		if !_fail(parser, _termset_IVFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// termset_III
		if !_fail(parser, _termset_IIIFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// termset_II
		if !_fail(parser, _termset_IIFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _termsetAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_termset]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _termset}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// termset_V/termset_IV/termset_III/termset_II
	{
		pos2 := pos
		// termset_V
		if p, n := _termset_VAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// termset_IV
		if p, n := _termset_IVAction(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		// termset_III
		if p, n := _termset_IIIAction(parser, pos); n == nil {
			goto fail5
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail5:
		pos = pos2
		// termset_II
		if p, n := _termset_IIAction(parser, pos); n == nil {
			goto fail6
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail6:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _termset_IIAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _termset_II, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_connective spaces? forethought_coP_term_II
	// forethought_connective
	if !_accept(parser, _forethought_connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_term_II
	if !_accept(parser, _forethought_coP_term_IIAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _termset_II, start, pos, perr)
fail:
	return _memoize(parser, _termset_II, start, -1, perr)
}

func _termset_IINode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_termset_II]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _termset_II}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "termset_II"}
	// forethought_connective spaces? forethought_coP_term_II
	// forethought_connective
	if !_node(parser, _forethought_connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_coP_term_II
	if !_node(parser, _forethought_coP_term_IINode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _termset_IIFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _termset_II, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "termset_II",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _termset_II}
	// forethought_connective spaces? forethought_coP_term_II
	// forethought_connective
	if !_fail(parser, _forethought_connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_term_II
	if !_fail(parser, _forethought_coP_term_IIFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _termset_IIAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_termset_II]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _termset_II}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_connective spaces? forethought_coP_term_II
	{
		var node0 string
		// forethought_connective
		if p, n := _forethought_connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_coP_term_II
		if p, n := _forethought_coP_term_IIAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_term_IIAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_term_II, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// terms_II spaces? forethought_co_bar_term_II
	// terms_II
	if !_accept(parser, _terms_IIAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_term_II
	if !_accept(parser, _forethought_co_bar_term_IIAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_term_II, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_term_II, start, -1, perr)
}

func _forethought_coP_term_IINode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_term_II]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_term_II}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_term_II"}
	// terms_II spaces? forethought_co_bar_term_II
	// terms_II
	if !_node(parser, _terms_IINode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_co_bar_term_II
	if !_node(parser, _forethought_co_bar_term_IINode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_term_IIFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_term_II, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_term_II",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_term_II}
	// terms_II spaces? forethought_co_bar_term_II
	// terms_II
	if !_fail(parser, _terms_IIFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_term_II
	if !_fail(parser, _forethought_co_bar_term_IIFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_term_IIAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_term_II]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_term_II}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// terms_II spaces? forethought_co_bar_term_II
	{
		var node0 string
		// terms_II
		if p, n := _terms_IIAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_co_bar_term_II
		if p, n := _forethought_co_bar_term_IIAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_co_bar_term_IIAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_co_bar_term_II, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// gik spaces? terms_II
	// gik
	if !_accept(parser, _gikAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms_II
	if !_accept(parser, _terms_IIAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_co_bar_term_II, start, pos, perr)
fail:
	return _memoize(parser, _forethought_co_bar_term_II, start, -1, perr)
}

func _forethought_co_bar_term_IINode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_co_bar_term_II]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_term_II}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_co_bar_term_II"}
	// gik spaces? terms_II
	// gik
	if !_node(parser, _gikNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// terms_II
	if !_node(parser, _terms_IINode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_co_bar_term_IIFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_co_bar_term_II, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_co_bar_term_II",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_co_bar_term_II}
	// gik spaces? terms_II
	// gik
	if !_fail(parser, _gikFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms_II
	if !_fail(parser, _terms_IIFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_co_bar_term_IIAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_co_bar_term_II]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_term_II}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// gik spaces? terms_II
	{
		var node0 string
		// gik
		if p, n := _gikAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// terms_II
		if p, n := _terms_IIAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _termset_IIIAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _termset_III, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_connective spaces? forethought_coP_term_III
	// forethought_connective
	if !_accept(parser, _forethought_connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_term_III
	if !_accept(parser, _forethought_coP_term_IIIAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _termset_III, start, pos, perr)
fail:
	return _memoize(parser, _termset_III, start, -1, perr)
}

func _termset_IIINode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_termset_III]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _termset_III}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "termset_III"}
	// forethought_connective spaces? forethought_coP_term_III
	// forethought_connective
	if !_node(parser, _forethought_connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_coP_term_III
	if !_node(parser, _forethought_coP_term_IIINode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _termset_IIIFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _termset_III, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "termset_III",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _termset_III}
	// forethought_connective spaces? forethought_coP_term_III
	// forethought_connective
	if !_fail(parser, _forethought_connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_term_III
	if !_fail(parser, _forethought_coP_term_IIIFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _termset_IIIAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_termset_III]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _termset_III}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_connective spaces? forethought_coP_term_III
	{
		var node0 string
		// forethought_connective
		if p, n := _forethought_connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_coP_term_III
		if p, n := _forethought_coP_term_IIIAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_term_IIIAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_term_III, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// terms_III spaces? forethought_co_bar_term_III
	// terms_III
	if !_accept(parser, _terms_IIIAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_term_III
	if !_accept(parser, _forethought_co_bar_term_IIIAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_term_III, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_term_III, start, -1, perr)
}

func _forethought_coP_term_IIINode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_term_III]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_term_III}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_term_III"}
	// terms_III spaces? forethought_co_bar_term_III
	// terms_III
	if !_node(parser, _terms_IIINode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_co_bar_term_III
	if !_node(parser, _forethought_co_bar_term_IIINode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_term_IIIFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_term_III, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_term_III",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_term_III}
	// terms_III spaces? forethought_co_bar_term_III
	// terms_III
	if !_fail(parser, _terms_IIIFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_term_III
	if !_fail(parser, _forethought_co_bar_term_IIIFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_term_IIIAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_term_III]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_term_III}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// terms_III spaces? forethought_co_bar_term_III
	{
		var node0 string
		// terms_III
		if p, n := _terms_IIIAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_co_bar_term_III
		if p, n := _forethought_co_bar_term_IIIAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_co_bar_term_IIIAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_co_bar_term_III, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// gik spaces? terms_III
	// gik
	if !_accept(parser, _gikAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms_III
	if !_accept(parser, _terms_IIIAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_co_bar_term_III, start, pos, perr)
fail:
	return _memoize(parser, _forethought_co_bar_term_III, start, -1, perr)
}

func _forethought_co_bar_term_IIINode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_co_bar_term_III]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_term_III}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_co_bar_term_III"}
	// gik spaces? terms_III
	// gik
	if !_node(parser, _gikNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// terms_III
	if !_node(parser, _terms_IIINode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_co_bar_term_IIIFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_co_bar_term_III, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_co_bar_term_III",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_co_bar_term_III}
	// gik spaces? terms_III
	// gik
	if !_fail(parser, _gikFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms_III
	if !_fail(parser, _terms_IIIFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_co_bar_term_IIIAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_co_bar_term_III]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_term_III}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// gik spaces? terms_III
	{
		var node0 string
		// gik
		if p, n := _gikAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// terms_III
		if p, n := _terms_IIIAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _termset_IVAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _termset_IV, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_connective spaces? forethought_coP_term_IV
	// forethought_connective
	if !_accept(parser, _forethought_connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_term_IV
	if !_accept(parser, _forethought_coP_term_IVAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _termset_IV, start, pos, perr)
fail:
	return _memoize(parser, _termset_IV, start, -1, perr)
}

func _termset_IVNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_termset_IV]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _termset_IV}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "termset_IV"}
	// forethought_connective spaces? forethought_coP_term_IV
	// forethought_connective
	if !_node(parser, _forethought_connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_coP_term_IV
	if !_node(parser, _forethought_coP_term_IVNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _termset_IVFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _termset_IV, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "termset_IV",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _termset_IV}
	// forethought_connective spaces? forethought_coP_term_IV
	// forethought_connective
	if !_fail(parser, _forethought_connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_term_IV
	if !_fail(parser, _forethought_coP_term_IVFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _termset_IVAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_termset_IV]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _termset_IV}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_connective spaces? forethought_coP_term_IV
	{
		var node0 string
		// forethought_connective
		if p, n := _forethought_connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_coP_term_IV
		if p, n := _forethought_coP_term_IVAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_term_IVAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_term_IV, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// terms_IV spaces? forethought_co_bar_term_IV
	// terms_IV
	if !_accept(parser, _terms_IVAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_term_IV
	if !_accept(parser, _forethought_co_bar_term_IVAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_term_IV, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_term_IV, start, -1, perr)
}

func _forethought_coP_term_IVNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_term_IV]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_term_IV}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_term_IV"}
	// terms_IV spaces? forethought_co_bar_term_IV
	// terms_IV
	if !_node(parser, _terms_IVNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_co_bar_term_IV
	if !_node(parser, _forethought_co_bar_term_IVNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_term_IVFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_term_IV, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_term_IV",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_term_IV}
	// terms_IV spaces? forethought_co_bar_term_IV
	// terms_IV
	if !_fail(parser, _terms_IVFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_term_IV
	if !_fail(parser, _forethought_co_bar_term_IVFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_term_IVAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_term_IV]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_term_IV}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// terms_IV spaces? forethought_co_bar_term_IV
	{
		var node0 string
		// terms_IV
		if p, n := _terms_IVAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_co_bar_term_IV
		if p, n := _forethought_co_bar_term_IVAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_co_bar_term_IVAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_co_bar_term_IV, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// gik spaces? terms_IV
	// gik
	if !_accept(parser, _gikAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms_IV
	if !_accept(parser, _terms_IVAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_co_bar_term_IV, start, pos, perr)
fail:
	return _memoize(parser, _forethought_co_bar_term_IV, start, -1, perr)
}

func _forethought_co_bar_term_IVNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_co_bar_term_IV]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_term_IV}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_co_bar_term_IV"}
	// gik spaces? terms_IV
	// gik
	if !_node(parser, _gikNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// terms_IV
	if !_node(parser, _terms_IVNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_co_bar_term_IVFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_co_bar_term_IV, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_co_bar_term_IV",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_co_bar_term_IV}
	// gik spaces? terms_IV
	// gik
	if !_fail(parser, _gikFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms_IV
	if !_fail(parser, _terms_IVFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_co_bar_term_IVAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_co_bar_term_IV]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_term_IV}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// gik spaces? terms_IV
	{
		var node0 string
		// gik
		if p, n := _gikAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// terms_IV
		if p, n := _terms_IVAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _termset_VAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _termset_V, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_connective spaces? forethought_coP_term_V
	// forethought_connective
	if !_accept(parser, _forethought_connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_term_V
	if !_accept(parser, _forethought_coP_term_VAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _termset_V, start, pos, perr)
fail:
	return _memoize(parser, _termset_V, start, -1, perr)
}

func _termset_VNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_termset_V]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _termset_V}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "termset_V"}
	// forethought_connective spaces? forethought_coP_term_V
	// forethought_connective
	if !_node(parser, _forethought_connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_coP_term_V
	if !_node(parser, _forethought_coP_term_VNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _termset_VFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _termset_V, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "termset_V",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _termset_V}
	// forethought_connective spaces? forethought_coP_term_V
	// forethought_connective
	if !_fail(parser, _forethought_connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_term_V
	if !_fail(parser, _forethought_coP_term_VFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _termset_VAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_termset_V]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _termset_V}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_connective spaces? forethought_coP_term_V
	{
		var node0 string
		// forethought_connective
		if p, n := _forethought_connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_coP_term_V
		if p, n := _forethought_coP_term_VAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_term_VAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_term_V, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// terms_V spaces? forethought_co_bar_term_V
	// terms_V
	if !_accept(parser, _terms_VAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_term_V
	if !_accept(parser, _forethought_co_bar_term_VAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_term_V, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_term_V, start, -1, perr)
}

func _forethought_coP_term_VNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_term_V]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_term_V}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_term_V"}
	// terms_V spaces? forethought_co_bar_term_V
	// terms_V
	if !_node(parser, _terms_VNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_co_bar_term_V
	if !_node(parser, _forethought_co_bar_term_VNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_term_VFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_term_V, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_term_V",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_term_V}
	// terms_V spaces? forethought_co_bar_term_V
	// terms_V
	if !_fail(parser, _terms_VFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_term_V
	if !_fail(parser, _forethought_co_bar_term_VFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_term_VAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_term_V]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_term_V}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// terms_V spaces? forethought_co_bar_term_V
	{
		var node0 string
		// terms_V
		if p, n := _terms_VAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_co_bar_term_V
		if p, n := _forethought_co_bar_term_VAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_co_bar_term_VAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_co_bar_term_V, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// gik spaces? terms_V
	// gik
	if !_accept(parser, _gikAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms_V
	if !_accept(parser, _terms_VAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_co_bar_term_V, start, pos, perr)
fail:
	return _memoize(parser, _forethought_co_bar_term_V, start, -1, perr)
}

func _forethought_co_bar_term_VNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_co_bar_term_V]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_term_V}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_co_bar_term_V"}
	// gik spaces? terms_V
	// gik
	if !_node(parser, _gikNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// terms_V
	if !_node(parser, _terms_VNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_co_bar_term_VFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_co_bar_term_V, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_co_bar_term_V",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_co_bar_term_V}
	// gik spaces? terms_V
	// gik
	if !_fail(parser, _gikFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms_V
	if !_fail(parser, _terms_VFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_co_bar_term_VAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_co_bar_term_V]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_term_V}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// gik spaces? terms_V
	{
		var node0 string
		// gik
		if p, n := _gikAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// terms_V
		if p, n := _terms_VAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_connectiveAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_connective, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// spaces? forethought_marker spaces? connective
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_marker
	if !_accept(parser, _forethought_markerAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos6 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	// connective
	if !_accept(parser, _connectiveAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_connective, start, pos, perr)
fail:
	return _memoize(parser, _forethought_connective, start, -1, perr)
}

func _forethought_connectiveNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_connective]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_connective}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_connective"}
	// spaces? forethought_marker spaces? connective
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_marker
	if !_node(parser, _forethought_markerNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	// connective
	if !_node(parser, _connectiveNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_connectiveFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_connective, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_connective",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_connective}
	// spaces? forethought_marker spaces? connective
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_marker
	if !_fail(parser, _forethought_markerFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos6 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	// connective
	if !_fail(parser, _connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_connectiveAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_connective]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_connective}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// spaces? forethought_marker spaces? connective
	{
		var node0 string
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_marker
		if p, n := _forethought_markerAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos6 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
		// connective
		if p, n := _connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_markerAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_marker, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// t o &boundary
	// t
	if !_accept(parser, _tAccepts, &pos, &perr) {
		goto fail
	}
	// o
	if !_accept(parser, _oAccepts, &pos, &perr) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		perr4 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	return _memoize(parser, _forethought_marker, start, pos, perr)
fail:
	return _memoize(parser, _forethought_marker, start, -1, perr)
}

func _forethought_markerNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_marker]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_marker}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_marker"}
	// t o &boundary
	// t
	if !_node(parser, _tNode, node, &pos) {
		goto fail
	}
	// o
	if !_node(parser, _oNode, node, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_markerFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_marker, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_marker",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_marker}
	// t o &boundary
	// t
	if !_fail(parser, _tFail, errPos, failure, &pos) {
		goto fail
	}
	// o
	if !_fail(parser, _oFail, errPos, failure, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_markerAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_marker]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_marker}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// t o &boundary
	{
		var node0 string
		// t
		if p, n := _tAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// o
		if p, n := _oAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// &boundary
		{
			pos2 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _gikAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _gik, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// t o &boundary
	// t
	if !_accept(parser, _tAccepts, &pos, &perr) {
		goto fail
	}
	// o
	if !_accept(parser, _oAccepts, &pos, &perr) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		perr4 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	return _memoize(parser, _gik, start, pos, perr)
fail:
	return _memoize(parser, _gik, start, -1, perr)
}

func _gikNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_gik]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _gik}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "gik"}
	// t o &boundary
	// t
	if !_node(parser, _tNode, node, &pos) {
		goto fail
	}
	// o
	if !_node(parser, _oNode, node, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _gikFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _gik, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "gik",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _gik}
	// t o &boundary
	// t
	if !_fail(parser, _tFail, errPos, failure, &pos) {
		goto fail
	}
	// o
	if !_fail(parser, _oFail, errPos, failure, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _gikAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_gik]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _gik}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// t o &boundary
	{
		var node0 string
		// t
		if p, n := _tAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// o
		if p, n := _oAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// &boundary
		{
			pos2 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _terms_IIAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _terms_II, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// term spaces? term
	// term
	if !_accept(parser, _termAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// term
	if !_accept(parser, _termAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _terms_II, start, pos, perr)
fail:
	return _memoize(parser, _terms_II, start, -1, perr)
}

func _terms_IINode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_terms_II]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _terms_II}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "terms_II"}
	// term spaces? term
	// term
	if !_node(parser, _termNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// term
	if !_node(parser, _termNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _terms_IIFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _terms_II, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "terms_II",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _terms_II}
	// term spaces? term
	// term
	if !_fail(parser, _termFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// term
	if !_fail(parser, _termFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _terms_IIAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_terms_II]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _terms_II}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// term spaces? term
	{
		var node0 string
		// term
		if p, n := _termAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// term
		if p, n := _termAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _terms_IIIAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _terms_III, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// term spaces? terms_II
	// term
	if !_accept(parser, _termAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms_II
	if !_accept(parser, _terms_IIAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _terms_III, start, pos, perr)
fail:
	return _memoize(parser, _terms_III, start, -1, perr)
}

func _terms_IIINode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_terms_III]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _terms_III}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "terms_III"}
	// term spaces? terms_II
	// term
	if !_node(parser, _termNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// terms_II
	if !_node(parser, _terms_IINode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _terms_IIIFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _terms_III, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "terms_III",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _terms_III}
	// term spaces? terms_II
	// term
	if !_fail(parser, _termFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms_II
	if !_fail(parser, _terms_IIFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _terms_IIIAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_terms_III]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _terms_III}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// term spaces? terms_II
	{
		var node0 string
		// term
		if p, n := _termAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// terms_II
		if p, n := _terms_IIAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _terms_IVAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _terms_IV, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// term spaces? terms_III
	// term
	if !_accept(parser, _termAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms_III
	if !_accept(parser, _terms_IIIAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _terms_IV, start, pos, perr)
fail:
	return _memoize(parser, _terms_IV, start, -1, perr)
}

func _terms_IVNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_terms_IV]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _terms_IV}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "terms_IV"}
	// term spaces? terms_III
	// term
	if !_node(parser, _termNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// terms_III
	if !_node(parser, _terms_IIINode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _terms_IVFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _terms_IV, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "terms_IV",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _terms_IV}
	// term spaces? terms_III
	// term
	if !_fail(parser, _termFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms_III
	if !_fail(parser, _terms_IIIFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _terms_IVAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_terms_IV]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _terms_IV}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// term spaces? terms_III
	{
		var node0 string
		// term
		if p, n := _termAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// terms_III
		if p, n := _terms_IIIAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _terms_VAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _terms_V, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// term spaces? terms_IV
	// term
	if !_accept(parser, _termAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms_IV
	if !_accept(parser, _terms_IVAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _terms_V, start, pos, perr)
fail:
	return _memoize(parser, _terms_V, start, -1, perr)
}

func _terms_VNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_terms_V]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _terms_V}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "terms_V"}
	// term spaces? terms_IV
	// term
	if !_node(parser, _termNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// terms_IV
	if !_node(parser, _terms_IVNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _terms_VFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _terms_V, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "terms_V",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _terms_V}
	// term spaces? terms_IV
	// term
	if !_fail(parser, _termFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms_IV
	if !_fail(parser, _terms_IVFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _terms_VAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_terms_V]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _terms_V}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// term spaces? terms_IV
	{
		var node0 string
		// term
		if p, n := _termAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// terms_IV
		if p, n := _terms_IVAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _adverbAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _adverb, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// coP_adverb/adverb_1
	{
		pos2 := pos
		// coP_adverb
		if !_accept(parser, _coP_adverbAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// adverb_1
		if !_accept(parser, _adverb_1Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _adverb, start, pos, perr)
fail:
	return _memoize(parser, _adverb, start, -1, perr)
}

func _adverbNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _adverb}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "adverb"}
	// coP_adverb/adverb_1
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// coP_adverb
		if !_node(parser, _coP_adverbNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// adverb_1
		if !_node(parser, _adverb_1Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _adverbFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _adverb, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "adverb",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _adverb}
	// coP_adverb/adverb_1
	{
		pos2 := pos
		// coP_adverb
		if !_fail(parser, _coP_adverbFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// adverb_1
		if !_fail(parser, _adverb_1Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _adverbAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _adverb}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// coP_adverb/adverb_1
	{
		pos2 := pos
		// coP_adverb
		if p, n := _coP_adverbAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// adverb_1
		if p, n := _adverb_1Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _adverb_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _adverb_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_coP_adverb/adverb_2
	{
		pos2 := pos
		// forethought_coP_adverb
		if !_accept(parser, _forethought_coP_adverbAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// adverb_2
		if !_accept(parser, _adverb_2Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _adverb_1, start, pos, perr)
fail:
	return _memoize(parser, _adverb_1, start, -1, perr)
}

func _adverb_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_adverb_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _adverb_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "adverb_1"}
	// forethought_coP_adverb/adverb_2
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// forethought_coP_adverb
		if !_node(parser, _forethought_coP_adverbNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// adverb_2
		if !_node(parser, _adverb_2Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _adverb_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _adverb_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "adverb_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _adverb_1}
	// forethought_coP_adverb/adverb_2
	{
		pos2 := pos
		// forethought_coP_adverb
		if !_fail(parser, _forethought_coP_adverbFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// adverb_2
		if !_fail(parser, _adverb_2Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _adverb_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_adverb_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _adverb_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_coP_adverb/adverb_2
	{
		pos2 := pos
		// forethought_coP_adverb
		if p, n := _forethought_coP_adverbAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// adverb_2
		if p, n := _adverb_2Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _adverb_2Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _adverb_2, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// serial_adverb/adverb_3
	{
		pos2 := pos
		// serial_adverb
		if !_accept(parser, _serial_adverbAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// adverb_3
		if !_accept(parser, _adverb_3Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _adverb_2, start, pos, perr)
fail:
	return _memoize(parser, _adverb_2, start, -1, perr)
}

func _adverb_2Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_adverb_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _adverb_2}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "adverb_2"}
	// serial_adverb/adverb_3
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// serial_adverb
		if !_node(parser, _serial_adverbNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// adverb_3
		if !_node(parser, _adverb_3Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _adverb_2Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _adverb_2, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "adverb_2",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _adverb_2}
	// serial_adverb/adverb_3
	{
		pos2 := pos
		// serial_adverb
		if !_fail(parser, _serial_adverbFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// adverb_3
		if !_fail(parser, _adverb_3Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _adverb_2Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_adverb_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _adverb_2}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// serial_adverb/adverb_3
	{
		pos2 := pos
		// serial_adverb
		if p, n := _serial_adverbAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// adverb_3
		if p, n := _adverb_3Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _adverb_3Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _adverb_3, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// coP_pred_adverb/forethought_coP_pred_adverb/LU_adverb/MI_adverb/PO_adverb/quotation_adverb/adverb_4
	{
		pos2 := pos
		// coP_pred_adverb
		if !_accept(parser, _coP_pred_adverbAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// forethought_coP_pred_adverb
		if !_accept(parser, _forethought_coP_pred_adverbAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// LU_adverb
		if !_accept(parser, _LU_adverbAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// MI_adverb
		if !_accept(parser, _MI_adverbAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// PO_adverb
		if !_accept(parser, _PO_adverbAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// quotation_adverb
		if !_accept(parser, _quotation_adverbAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// adverb_4
		if !_accept(parser, _adverb_4Accepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _adverb_3, start, pos, perr)
fail:
	return _memoize(parser, _adverb_3, start, -1, perr)
}

func _adverb_3Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_adverb_3]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _adverb_3}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "adverb_3"}
	// coP_pred_adverb/forethought_coP_pred_adverb/LU_adverb/MI_adverb/PO_adverb/quotation_adverb/adverb_4
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// coP_pred_adverb
		if !_node(parser, _coP_pred_adverbNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// forethought_coP_pred_adverb
		if !_node(parser, _forethought_coP_pred_adverbNode, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// LU_adverb
		if !_node(parser, _LU_adverbNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// MI_adverb
		if !_node(parser, _MI_adverbNode, node, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// PO_adverb
		if !_node(parser, _PO_adverbNode, node, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// quotation_adverb
		if !_node(parser, _quotation_adverbNode, node, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// adverb_4
		if !_node(parser, _adverb_4Node, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _adverb_3Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _adverb_3, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "adverb_3",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _adverb_3}
	// coP_pred_adverb/forethought_coP_pred_adverb/LU_adverb/MI_adverb/PO_adverb/quotation_adverb/adverb_4
	{
		pos2 := pos
		// coP_pred_adverb
		if !_fail(parser, _coP_pred_adverbFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// forethought_coP_pred_adverb
		if !_fail(parser, _forethought_coP_pred_adverbFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// LU_adverb
		if !_fail(parser, _LU_adverbFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// MI_adverb
		if !_fail(parser, _MI_adverbFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// PO_adverb
		if !_fail(parser, _PO_adverbFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// quotation_adverb
		if !_fail(parser, _quotation_adverbFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// adverb_4
		if !_fail(parser, _adverb_4Fail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _adverb_3Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_adverb_3]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _adverb_3}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// coP_pred_adverb/forethought_coP_pred_adverb/LU_adverb/MI_adverb/PO_adverb/quotation_adverb/adverb_4
	{
		pos2 := pos
		// coP_pred_adverb
		if p, n := _coP_pred_adverbAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// forethought_coP_pred_adverb
		if p, n := _forethought_coP_pred_adverbAction(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		// LU_adverb
		if p, n := _LU_adverbAction(parser, pos); n == nil {
			goto fail5
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail5:
		pos = pos2
		// MI_adverb
		if p, n := _MI_adverbAction(parser, pos); n == nil {
			goto fail6
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail6:
		pos = pos2
		// PO_adverb
		if p, n := _PO_adverbAction(parser, pos); n == nil {
			goto fail7
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail7:
		pos = pos2
		// quotation_adverb
		if p, n := _quotation_adverbAction(parser, pos); n == nil {
			goto fail8
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail8:
		pos = pos2
		// adverb_4
		if p, n := _adverb_4Action(parser, pos); n == nil {
			goto fail9
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _adverb_4Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _adverb_4, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// adverb_syllable compound_syllable+/!function_word adverb_syllable
	{
		pos2 := pos
		// adverb_syllable compound_syllable+
		// adverb_syllable
		if !_accept(parser, _adverb_syllableAccepts, &pos, &perr) {
			goto fail3
		}
		// compound_syllable+
		// compound_syllable
		if !_accept(parser, _compound_syllableAccepts, &pos, &perr) {
			goto fail3
		}
		for {
			pos6 := pos
			// compound_syllable
			if !_accept(parser, _compound_syllableAccepts, &pos, &perr) {
				goto fail8
			}
			continue
		fail8:
			pos = pos6
			break
		}
		goto ok0
	fail3:
		pos = pos2
		// !function_word adverb_syllable
		// !function_word
		{
			pos12 := pos
			perr14 := perr
			// function_word
			if !_accept(parser, _function_wordAccepts, &pos, &perr) {
				goto ok11
			}
			pos = pos12
			perr = _max(perr14, pos)
			goto fail9
		ok11:
			pos = pos12
			perr = perr14
		}
		// adverb_syllable
		if !_accept(parser, _adverb_syllableAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _adverb_4, start, pos, perr)
fail:
	return _memoize(parser, _adverb_4, start, -1, perr)
}

func _adverb_4Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_adverb_4]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _adverb_4}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "adverb_4"}
	// adverb_syllable compound_syllable+/!function_word adverb_syllable
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// adverb_syllable compound_syllable+
		// adverb_syllable
		if !_node(parser, _adverb_syllableNode, node, &pos) {
			goto fail3
		}
		// compound_syllable+
		// compound_syllable
		if !_node(parser, _compound_syllableNode, node, &pos) {
			goto fail3
		}
		for {
			nkids5 := len(node.Kids)
			pos6 := pos
			// compound_syllable
			if !_node(parser, _compound_syllableNode, node, &pos) {
				goto fail8
			}
			continue
		fail8:
			node.Kids = node.Kids[:nkids5]
			pos = pos6
			break
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// !function_word adverb_syllable
		// !function_word
		{
			pos12 := pos
			nkids13 := len(node.Kids)
			// function_word
			if !_node(parser, _function_wordNode, node, &pos) {
				goto ok11
			}
			pos = pos12
			node.Kids = node.Kids[:nkids13]
			goto fail9
		ok11:
			pos = pos12
			node.Kids = node.Kids[:nkids13]
		}
		// adverb_syllable
		if !_node(parser, _adverb_syllableNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _adverb_4Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _adverb_4, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "adverb_4",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _adverb_4}
	// adverb_syllable compound_syllable+/!function_word adverb_syllable
	{
		pos2 := pos
		// adverb_syllable compound_syllable+
		// adverb_syllable
		if !_fail(parser, _adverb_syllableFail, errPos, failure, &pos) {
			goto fail3
		}
		// compound_syllable+
		// compound_syllable
		if !_fail(parser, _compound_syllableFail, errPos, failure, &pos) {
			goto fail3
		}
		for {
			pos6 := pos
			// compound_syllable
			if !_fail(parser, _compound_syllableFail, errPos, failure, &pos) {
				goto fail8
			}
			continue
		fail8:
			pos = pos6
			break
		}
		goto ok0
	fail3:
		pos = pos2
		// !function_word adverb_syllable
		// !function_word
		{
			pos12 := pos
			nkids13 := len(failure.Kids)
			// function_word
			if !_fail(parser, _function_wordFail, errPos, failure, &pos) {
				goto ok11
			}
			pos = pos12
			failure.Kids = failure.Kids[:nkids13]
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "!function_word",
				})
			}
			goto fail9
		ok11:
			pos = pos12
			failure.Kids = failure.Kids[:nkids13]
		}
		// adverb_syllable
		if !_fail(parser, _adverb_syllableFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _adverb_4Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_adverb_4]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _adverb_4}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// adverb_syllable compound_syllable+/!function_word adverb_syllable
	{
		pos2 := pos
		// adverb_syllable compound_syllable+
		{
			var node4 string
			// adverb_syllable
			if p, n := _adverb_syllableAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
			// compound_syllable+
			{
				var node7 string
				// compound_syllable
				if p, n := _compound_syllableAction(parser, pos); n == nil {
					goto fail3
				} else {
					node7 = *n
					pos = p
				}
				node4 += node7
			}
			for {
				pos6 := pos
				var node7 string
				// compound_syllable
				if p, n := _compound_syllableAction(parser, pos); n == nil {
					goto fail8
				} else {
					node7 = *n
					pos = p
				}
				node4 += node7
				continue
			fail8:
				pos = pos6
				break
			}
			node += node4
		}
		goto ok0
	fail3:
		pos = pos2
		// !function_word adverb_syllable
		{
			var node10 string
			// !function_word
			{
				pos12 := pos
				// function_word
				if p, n := _function_wordAction(parser, pos); n == nil {
					goto ok11
				} else {
					pos = p
				}
				pos = pos12
				goto fail9
			ok11:
				pos = pos12
				node = ""
			}
			node += node10
			// adverb_syllable
			if p, n := _adverb_syllableAction(parser, pos); n == nil {
				goto fail9
			} else {
				node10 = *n
				pos = p
			}
			node += node10
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _coP_adverbAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _coP_adverb, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// adverb_1 spaces? co_bar_adverb
	// adverb_1
	if !_accept(parser, _adverb_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_adverb
	if !_accept(parser, _co_bar_adverbAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _coP_adverb, start, pos, perr)
fail:
	return _memoize(parser, _coP_adverb, start, -1, perr)
}

func _coP_adverbNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_coP_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_adverb}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "coP_adverb"}
	// adverb_1 spaces? co_bar_adverb
	// adverb_1
	if !_node(parser, _adverb_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// co_bar_adverb
	if !_node(parser, _co_bar_adverbNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _coP_adverbFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _coP_adverb, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "coP_adverb",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _coP_adverb}
	// adverb_1 spaces? co_bar_adverb
	// adverb_1
	if !_fail(parser, _adverb_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_adverb
	if !_fail(parser, _co_bar_adverbFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _coP_adverbAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_coP_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_adverb}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// adverb_1 spaces? co_bar_adverb
	{
		var node0 string
		// adverb_1
		if p, n := _adverb_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// co_bar_adverb
		if p, n := _co_bar_adverbAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _co_bar_adverbAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _co_bar_adverb, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// connective spaces? adverb
	// connective
	if !_accept(parser, _connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// adverb
	if !_accept(parser, _adverbAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _co_bar_adverb, start, pos, perr)
fail:
	return _memoize(parser, _co_bar_adverb, start, -1, perr)
}

func _co_bar_adverbNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_co_bar_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _co_bar_adverb}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "co_bar_adverb"}
	// connective spaces? adverb
	// connective
	if !_node(parser, _connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// adverb
	if !_node(parser, _adverbNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _co_bar_adverbFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _co_bar_adverb, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "co_bar_adverb",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _co_bar_adverb}
	// connective spaces? adverb
	// connective
	if !_fail(parser, _connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// adverb
	if !_fail(parser, _adverbFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _co_bar_adverbAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_co_bar_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _co_bar_adverb}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// connective spaces? adverb
	{
		var node0 string
		// connective
		if p, n := _connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// adverb
		if p, n := _adverbAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_adverbAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_adverb, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_connective spaces? forethought_coP_adverb_1
	// forethought_connective
	if !_accept(parser, _forethought_connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_adverb_1
	if !_accept(parser, _forethought_coP_adverb_1Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_adverb, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_adverb, start, -1, perr)
}

func _forethought_coP_adverbNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_adverb}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_adverb"}
	// forethought_connective spaces? forethought_coP_adverb_1
	// forethought_connective
	if !_node(parser, _forethought_connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_coP_adverb_1
	if !_node(parser, _forethought_coP_adverb_1Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_adverbFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_adverb, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_adverb",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_adverb}
	// forethought_connective spaces? forethought_coP_adverb_1
	// forethought_connective
	if !_fail(parser, _forethought_connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_adverb_1
	if !_fail(parser, _forethought_coP_adverb_1Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_adverbAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_adverb}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_connective spaces? forethought_coP_adverb_1
	{
		var node0 string
		// forethought_connective
		if p, n := _forethought_connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_coP_adverb_1
		if p, n := _forethought_coP_adverb_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_adverb_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_adverb_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// adverb spaces? forethought_co_bar_adverb
	// adverb
	if !_accept(parser, _adverbAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_adverb
	if !_accept(parser, _forethought_co_bar_adverbAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_adverb_1, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_adverb_1, start, -1, perr)
}

func _forethought_coP_adverb_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_adverb_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_adverb_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_adverb_1"}
	// adverb spaces? forethought_co_bar_adverb
	// adverb
	if !_node(parser, _adverbNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_co_bar_adverb
	if !_node(parser, _forethought_co_bar_adverbNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_adverb_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_adverb_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_adverb_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_adverb_1}
	// adverb spaces? forethought_co_bar_adverb
	// adverb
	if !_fail(parser, _adverbFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_adverb
	if !_fail(parser, _forethought_co_bar_adverbFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_adverb_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_adverb_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_adverb_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// adverb spaces? forethought_co_bar_adverb
	{
		var node0 string
		// adverb
		if p, n := _adverbAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_co_bar_adverb
		if p, n := _forethought_co_bar_adverbAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_co_bar_adverbAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_co_bar_adverb, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// gik spaces? adverb
	// gik
	if !_accept(parser, _gikAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// adverb
	if !_accept(parser, _adverbAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_co_bar_adverb, start, pos, perr)
fail:
	return _memoize(parser, _forethought_co_bar_adverb, start, -1, perr)
}

func _forethought_co_bar_adverbNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_co_bar_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_adverb}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_co_bar_adverb"}
	// gik spaces? adverb
	// gik
	if !_node(parser, _gikNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// adverb
	if !_node(parser, _adverbNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_co_bar_adverbFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_co_bar_adverb, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_co_bar_adverb",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_co_bar_adverb}
	// gik spaces? adverb
	// gik
	if !_fail(parser, _gikFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// adverb
	if !_fail(parser, _adverbFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_co_bar_adverbAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_co_bar_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_adverb}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// gik spaces? adverb
	{
		var node0 string
		// gik
		if p, n := _gikAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// adverb
		if p, n := _adverbAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _serial_adverbAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _serial_adverb, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// adverb_3 spaces? serial_predicate
	// adverb_3
	if !_accept(parser, _adverb_3Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// serial_predicate
	if !_accept(parser, _serial_predicateAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _serial_adverb, start, pos, perr)
fail:
	return _memoize(parser, _serial_adverb, start, -1, perr)
}

func _serial_adverbNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_serial_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _serial_adverb}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "serial_adverb"}
	// adverb_3 spaces? serial_predicate
	// adverb_3
	if !_node(parser, _adverb_3Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// serial_predicate
	if !_node(parser, _serial_predicateNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _serial_adverbFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _serial_adverb, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "serial_adverb",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _serial_adverb}
	// adverb_3 spaces? serial_predicate
	// adverb_3
	if !_fail(parser, _adverb_3Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// serial_predicate
	if !_fail(parser, _serial_predicateFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _serial_adverbAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_serial_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _serial_adverb}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// adverb_3 spaces? serial_predicate
	{
		var node0 string
		// adverb_3
		if p, n := _adverb_3Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// serial_predicate
		if p, n := _serial_predicateAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _coP_pred_adverbAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _coP_pred_adverb, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// adverb_4 spaces? co_bar_pred
	// adverb_4
	if !_accept(parser, _adverb_4Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_pred
	if !_accept(parser, _co_bar_predAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _coP_pred_adverb, start, pos, perr)
fail:
	return _memoize(parser, _coP_pred_adverb, start, -1, perr)
}

func _coP_pred_adverbNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_coP_pred_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_pred_adverb}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "coP_pred_adverb"}
	// adverb_4 spaces? co_bar_pred
	// adverb_4
	if !_node(parser, _adverb_4Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// co_bar_pred
	if !_node(parser, _co_bar_predNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _coP_pred_adverbFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _coP_pred_adverb, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "coP_pred_adverb",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _coP_pred_adverb}
	// adverb_4 spaces? co_bar_pred
	// adverb_4
	if !_fail(parser, _adverb_4Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_pred
	if !_fail(parser, _co_bar_predFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _coP_pred_adverbAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_coP_pred_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_pred_adverb}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// adverb_4 spaces? co_bar_pred
	{
		var node0 string
		// adverb_4
		if p, n := _adverb_4Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// co_bar_pred
		if p, n := _co_bar_predAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_pred_adverbAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_pred_adverb, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_connective spaces? forethought_coP_pred_adverb_1
	// forethought_connective
	if !_accept(parser, _forethought_connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_pred_adverb_1
	if !_accept(parser, _forethought_coP_pred_adverb_1Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_pred_adverb, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_pred_adverb, start, -1, perr)
}

func _forethought_coP_pred_adverbNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_pred_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_adverb}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_pred_adverb"}
	// forethought_connective spaces? forethought_coP_pred_adverb_1
	// forethought_connective
	if !_node(parser, _forethought_connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_coP_pred_adverb_1
	if !_node(parser, _forethought_coP_pred_adverb_1Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_pred_adverbFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_pred_adverb, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_pred_adverb",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_pred_adverb}
	// forethought_connective spaces? forethought_coP_pred_adverb_1
	// forethought_connective
	if !_fail(parser, _forethought_connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_pred_adverb_1
	if !_fail(parser, _forethought_coP_pred_adverb_1Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_pred_adverbAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_pred_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_adverb}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_connective spaces? forethought_coP_pred_adverb_1
	{
		var node0 string
		// forethought_connective
		if p, n := _forethought_connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_coP_pred_adverb_1
		if p, n := _forethought_coP_pred_adverb_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_pred_adverb_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_pred_adverb_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// adverb spaces? forethought_co_bar_pred
	// adverb
	if !_accept(parser, _adverbAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_pred
	if !_accept(parser, _forethought_co_bar_predAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_pred_adverb_1, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_pred_adverb_1, start, -1, perr)
}

func _forethought_coP_pred_adverb_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_pred_adverb_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_adverb_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_pred_adverb_1"}
	// adverb spaces? forethought_co_bar_pred
	// adverb
	if !_node(parser, _adverbNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_co_bar_pred
	if !_node(parser, _forethought_co_bar_predNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_pred_adverb_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_pred_adverb_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_pred_adverb_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_pred_adverb_1}
	// adverb spaces? forethought_co_bar_pred
	// adverb
	if !_fail(parser, _adverbFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_pred
	if !_fail(parser, _forethought_co_bar_predFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_pred_adverb_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_pred_adverb_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_adverb_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// adverb spaces? forethought_co_bar_pred
	{
		var node0 string
		// adverb
		if p, n := _adverbAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_co_bar_pred
		if p, n := _forethought_co_bar_predAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _LU_adverbAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _LU_adverb, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// LU_adverb_tone spaces? statement
	// LU_adverb_tone
	if !_accept(parser, _LU_adverb_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// statement
	if !_accept(parser, _statementAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _LU_adverb, start, pos, perr)
fail:
	return _memoize(parser, _LU_adverb, start, -1, perr)
}

func _LU_adverbNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_LU_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_adverb}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "LU_adverb"}
	// LU_adverb_tone spaces? statement
	// LU_adverb_tone
	if !_node(parser, _LU_adverb_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// statement
	if !_node(parser, _statementNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _LU_adverbFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _LU_adverb, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "LU_adverb",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _LU_adverb}
	// LU_adverb_tone spaces? statement
	// LU_adverb_tone
	if !_fail(parser, _LU_adverb_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// statement
	if !_fail(parser, _statementFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _LU_adverbAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_LU_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_adverb}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// LU_adverb_tone spaces? statement
	{
		var node0 string
		// LU_adverb_tone
		if p, n := _LU_adverb_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// statement
		if p, n := _statementAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _LU_adverb_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _LU_adverb_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &LU adverb_syllable
	// &LU
	{
		pos2 := pos
		perr4 := perr
		// LU
		if !_accept(parser, _LUAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// adverb_syllable
	if !_accept(parser, _adverb_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _LU_adverb_tone, start, pos, perr)
fail:
	return _memoize(parser, _LU_adverb_tone, start, -1, perr)
}

func _LU_adverb_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_LU_adverb_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_adverb_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "LU_adverb_tone"}
	// &LU adverb_syllable
	// &LU
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// LU
		if !_node(parser, _LUNode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// adverb_syllable
	if !_node(parser, _adverb_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _LU_adverb_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _LU_adverb_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "LU_adverb_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _LU_adverb_tone}
	// &LU adverb_syllable
	// &LU
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// LU
		if !_fail(parser, _LUFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&LU",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// adverb_syllable
	if !_fail(parser, _adverb_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _LU_adverb_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_LU_adverb_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_adverb_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &LU adverb_syllable
	{
		var node0 string
		// &LU
		{
			pos2 := pos
			// LU
			if p, n := _LUAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// adverb_syllable
		if p, n := _adverb_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MI_adverbAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MI_adverb, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MI_adverb_1 spaces? GA?
	// MI_adverb_1
	if !_accept(parser, _MI_adverb_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_accept(parser, _GAAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	return _memoize(parser, _MI_adverb, start, pos, perr)
fail:
	return _memoize(parser, _MI_adverb, start, -1, perr)
}

func _MI_adverbNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MI_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_adverb}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MI_adverb"}
	// MI_adverb_1 spaces? GA?
	// MI_adverb_1
	if !_node(parser, _MI_adverb_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// GA?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// GA
		if !_node(parser, _GANode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MI_adverbFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MI_adverb, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MI_adverb",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MI_adverb}
	// MI_adverb_1 spaces? GA?
	// MI_adverb_1
	if !_fail(parser, _MI_adverb_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_fail(parser, _GAFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MI_adverbAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MI_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_adverb}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MI_adverb_1 spaces? GA?
	{
		var node0 string
		// MI_adverb_1
		if p, n := _MI_adverb_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// GA?
		{
			pos6 := pos
			// GA
			if p, n := _GAAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MI_adverb_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MI_adverb_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MI_adverb_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	// MI_adverb_tone
	if !_accept(parser, _MI_adverb_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// (predicate/argument/adverb/prepositional_phrase)
	// predicate/argument/adverb/prepositional_phrase
	{
		pos7 := pos
		// predicate
		if !_accept(parser, _predicateAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok5
	fail8:
		pos = pos7
		// argument
		if !_accept(parser, _argumentAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok5
	fail9:
		pos = pos7
		// adverb
		if !_accept(parser, _adverbAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok5
	fail10:
		pos = pos7
		// prepositional_phrase
		if !_accept(parser, _prepositional_phraseAccepts, &pos, &perr) {
			goto fail11
		}
		goto ok5
	fail11:
		pos = pos7
		goto fail
	ok5:
	}
	return _memoize(parser, _MI_adverb_1, start, pos, perr)
fail:
	return _memoize(parser, _MI_adverb_1, start, -1, perr)
}

func _MI_adverb_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MI_adverb_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_adverb_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MI_adverb_1"}
	// MI_adverb_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	// MI_adverb_tone
	if !_node(parser, _MI_adverb_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// (predicate/argument/adverb/prepositional_phrase)
	{
		nkids5 := len(node.Kids)
		pos06 := pos
		// predicate/argument/adverb/prepositional_phrase
		{
			pos9 := pos
			nkids8 := len(node.Kids)
			// predicate
			if !_node(parser, _predicateNode, node, &pos) {
				goto fail10
			}
			goto ok7
		fail10:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// argument
			if !_node(parser, _argumentNode, node, &pos) {
				goto fail11
			}
			goto ok7
		fail11:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// adverb
			if !_node(parser, _adverbNode, node, &pos) {
				goto fail12
			}
			goto ok7
		fail12:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// prepositional_phrase
			if !_node(parser, _prepositional_phraseNode, node, &pos) {
				goto fail13
			}
			goto ok7
		fail13:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			goto fail
		ok7:
		}
		sub := _sub(parser, pos06, pos, node.Kids[nkids5:])
		node.Kids = append(node.Kids[:nkids5], sub)
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MI_adverb_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MI_adverb_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MI_adverb_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MI_adverb_1}
	// MI_adverb_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	// MI_adverb_tone
	if !_fail(parser, _MI_adverb_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// (predicate/argument/adverb/prepositional_phrase)
	// predicate/argument/adverb/prepositional_phrase
	{
		pos7 := pos
		// predicate
		if !_fail(parser, _predicateFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok5
	fail8:
		pos = pos7
		// argument
		if !_fail(parser, _argumentFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok5
	fail9:
		pos = pos7
		// adverb
		if !_fail(parser, _adverbFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok5
	fail10:
		pos = pos7
		// prepositional_phrase
		if !_fail(parser, _prepositional_phraseFail, errPos, failure, &pos) {
			goto fail11
		}
		goto ok5
	fail11:
		pos = pos7
		goto fail
	ok5:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MI_adverb_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MI_adverb_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_adverb_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MI_adverb_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	{
		var node0 string
		// MI_adverb_tone
		if p, n := _MI_adverb_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// (predicate/argument/adverb/prepositional_phrase)
		// predicate/argument/adverb/prepositional_phrase
		{
			pos7 := pos
			// predicate
			if p, n := _predicateAction(parser, pos); n == nil {
				goto fail8
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail8:
			pos = pos7
			// argument
			if p, n := _argumentAction(parser, pos); n == nil {
				goto fail9
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail9:
			pos = pos7
			// adverb
			if p, n := _adverbAction(parser, pos); n == nil {
				goto fail10
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail10:
			pos = pos7
			// prepositional_phrase
			if p, n := _prepositional_phraseAction(parser, pos); n == nil {
				goto fail11
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail11:
			pos = pos7
			goto fail
		ok5:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MI_adverb_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MI_adverb_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &MI adverb_syllable
	// &MI
	{
		pos2 := pos
		perr4 := perr
		// MI
		if !_accept(parser, _MIAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// adverb_syllable
	if !_accept(parser, _adverb_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _MI_adverb_tone, start, pos, perr)
fail:
	return _memoize(parser, _MI_adverb_tone, start, -1, perr)
}

func _MI_adverb_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MI_adverb_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_adverb_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MI_adverb_tone"}
	// &MI adverb_syllable
	// &MI
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// MI
		if !_node(parser, _MINode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// adverb_syllable
	if !_node(parser, _adverb_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MI_adverb_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MI_adverb_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MI_adverb_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MI_adverb_tone}
	// &MI adverb_syllable
	// &MI
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// MI
		if !_fail(parser, _MIFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&MI",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// adverb_syllable
	if !_fail(parser, _adverb_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MI_adverb_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MI_adverb_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_adverb_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &MI adverb_syllable
	{
		var node0 string
		// &MI
		{
			pos2 := pos
			// MI
			if p, n := _MIAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// adverb_syllable
		if p, n := _adverb_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _PO_adverbAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _PO_adverb, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// PO_adverb_1 spaces? GA?
	// PO_adverb_1
	if !_accept(parser, _PO_adverb_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_accept(parser, _GAAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	return _memoize(parser, _PO_adverb, start, pos, perr)
fail:
	return _memoize(parser, _PO_adverb, start, -1, perr)
}

func _PO_adverbNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_PO_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_adverb}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "PO_adverb"}
	// PO_adverb_1 spaces? GA?
	// PO_adverb_1
	if !_node(parser, _PO_adverb_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// GA?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// GA
		if !_node(parser, _GANode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _PO_adverbFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _PO_adverb, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "PO_adverb",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _PO_adverb}
	// PO_adverb_1 spaces? GA?
	// PO_adverb_1
	if !_fail(parser, _PO_adverb_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_fail(parser, _GAFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _PO_adverbAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_PO_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_adverb}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// PO_adverb_1 spaces? GA?
	{
		var node0 string
		// PO_adverb_1
		if p, n := _PO_adverb_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// GA?
		{
			pos6 := pos
			// GA
			if p, n := _GAAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _PO_adverb_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _PO_adverb_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// PO_adverb_tone spaces? argument
	// PO_adverb_tone
	if !_accept(parser, _PO_adverb_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// argument
	if !_accept(parser, _argumentAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _PO_adverb_1, start, pos, perr)
fail:
	return _memoize(parser, _PO_adverb_1, start, -1, perr)
}

func _PO_adverb_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_PO_adverb_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_adverb_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "PO_adverb_1"}
	// PO_adverb_tone spaces? argument
	// PO_adverb_tone
	if !_node(parser, _PO_adverb_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// argument
	if !_node(parser, _argumentNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _PO_adverb_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _PO_adverb_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "PO_adverb_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _PO_adverb_1}
	// PO_adverb_tone spaces? argument
	// PO_adverb_tone
	if !_fail(parser, _PO_adverb_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// argument
	if !_fail(parser, _argumentFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _PO_adverb_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_PO_adverb_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_adverb_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// PO_adverb_tone spaces? argument
	{
		var node0 string
		// PO_adverb_tone
		if p, n := _PO_adverb_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// argument
		if p, n := _argumentAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _PO_adverb_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _PO_adverb_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &PO adverb_syllable
	// &PO
	{
		pos2 := pos
		perr4 := perr
		// PO
		if !_accept(parser, _POAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// adverb_syllable
	if !_accept(parser, _adverb_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _PO_adverb_tone, start, pos, perr)
fail:
	return _memoize(parser, _PO_adverb_tone, start, -1, perr)
}

func _PO_adverb_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_PO_adverb_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_adverb_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "PO_adverb_tone"}
	// &PO adverb_syllable
	// &PO
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// PO
		if !_node(parser, _PONode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// adverb_syllable
	if !_node(parser, _adverb_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _PO_adverb_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _PO_adverb_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "PO_adverb_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _PO_adverb_tone}
	// &PO adverb_syllable
	// &PO
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// PO
		if !_fail(parser, _POFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&PO",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// adverb_syllable
	if !_fail(parser, _adverb_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _PO_adverb_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_PO_adverb_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_adverb_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &PO adverb_syllable
	{
		var node0 string
		// &PO
		{
			pos2 := pos
			// PO
			if p, n := _POAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// adverb_syllable
		if p, n := _adverb_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _quotation_adverbAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _quotation_adverb, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MO_adverb spaces? TEO
	// MO_adverb
	if !_accept(parser, _MO_adverbAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// TEO
	if !_accept(parser, _TEOAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _quotation_adverb, start, pos, perr)
fail:
	return _memoize(parser, _quotation_adverb, start, -1, perr)
}

func _quotation_adverbNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_quotation_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _quotation_adverb}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "quotation_adverb"}
	// MO_adverb spaces? TEO
	// MO_adverb
	if !_node(parser, _MO_adverbNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// TEO
	if !_node(parser, _TEONode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _quotation_adverbFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _quotation_adverb, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "quotation_adverb",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _quotation_adverb}
	// MO_adverb spaces? TEO
	// MO_adverb
	if !_fail(parser, _MO_adverbFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// TEO
	if !_fail(parser, _TEOFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _quotation_adverbAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_quotation_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _quotation_adverb}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MO_adverb spaces? TEO
	{
		var node0 string
		// MO_adverb
		if p, n := _MO_adverbAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// TEO
		if p, n := _TEOAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MO_adverbAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MO_adverb, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MO_adverb_tone spaces? discourse
	// MO_adverb_tone
	if !_accept(parser, _MO_adverb_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// discourse
	if !_accept(parser, _discourseAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _MO_adverb, start, pos, perr)
fail:
	return _memoize(parser, _MO_adverb, start, -1, perr)
}

func _MO_adverbNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MO_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_adverb}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MO_adverb"}
	// MO_adverb_tone spaces? discourse
	// MO_adverb_tone
	if !_node(parser, _MO_adverb_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// discourse
	if !_node(parser, _discourseNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MO_adverbFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MO_adverb, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MO_adverb",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MO_adverb}
	// MO_adverb_tone spaces? discourse
	// MO_adverb_tone
	if !_fail(parser, _MO_adverb_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// discourse
	if !_fail(parser, _discourseFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MO_adverbAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MO_adverb]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_adverb}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MO_adverb_tone spaces? discourse
	{
		var node0 string
		// MO_adverb_tone
		if p, n := _MO_adverb_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// discourse
		if p, n := _discourseAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MO_adverb_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MO_adverb_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &MO adverb_syllable
	// &MO
	{
		pos2 := pos
		perr4 := perr
		// MO
		if !_accept(parser, _MOAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// adverb_syllable
	if !_accept(parser, _adverb_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _MO_adverb_tone, start, pos, perr)
fail:
	return _memoize(parser, _MO_adverb_tone, start, -1, perr)
}

func _MO_adverb_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MO_adverb_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_adverb_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MO_adverb_tone"}
	// &MO adverb_syllable
	// &MO
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// MO
		if !_node(parser, _MONode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// adverb_syllable
	if !_node(parser, _adverb_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MO_adverb_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MO_adverb_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MO_adverb_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MO_adverb_tone}
	// &MO adverb_syllable
	// &MO
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// MO
		if !_fail(parser, _MOFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&MO",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// adverb_syllable
	if !_fail(parser, _adverb_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MO_adverb_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MO_adverb_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_adverb_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &MO adverb_syllable
	{
		var node0 string
		// &MO
		{
			pos2 := pos
			// MO
			if p, n := _MOAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// adverb_syllable
		if p, n := _adverb_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _prepositional_phraseAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _prepositional_phrase, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// coP_prepositional_phrase/prepositional_phrase_1
	{
		pos2 := pos
		// coP_prepositional_phrase
		if !_accept(parser, _coP_prepositional_phraseAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// prepositional_phrase_1
		if !_accept(parser, _prepositional_phrase_1Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _prepositional_phrase, start, pos, perr)
fail:
	return _memoize(parser, _prepositional_phrase, start, -1, perr)
}

func _prepositional_phraseNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_prepositional_phrase]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _prepositional_phrase}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "prepositional_phrase"}
	// coP_prepositional_phrase/prepositional_phrase_1
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// coP_prepositional_phrase
		if !_node(parser, _coP_prepositional_phraseNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// prepositional_phrase_1
		if !_node(parser, _prepositional_phrase_1Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _prepositional_phraseFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _prepositional_phrase, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "prepositional_phrase",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _prepositional_phrase}
	// coP_prepositional_phrase/prepositional_phrase_1
	{
		pos2 := pos
		// coP_prepositional_phrase
		if !_fail(parser, _coP_prepositional_phraseFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// prepositional_phrase_1
		if !_fail(parser, _prepositional_phrase_1Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _prepositional_phraseAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_prepositional_phrase]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _prepositional_phrase}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// coP_prepositional_phrase/prepositional_phrase_1
	{
		pos2 := pos
		// coP_prepositional_phrase
		if p, n := _coP_prepositional_phraseAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// prepositional_phrase_1
		if p, n := _prepositional_phrase_1Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _prepositional_phrase_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _prepositional_phrase_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_coP_prepositional_phrase/prepositional_phrase_2
	{
		pos2 := pos
		// forethought_coP_prepositional_phrase
		if !_accept(parser, _forethought_coP_prepositional_phraseAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// prepositional_phrase_2
		if !_accept(parser, _prepositional_phrase_2Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _prepositional_phrase_1, start, pos, perr)
fail:
	return _memoize(parser, _prepositional_phrase_1, start, -1, perr)
}

func _prepositional_phrase_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_prepositional_phrase_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _prepositional_phrase_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "prepositional_phrase_1"}
	// forethought_coP_prepositional_phrase/prepositional_phrase_2
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// forethought_coP_prepositional_phrase
		if !_node(parser, _forethought_coP_prepositional_phraseNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// prepositional_phrase_2
		if !_node(parser, _prepositional_phrase_2Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _prepositional_phrase_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _prepositional_phrase_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "prepositional_phrase_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _prepositional_phrase_1}
	// forethought_coP_prepositional_phrase/prepositional_phrase_2
	{
		pos2 := pos
		// forethought_coP_prepositional_phrase
		if !_fail(parser, _forethought_coP_prepositional_phraseFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// prepositional_phrase_2
		if !_fail(parser, _prepositional_phrase_2Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _prepositional_phrase_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_prepositional_phrase_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _prepositional_phrase_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_coP_prepositional_phrase/prepositional_phrase_2
	{
		pos2 := pos
		// forethought_coP_prepositional_phrase
		if p, n := _forethought_coP_prepositional_phraseAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// prepositional_phrase_2
		if p, n := _prepositional_phrase_2Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _prepositional_phrase_2Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _prepositional_phrase_2, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// preposition spaces? argument
	// preposition
	if !_accept(parser, _prepositionAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// argument
	if !_accept(parser, _argumentAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _prepositional_phrase_2, start, pos, perr)
fail:
	return _memoize(parser, _prepositional_phrase_2, start, -1, perr)
}

func _prepositional_phrase_2Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_prepositional_phrase_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _prepositional_phrase_2}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "prepositional_phrase_2"}
	// preposition spaces? argument
	// preposition
	if !_node(parser, _prepositionNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// argument
	if !_node(parser, _argumentNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _prepositional_phrase_2Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _prepositional_phrase_2, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "prepositional_phrase_2",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _prepositional_phrase_2}
	// preposition spaces? argument
	// preposition
	if !_fail(parser, _prepositionFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// argument
	if !_fail(parser, _argumentFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _prepositional_phrase_2Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_prepositional_phrase_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _prepositional_phrase_2}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// preposition spaces? argument
	{
		var node0 string
		// preposition
		if p, n := _prepositionAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// argument
		if p, n := _argumentAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _coP_prepositional_phraseAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _coP_prepositional_phrase, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// prepositional_phrase_1 spaces? co_bar_prepositional_phrase
	// prepositional_phrase_1
	if !_accept(parser, _prepositional_phrase_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_prepositional_phrase
	if !_accept(parser, _co_bar_prepositional_phraseAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _coP_prepositional_phrase, start, pos, perr)
fail:
	return _memoize(parser, _coP_prepositional_phrase, start, -1, perr)
}

func _coP_prepositional_phraseNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_coP_prepositional_phrase]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_prepositional_phrase}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "coP_prepositional_phrase"}
	// prepositional_phrase_1 spaces? co_bar_prepositional_phrase
	// prepositional_phrase_1
	if !_node(parser, _prepositional_phrase_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// co_bar_prepositional_phrase
	if !_node(parser, _co_bar_prepositional_phraseNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _coP_prepositional_phraseFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _coP_prepositional_phrase, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "coP_prepositional_phrase",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _coP_prepositional_phrase}
	// prepositional_phrase_1 spaces? co_bar_prepositional_phrase
	// prepositional_phrase_1
	if !_fail(parser, _prepositional_phrase_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_prepositional_phrase
	if !_fail(parser, _co_bar_prepositional_phraseFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _coP_prepositional_phraseAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_coP_prepositional_phrase]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_prepositional_phrase}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// prepositional_phrase_1 spaces? co_bar_prepositional_phrase
	{
		var node0 string
		// prepositional_phrase_1
		if p, n := _prepositional_phrase_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// co_bar_prepositional_phrase
		if p, n := _co_bar_prepositional_phraseAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _co_bar_prepositional_phraseAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _co_bar_prepositional_phrase, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// connective spaces? prepositional_phrase_1
	// connective
	if !_accept(parser, _connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// prepositional_phrase_1
	if !_accept(parser, _prepositional_phrase_1Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _co_bar_prepositional_phrase, start, pos, perr)
fail:
	return _memoize(parser, _co_bar_prepositional_phrase, start, -1, perr)
}

func _co_bar_prepositional_phraseNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_co_bar_prepositional_phrase]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _co_bar_prepositional_phrase}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "co_bar_prepositional_phrase"}
	// connective spaces? prepositional_phrase_1
	// connective
	if !_node(parser, _connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// prepositional_phrase_1
	if !_node(parser, _prepositional_phrase_1Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _co_bar_prepositional_phraseFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _co_bar_prepositional_phrase, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "co_bar_prepositional_phrase",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _co_bar_prepositional_phrase}
	// connective spaces? prepositional_phrase_1
	// connective
	if !_fail(parser, _connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// prepositional_phrase_1
	if !_fail(parser, _prepositional_phrase_1Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _co_bar_prepositional_phraseAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_co_bar_prepositional_phrase]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _co_bar_prepositional_phrase}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// connective spaces? prepositional_phrase_1
	{
		var node0 string
		// connective
		if p, n := _connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// prepositional_phrase_1
		if p, n := _prepositional_phrase_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_prepositional_phraseAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_prepositional_phrase, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_connective spaces? forethought_coP_prepositional_phrase_1
	// forethought_connective
	if !_accept(parser, _forethought_connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_prepositional_phrase_1
	if !_accept(parser, _forethought_coP_prepositional_phrase_1Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_prepositional_phrase, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_prepositional_phrase, start, -1, perr)
}

func _forethought_coP_prepositional_phraseNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_prepositional_phrase]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_prepositional_phrase}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_prepositional_phrase"}
	// forethought_connective spaces? forethought_coP_prepositional_phrase_1
	// forethought_connective
	if !_node(parser, _forethought_connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_coP_prepositional_phrase_1
	if !_node(parser, _forethought_coP_prepositional_phrase_1Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_prepositional_phraseFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_prepositional_phrase, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_prepositional_phrase",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_prepositional_phrase}
	// forethought_connective spaces? forethought_coP_prepositional_phrase_1
	// forethought_connective
	if !_fail(parser, _forethought_connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_prepositional_phrase_1
	if !_fail(parser, _forethought_coP_prepositional_phrase_1Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_prepositional_phraseAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_prepositional_phrase]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_prepositional_phrase}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_connective spaces? forethought_coP_prepositional_phrase_1
	{
		var node0 string
		// forethought_connective
		if p, n := _forethought_connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_coP_prepositional_phrase_1
		if p, n := _forethought_coP_prepositional_phrase_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_prepositional_phrase_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_prepositional_phrase_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// prepositional_phrase spaces? forethought_co_bar_prepositional_phrase
	// prepositional_phrase
	if !_accept(parser, _prepositional_phraseAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_prepositional_phrase
	if !_accept(parser, _forethought_co_bar_prepositional_phraseAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_prepositional_phrase_1, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_prepositional_phrase_1, start, -1, perr)
}

func _forethought_coP_prepositional_phrase_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_prepositional_phrase_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_prepositional_phrase_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_prepositional_phrase_1"}
	// prepositional_phrase spaces? forethought_co_bar_prepositional_phrase
	// prepositional_phrase
	if !_node(parser, _prepositional_phraseNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_co_bar_prepositional_phrase
	if !_node(parser, _forethought_co_bar_prepositional_phraseNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_prepositional_phrase_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_prepositional_phrase_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_prepositional_phrase_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_prepositional_phrase_1}
	// prepositional_phrase spaces? forethought_co_bar_prepositional_phrase
	// prepositional_phrase
	if !_fail(parser, _prepositional_phraseFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_prepositional_phrase
	if !_fail(parser, _forethought_co_bar_prepositional_phraseFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_prepositional_phrase_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_prepositional_phrase_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_prepositional_phrase_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// prepositional_phrase spaces? forethought_co_bar_prepositional_phrase
	{
		var node0 string
		// prepositional_phrase
		if p, n := _prepositional_phraseAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_co_bar_prepositional_phrase
		if p, n := _forethought_co_bar_prepositional_phraseAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_co_bar_prepositional_phraseAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_co_bar_prepositional_phrase, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// gik spaces? prepositional_phrase
	// gik
	if !_accept(parser, _gikAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// prepositional_phrase
	if !_accept(parser, _prepositional_phraseAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_co_bar_prepositional_phrase, start, pos, perr)
fail:
	return _memoize(parser, _forethought_co_bar_prepositional_phrase, start, -1, perr)
}

func _forethought_co_bar_prepositional_phraseNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_co_bar_prepositional_phrase]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_prepositional_phrase}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_co_bar_prepositional_phrase"}
	// gik spaces? prepositional_phrase
	// gik
	if !_node(parser, _gikNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// prepositional_phrase
	if !_node(parser, _prepositional_phraseNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_co_bar_prepositional_phraseFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_co_bar_prepositional_phrase, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_co_bar_prepositional_phrase",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_co_bar_prepositional_phrase}
	// gik spaces? prepositional_phrase
	// gik
	if !_fail(parser, _gikFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// prepositional_phrase
	if !_fail(parser, _prepositional_phraseFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_co_bar_prepositional_phraseAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_co_bar_prepositional_phrase]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_prepositional_phrase}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// gik spaces? prepositional_phrase
	{
		var node0 string
		// gik
		if p, n := _gikAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// prepositional_phrase
		if p, n := _prepositional_phraseAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _prepositionAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _preposition, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// coP_preposition/preposition_1
	{
		pos2 := pos
		// coP_preposition
		if !_accept(parser, _coP_prepositionAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// preposition_1
		if !_accept(parser, _preposition_1Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _preposition, start, pos, perr)
fail:
	return _memoize(parser, _preposition, start, -1, perr)
}

func _prepositionNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _preposition}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "preposition"}
	// coP_preposition/preposition_1
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// coP_preposition
		if !_node(parser, _coP_prepositionNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// preposition_1
		if !_node(parser, _preposition_1Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _prepositionFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _preposition, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "preposition",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _preposition}
	// coP_preposition/preposition_1
	{
		pos2 := pos
		// coP_preposition
		if !_fail(parser, _coP_prepositionFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// preposition_1
		if !_fail(parser, _preposition_1Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _prepositionAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _preposition}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// coP_preposition/preposition_1
	{
		pos2 := pos
		// coP_preposition
		if p, n := _coP_prepositionAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// preposition_1
		if p, n := _preposition_1Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _preposition_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _preposition_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_coP_preposition/preposition_2
	{
		pos2 := pos
		// forethought_coP_preposition
		if !_accept(parser, _forethought_coP_prepositionAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// preposition_2
		if !_accept(parser, _preposition_2Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _preposition_1, start, pos, perr)
fail:
	return _memoize(parser, _preposition_1, start, -1, perr)
}

func _preposition_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_preposition_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _preposition_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "preposition_1"}
	// forethought_coP_preposition/preposition_2
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// forethought_coP_preposition
		if !_node(parser, _forethought_coP_prepositionNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// preposition_2
		if !_node(parser, _preposition_2Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _preposition_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _preposition_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "preposition_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _preposition_1}
	// forethought_coP_preposition/preposition_2
	{
		pos2 := pos
		// forethought_coP_preposition
		if !_fail(parser, _forethought_coP_prepositionFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// preposition_2
		if !_fail(parser, _preposition_2Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _preposition_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_preposition_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _preposition_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_coP_preposition/preposition_2
	{
		pos2 := pos
		// forethought_coP_preposition
		if p, n := _forethought_coP_prepositionAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// preposition_2
		if p, n := _preposition_2Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _preposition_2Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _preposition_2, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// serial_preposition/preposition_3
	{
		pos2 := pos
		// serial_preposition
		if !_accept(parser, _serial_prepositionAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// preposition_3
		if !_accept(parser, _preposition_3Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _preposition_2, start, pos, perr)
fail:
	return _memoize(parser, _preposition_2, start, -1, perr)
}

func _preposition_2Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_preposition_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _preposition_2}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "preposition_2"}
	// serial_preposition/preposition_3
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// serial_preposition
		if !_node(parser, _serial_prepositionNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// preposition_3
		if !_node(parser, _preposition_3Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _preposition_2Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _preposition_2, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "preposition_2",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _preposition_2}
	// serial_preposition/preposition_3
	{
		pos2 := pos
		// serial_preposition
		if !_fail(parser, _serial_prepositionFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// preposition_3
		if !_fail(parser, _preposition_3Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _preposition_2Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_preposition_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _preposition_2}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// serial_preposition/preposition_3
	{
		pos2 := pos
		// serial_preposition
		if p, n := _serial_prepositionAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// preposition_3
		if p, n := _preposition_3Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _preposition_3Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _preposition_3, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// coP_pred_preposition/forethought_coP_pred_preposition/LU_preposition/MI_preposition/PO_preposition/quotation_preposition/preposition_4
	{
		pos2 := pos
		// coP_pred_preposition
		if !_accept(parser, _coP_pred_prepositionAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// forethought_coP_pred_preposition
		if !_accept(parser, _forethought_coP_pred_prepositionAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// LU_preposition
		if !_accept(parser, _LU_prepositionAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// MI_preposition
		if !_accept(parser, _MI_prepositionAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// PO_preposition
		if !_accept(parser, _PO_prepositionAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// quotation_preposition
		if !_accept(parser, _quotation_prepositionAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// preposition_4
		if !_accept(parser, _preposition_4Accepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _preposition_3, start, pos, perr)
fail:
	return _memoize(parser, _preposition_3, start, -1, perr)
}

func _preposition_3Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_preposition_3]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _preposition_3}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "preposition_3"}
	// coP_pred_preposition/forethought_coP_pred_preposition/LU_preposition/MI_preposition/PO_preposition/quotation_preposition/preposition_4
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// coP_pred_preposition
		if !_node(parser, _coP_pred_prepositionNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// forethought_coP_pred_preposition
		if !_node(parser, _forethought_coP_pred_prepositionNode, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// LU_preposition
		if !_node(parser, _LU_prepositionNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// MI_preposition
		if !_node(parser, _MI_prepositionNode, node, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// PO_preposition
		if !_node(parser, _PO_prepositionNode, node, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// quotation_preposition
		if !_node(parser, _quotation_prepositionNode, node, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// preposition_4
		if !_node(parser, _preposition_4Node, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _preposition_3Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _preposition_3, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "preposition_3",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _preposition_3}
	// coP_pred_preposition/forethought_coP_pred_preposition/LU_preposition/MI_preposition/PO_preposition/quotation_preposition/preposition_4
	{
		pos2 := pos
		// coP_pred_preposition
		if !_fail(parser, _coP_pred_prepositionFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// forethought_coP_pred_preposition
		if !_fail(parser, _forethought_coP_pred_prepositionFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// LU_preposition
		if !_fail(parser, _LU_prepositionFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// MI_preposition
		if !_fail(parser, _MI_prepositionFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// PO_preposition
		if !_fail(parser, _PO_prepositionFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// quotation_preposition
		if !_fail(parser, _quotation_prepositionFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// preposition_4
		if !_fail(parser, _preposition_4Fail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _preposition_3Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_preposition_3]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _preposition_3}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// coP_pred_preposition/forethought_coP_pred_preposition/LU_preposition/MI_preposition/PO_preposition/quotation_preposition/preposition_4
	{
		pos2 := pos
		// coP_pred_preposition
		if p, n := _coP_pred_prepositionAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// forethought_coP_pred_preposition
		if p, n := _forethought_coP_pred_prepositionAction(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		// LU_preposition
		if p, n := _LU_prepositionAction(parser, pos); n == nil {
			goto fail5
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail5:
		pos = pos2
		// MI_preposition
		if p, n := _MI_prepositionAction(parser, pos); n == nil {
			goto fail6
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail6:
		pos = pos2
		// PO_preposition
		if p, n := _PO_prepositionAction(parser, pos); n == nil {
			goto fail7
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail7:
		pos = pos2
		// quotation_preposition
		if p, n := _quotation_prepositionAction(parser, pos); n == nil {
			goto fail8
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail8:
		pos = pos2
		// preposition_4
		if p, n := _preposition_4Action(parser, pos); n == nil {
			goto fail9
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _preposition_4Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _preposition_4, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// preposition_syllable compound_syllable+/!function_word preposition_syllable
	{
		pos2 := pos
		// preposition_syllable compound_syllable+
		// preposition_syllable
		if !_accept(parser, _preposition_syllableAccepts, &pos, &perr) {
			goto fail3
		}
		// compound_syllable+
		// compound_syllable
		if !_accept(parser, _compound_syllableAccepts, &pos, &perr) {
			goto fail3
		}
		for {
			pos6 := pos
			// compound_syllable
			if !_accept(parser, _compound_syllableAccepts, &pos, &perr) {
				goto fail8
			}
			continue
		fail8:
			pos = pos6
			break
		}
		goto ok0
	fail3:
		pos = pos2
		// !function_word preposition_syllable
		// !function_word
		{
			pos12 := pos
			perr14 := perr
			// function_word
			if !_accept(parser, _function_wordAccepts, &pos, &perr) {
				goto ok11
			}
			pos = pos12
			perr = _max(perr14, pos)
			goto fail9
		ok11:
			pos = pos12
			perr = perr14
		}
		// preposition_syllable
		if !_accept(parser, _preposition_syllableAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _preposition_4, start, pos, perr)
fail:
	return _memoize(parser, _preposition_4, start, -1, perr)
}

func _preposition_4Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_preposition_4]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _preposition_4}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "preposition_4"}
	// preposition_syllable compound_syllable+/!function_word preposition_syllable
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// preposition_syllable compound_syllable+
		// preposition_syllable
		if !_node(parser, _preposition_syllableNode, node, &pos) {
			goto fail3
		}
		// compound_syllable+
		// compound_syllable
		if !_node(parser, _compound_syllableNode, node, &pos) {
			goto fail3
		}
		for {
			nkids5 := len(node.Kids)
			pos6 := pos
			// compound_syllable
			if !_node(parser, _compound_syllableNode, node, &pos) {
				goto fail8
			}
			continue
		fail8:
			node.Kids = node.Kids[:nkids5]
			pos = pos6
			break
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// !function_word preposition_syllable
		// !function_word
		{
			pos12 := pos
			nkids13 := len(node.Kids)
			// function_word
			if !_node(parser, _function_wordNode, node, &pos) {
				goto ok11
			}
			pos = pos12
			node.Kids = node.Kids[:nkids13]
			goto fail9
		ok11:
			pos = pos12
			node.Kids = node.Kids[:nkids13]
		}
		// preposition_syllable
		if !_node(parser, _preposition_syllableNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _preposition_4Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _preposition_4, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "preposition_4",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _preposition_4}
	// preposition_syllable compound_syllable+/!function_word preposition_syllable
	{
		pos2 := pos
		// preposition_syllable compound_syllable+
		// preposition_syllable
		if !_fail(parser, _preposition_syllableFail, errPos, failure, &pos) {
			goto fail3
		}
		// compound_syllable+
		// compound_syllable
		if !_fail(parser, _compound_syllableFail, errPos, failure, &pos) {
			goto fail3
		}
		for {
			pos6 := pos
			// compound_syllable
			if !_fail(parser, _compound_syllableFail, errPos, failure, &pos) {
				goto fail8
			}
			continue
		fail8:
			pos = pos6
			break
		}
		goto ok0
	fail3:
		pos = pos2
		// !function_word preposition_syllable
		// !function_word
		{
			pos12 := pos
			nkids13 := len(failure.Kids)
			// function_word
			if !_fail(parser, _function_wordFail, errPos, failure, &pos) {
				goto ok11
			}
			pos = pos12
			failure.Kids = failure.Kids[:nkids13]
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "!function_word",
				})
			}
			goto fail9
		ok11:
			pos = pos12
			failure.Kids = failure.Kids[:nkids13]
		}
		// preposition_syllable
		if !_fail(parser, _preposition_syllableFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _preposition_4Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_preposition_4]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _preposition_4}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// preposition_syllable compound_syllable+/!function_word preposition_syllable
	{
		pos2 := pos
		// preposition_syllable compound_syllable+
		{
			var node4 string
			// preposition_syllable
			if p, n := _preposition_syllableAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
			// compound_syllable+
			{
				var node7 string
				// compound_syllable
				if p, n := _compound_syllableAction(parser, pos); n == nil {
					goto fail3
				} else {
					node7 = *n
					pos = p
				}
				node4 += node7
			}
			for {
				pos6 := pos
				var node7 string
				// compound_syllable
				if p, n := _compound_syllableAction(parser, pos); n == nil {
					goto fail8
				} else {
					node7 = *n
					pos = p
				}
				node4 += node7
				continue
			fail8:
				pos = pos6
				break
			}
			node += node4
		}
		goto ok0
	fail3:
		pos = pos2
		// !function_word preposition_syllable
		{
			var node10 string
			// !function_word
			{
				pos12 := pos
				// function_word
				if p, n := _function_wordAction(parser, pos); n == nil {
					goto ok11
				} else {
					pos = p
				}
				pos = pos12
				goto fail9
			ok11:
				pos = pos12
				node = ""
			}
			node += node10
			// preposition_syllable
			if p, n := _preposition_syllableAction(parser, pos); n == nil {
				goto fail9
			} else {
				node10 = *n
				pos = p
			}
			node += node10
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _coP_prepositionAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _coP_preposition, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// preposition_1 spaces? co_bar_preposition
	// preposition_1
	if !_accept(parser, _preposition_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_preposition
	if !_accept(parser, _co_bar_prepositionAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _coP_preposition, start, pos, perr)
fail:
	return _memoize(parser, _coP_preposition, start, -1, perr)
}

func _coP_prepositionNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_coP_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_preposition}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "coP_preposition"}
	// preposition_1 spaces? co_bar_preposition
	// preposition_1
	if !_node(parser, _preposition_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// co_bar_preposition
	if !_node(parser, _co_bar_prepositionNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _coP_prepositionFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _coP_preposition, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "coP_preposition",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _coP_preposition}
	// preposition_1 spaces? co_bar_preposition
	// preposition_1
	if !_fail(parser, _preposition_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_preposition
	if !_fail(parser, _co_bar_prepositionFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _coP_prepositionAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_coP_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_preposition}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// preposition_1 spaces? co_bar_preposition
	{
		var node0 string
		// preposition_1
		if p, n := _preposition_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// co_bar_preposition
		if p, n := _co_bar_prepositionAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _co_bar_prepositionAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _co_bar_preposition, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// connective spaces? preposition
	// connective
	if !_accept(parser, _connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// preposition
	if !_accept(parser, _prepositionAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _co_bar_preposition, start, pos, perr)
fail:
	return _memoize(parser, _co_bar_preposition, start, -1, perr)
}

func _co_bar_prepositionNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_co_bar_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _co_bar_preposition}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "co_bar_preposition"}
	// connective spaces? preposition
	// connective
	if !_node(parser, _connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// preposition
	if !_node(parser, _prepositionNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _co_bar_prepositionFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _co_bar_preposition, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "co_bar_preposition",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _co_bar_preposition}
	// connective spaces? preposition
	// connective
	if !_fail(parser, _connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// preposition
	if !_fail(parser, _prepositionFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _co_bar_prepositionAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_co_bar_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _co_bar_preposition}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// connective spaces? preposition
	{
		var node0 string
		// connective
		if p, n := _connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// preposition
		if p, n := _prepositionAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_prepositionAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_preposition, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_connective spaces? forethought_coP_preposition_1
	// forethought_connective
	if !_accept(parser, _forethought_connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_preposition_1
	if !_accept(parser, _forethought_coP_preposition_1Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_preposition, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_preposition, start, -1, perr)
}

func _forethought_coP_prepositionNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_preposition}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_preposition"}
	// forethought_connective spaces? forethought_coP_preposition_1
	// forethought_connective
	if !_node(parser, _forethought_connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_coP_preposition_1
	if !_node(parser, _forethought_coP_preposition_1Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_prepositionFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_preposition, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_preposition",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_preposition}
	// forethought_connective spaces? forethought_coP_preposition_1
	// forethought_connective
	if !_fail(parser, _forethought_connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_preposition_1
	if !_fail(parser, _forethought_coP_preposition_1Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_prepositionAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_preposition}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_connective spaces? forethought_coP_preposition_1
	{
		var node0 string
		// forethought_connective
		if p, n := _forethought_connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_coP_preposition_1
		if p, n := _forethought_coP_preposition_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_preposition_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_preposition_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// preposition spaces? forethought_co_bar_preposition
	// preposition
	if !_accept(parser, _prepositionAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_preposition
	if !_accept(parser, _forethought_co_bar_prepositionAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_preposition_1, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_preposition_1, start, -1, perr)
}

func _forethought_coP_preposition_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_preposition_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_preposition_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_preposition_1"}
	// preposition spaces? forethought_co_bar_preposition
	// preposition
	if !_node(parser, _prepositionNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_co_bar_preposition
	if !_node(parser, _forethought_co_bar_prepositionNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_preposition_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_preposition_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_preposition_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_preposition_1}
	// preposition spaces? forethought_co_bar_preposition
	// preposition
	if !_fail(parser, _prepositionFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_preposition
	if !_fail(parser, _forethought_co_bar_prepositionFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_preposition_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_preposition_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_preposition_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// preposition spaces? forethought_co_bar_preposition
	{
		var node0 string
		// preposition
		if p, n := _prepositionAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_co_bar_preposition
		if p, n := _forethought_co_bar_prepositionAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_co_bar_prepositionAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_co_bar_preposition, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// gik spaces? preposition
	// gik
	if !_accept(parser, _gikAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// preposition
	if !_accept(parser, _prepositionAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_co_bar_preposition, start, pos, perr)
fail:
	return _memoize(parser, _forethought_co_bar_preposition, start, -1, perr)
}

func _forethought_co_bar_prepositionNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_co_bar_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_preposition}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_co_bar_preposition"}
	// gik spaces? preposition
	// gik
	if !_node(parser, _gikNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// preposition
	if !_node(parser, _prepositionNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_co_bar_prepositionFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_co_bar_preposition, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_co_bar_preposition",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_co_bar_preposition}
	// gik spaces? preposition
	// gik
	if !_fail(parser, _gikFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// preposition
	if !_fail(parser, _prepositionFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_co_bar_prepositionAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_co_bar_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_co_bar_preposition}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// gik spaces? preposition
	{
		var node0 string
		// gik
		if p, n := _gikAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// preposition
		if p, n := _prepositionAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _serial_prepositionAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _serial_preposition, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// preposition_3 spaces? serial_predicate
	// preposition_3
	if !_accept(parser, _preposition_3Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// serial_predicate
	if !_accept(parser, _serial_predicateAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _serial_preposition, start, pos, perr)
fail:
	return _memoize(parser, _serial_preposition, start, -1, perr)
}

func _serial_prepositionNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_serial_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _serial_preposition}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "serial_preposition"}
	// preposition_3 spaces? serial_predicate
	// preposition_3
	if !_node(parser, _preposition_3Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// serial_predicate
	if !_node(parser, _serial_predicateNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _serial_prepositionFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _serial_preposition, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "serial_preposition",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _serial_preposition}
	// preposition_3 spaces? serial_predicate
	// preposition_3
	if !_fail(parser, _preposition_3Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// serial_predicate
	if !_fail(parser, _serial_predicateFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _serial_prepositionAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_serial_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _serial_preposition}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// preposition_3 spaces? serial_predicate
	{
		var node0 string
		// preposition_3
		if p, n := _preposition_3Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// serial_predicate
		if p, n := _serial_predicateAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _coP_pred_prepositionAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _coP_pred_preposition, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// preposition_4 spaces? co_bar_pred
	// preposition_4
	if !_accept(parser, _preposition_4Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_pred
	if !_accept(parser, _co_bar_predAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _coP_pred_preposition, start, pos, perr)
fail:
	return _memoize(parser, _coP_pred_preposition, start, -1, perr)
}

func _coP_pred_prepositionNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_coP_pred_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_pred_preposition}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "coP_pred_preposition"}
	// preposition_4 spaces? co_bar_pred
	// preposition_4
	if !_node(parser, _preposition_4Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// co_bar_pred
	if !_node(parser, _co_bar_predNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _coP_pred_prepositionFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _coP_pred_preposition, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "coP_pred_preposition",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _coP_pred_preposition}
	// preposition_4 spaces? co_bar_pred
	// preposition_4
	if !_fail(parser, _preposition_4Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_pred
	if !_fail(parser, _co_bar_predFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _coP_pred_prepositionAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_coP_pred_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_pred_preposition}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// preposition_4 spaces? co_bar_pred
	{
		var node0 string
		// preposition_4
		if p, n := _preposition_4Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// co_bar_pred
		if p, n := _co_bar_predAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_pred_prepositionAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_pred_preposition, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_connective spaces? forethought_coP_pred_preposition_1
	// forethought_connective
	if !_accept(parser, _forethought_connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_pred_preposition_1
	if !_accept(parser, _forethought_coP_pred_preposition_1Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_pred_preposition, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_pred_preposition, start, -1, perr)
}

func _forethought_coP_pred_prepositionNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_pred_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_preposition}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_pred_preposition"}
	// forethought_connective spaces? forethought_coP_pred_preposition_1
	// forethought_connective
	if !_node(parser, _forethought_connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_coP_pred_preposition_1
	if !_node(parser, _forethought_coP_pred_preposition_1Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_pred_prepositionFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_pred_preposition, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_pred_preposition",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_pred_preposition}
	// forethought_connective spaces? forethought_coP_pred_preposition_1
	// forethought_connective
	if !_fail(parser, _forethought_connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_pred_preposition_1
	if !_fail(parser, _forethought_coP_pred_preposition_1Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_pred_prepositionAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_pred_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_preposition}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_connective spaces? forethought_coP_pred_preposition_1
	{
		var node0 string
		// forethought_connective
		if p, n := _forethought_connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_coP_pred_preposition_1
		if p, n := _forethought_coP_pred_preposition_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_pred_preposition_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_pred_preposition_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// preposition spaces? forethought_co_bar_pred
	// preposition
	if !_accept(parser, _prepositionAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_pred
	if !_accept(parser, _forethought_co_bar_predAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_pred_preposition_1, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_pred_preposition_1, start, -1, perr)
}

func _forethought_coP_pred_preposition_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_pred_preposition_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_preposition_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_pred_preposition_1"}
	// preposition spaces? forethought_co_bar_pred
	// preposition
	if !_node(parser, _prepositionNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_co_bar_pred
	if !_node(parser, _forethought_co_bar_predNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_pred_preposition_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_pred_preposition_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_pred_preposition_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_pred_preposition_1}
	// preposition spaces? forethought_co_bar_pred
	// preposition
	if !_fail(parser, _prepositionFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_pred
	if !_fail(parser, _forethought_co_bar_predFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_pred_preposition_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_pred_preposition_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_preposition_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// preposition spaces? forethought_co_bar_pred
	{
		var node0 string
		// preposition
		if p, n := _prepositionAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_co_bar_pred
		if p, n := _forethought_co_bar_predAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _LU_prepositionAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _LU_preposition, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// LU_preposition_tone spaces? statement
	// LU_preposition_tone
	if !_accept(parser, _LU_preposition_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// statement
	if !_accept(parser, _statementAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _LU_preposition, start, pos, perr)
fail:
	return _memoize(parser, _LU_preposition, start, -1, perr)
}

func _LU_prepositionNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_LU_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_preposition}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "LU_preposition"}
	// LU_preposition_tone spaces? statement
	// LU_preposition_tone
	if !_node(parser, _LU_preposition_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// statement
	if !_node(parser, _statementNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _LU_prepositionFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _LU_preposition, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "LU_preposition",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _LU_preposition}
	// LU_preposition_tone spaces? statement
	// LU_preposition_tone
	if !_fail(parser, _LU_preposition_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// statement
	if !_fail(parser, _statementFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _LU_prepositionAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_LU_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_preposition}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// LU_preposition_tone spaces? statement
	{
		var node0 string
		// LU_preposition_tone
		if p, n := _LU_preposition_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// statement
		if p, n := _statementAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _LU_preposition_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _LU_preposition_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &LU preposition_syllable
	// &LU
	{
		pos2 := pos
		perr4 := perr
		// LU
		if !_accept(parser, _LUAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// preposition_syllable
	if !_accept(parser, _preposition_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _LU_preposition_tone, start, pos, perr)
fail:
	return _memoize(parser, _LU_preposition_tone, start, -1, perr)
}

func _LU_preposition_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_LU_preposition_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_preposition_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "LU_preposition_tone"}
	// &LU preposition_syllable
	// &LU
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// LU
		if !_node(parser, _LUNode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// preposition_syllable
	if !_node(parser, _preposition_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _LU_preposition_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _LU_preposition_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "LU_preposition_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _LU_preposition_tone}
	// &LU preposition_syllable
	// &LU
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// LU
		if !_fail(parser, _LUFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&LU",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// preposition_syllable
	if !_fail(parser, _preposition_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _LU_preposition_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_LU_preposition_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_preposition_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &LU preposition_syllable
	{
		var node0 string
		// &LU
		{
			pos2 := pos
			// LU
			if p, n := _LUAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// preposition_syllable
		if p, n := _preposition_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MI_prepositionAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MI_preposition, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MI_preposition_1 spaces? GA?
	// MI_preposition_1
	if !_accept(parser, _MI_preposition_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_accept(parser, _GAAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	return _memoize(parser, _MI_preposition, start, pos, perr)
fail:
	return _memoize(parser, _MI_preposition, start, -1, perr)
}

func _MI_prepositionNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MI_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_preposition}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MI_preposition"}
	// MI_preposition_1 spaces? GA?
	// MI_preposition_1
	if !_node(parser, _MI_preposition_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// GA?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// GA
		if !_node(parser, _GANode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MI_prepositionFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MI_preposition, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MI_preposition",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MI_preposition}
	// MI_preposition_1 spaces? GA?
	// MI_preposition_1
	if !_fail(parser, _MI_preposition_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_fail(parser, _GAFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MI_prepositionAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MI_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_preposition}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MI_preposition_1 spaces? GA?
	{
		var node0 string
		// MI_preposition_1
		if p, n := _MI_preposition_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// GA?
		{
			pos6 := pos
			// GA
			if p, n := _GAAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MI_preposition_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MI_preposition_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MI_preposition_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	// MI_preposition_tone
	if !_accept(parser, _MI_preposition_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// (predicate/argument/adverb/prepositional_phrase)
	// predicate/argument/adverb/prepositional_phrase
	{
		pos7 := pos
		// predicate
		if !_accept(parser, _predicateAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok5
	fail8:
		pos = pos7
		// argument
		if !_accept(parser, _argumentAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok5
	fail9:
		pos = pos7
		// adverb
		if !_accept(parser, _adverbAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok5
	fail10:
		pos = pos7
		// prepositional_phrase
		if !_accept(parser, _prepositional_phraseAccepts, &pos, &perr) {
			goto fail11
		}
		goto ok5
	fail11:
		pos = pos7
		goto fail
	ok5:
	}
	return _memoize(parser, _MI_preposition_1, start, pos, perr)
fail:
	return _memoize(parser, _MI_preposition_1, start, -1, perr)
}

func _MI_preposition_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MI_preposition_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_preposition_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MI_preposition_1"}
	// MI_preposition_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	// MI_preposition_tone
	if !_node(parser, _MI_preposition_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// (predicate/argument/adverb/prepositional_phrase)
	{
		nkids5 := len(node.Kids)
		pos06 := pos
		// predicate/argument/adverb/prepositional_phrase
		{
			pos9 := pos
			nkids8 := len(node.Kids)
			// predicate
			if !_node(parser, _predicateNode, node, &pos) {
				goto fail10
			}
			goto ok7
		fail10:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// argument
			if !_node(parser, _argumentNode, node, &pos) {
				goto fail11
			}
			goto ok7
		fail11:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// adverb
			if !_node(parser, _adverbNode, node, &pos) {
				goto fail12
			}
			goto ok7
		fail12:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// prepositional_phrase
			if !_node(parser, _prepositional_phraseNode, node, &pos) {
				goto fail13
			}
			goto ok7
		fail13:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			goto fail
		ok7:
		}
		sub := _sub(parser, pos06, pos, node.Kids[nkids5:])
		node.Kids = append(node.Kids[:nkids5], sub)
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MI_preposition_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MI_preposition_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MI_preposition_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MI_preposition_1}
	// MI_preposition_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	// MI_preposition_tone
	if !_fail(parser, _MI_preposition_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// (predicate/argument/adverb/prepositional_phrase)
	// predicate/argument/adverb/prepositional_phrase
	{
		pos7 := pos
		// predicate
		if !_fail(parser, _predicateFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok5
	fail8:
		pos = pos7
		// argument
		if !_fail(parser, _argumentFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok5
	fail9:
		pos = pos7
		// adverb
		if !_fail(parser, _adverbFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok5
	fail10:
		pos = pos7
		// prepositional_phrase
		if !_fail(parser, _prepositional_phraseFail, errPos, failure, &pos) {
			goto fail11
		}
		goto ok5
	fail11:
		pos = pos7
		goto fail
	ok5:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MI_preposition_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MI_preposition_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_preposition_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MI_preposition_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	{
		var node0 string
		// MI_preposition_tone
		if p, n := _MI_preposition_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// (predicate/argument/adverb/prepositional_phrase)
		// predicate/argument/adverb/prepositional_phrase
		{
			pos7 := pos
			// predicate
			if p, n := _predicateAction(parser, pos); n == nil {
				goto fail8
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail8:
			pos = pos7
			// argument
			if p, n := _argumentAction(parser, pos); n == nil {
				goto fail9
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail9:
			pos = pos7
			// adverb
			if p, n := _adverbAction(parser, pos); n == nil {
				goto fail10
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail10:
			pos = pos7
			// prepositional_phrase
			if p, n := _prepositional_phraseAction(parser, pos); n == nil {
				goto fail11
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail11:
			pos = pos7
			goto fail
		ok5:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MI_preposition_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MI_preposition_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &MI preposition_syllable
	// &MI
	{
		pos2 := pos
		perr4 := perr
		// MI
		if !_accept(parser, _MIAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// preposition_syllable
	if !_accept(parser, _preposition_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _MI_preposition_tone, start, pos, perr)
fail:
	return _memoize(parser, _MI_preposition_tone, start, -1, perr)
}

func _MI_preposition_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MI_preposition_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_preposition_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MI_preposition_tone"}
	// &MI preposition_syllable
	// &MI
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// MI
		if !_node(parser, _MINode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// preposition_syllable
	if !_node(parser, _preposition_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MI_preposition_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MI_preposition_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MI_preposition_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MI_preposition_tone}
	// &MI preposition_syllable
	// &MI
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// MI
		if !_fail(parser, _MIFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&MI",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// preposition_syllable
	if !_fail(parser, _preposition_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MI_preposition_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MI_preposition_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_preposition_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &MI preposition_syllable
	{
		var node0 string
		// &MI
		{
			pos2 := pos
			// MI
			if p, n := _MIAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// preposition_syllable
		if p, n := _preposition_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _PO_prepositionAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _PO_preposition, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// PO_preposition_1 spaces? GA?
	// PO_preposition_1
	if !_accept(parser, _PO_preposition_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_accept(parser, _GAAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	return _memoize(parser, _PO_preposition, start, pos, perr)
fail:
	return _memoize(parser, _PO_preposition, start, -1, perr)
}

func _PO_prepositionNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_PO_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_preposition}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "PO_preposition"}
	// PO_preposition_1 spaces? GA?
	// PO_preposition_1
	if !_node(parser, _PO_preposition_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// GA?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// GA
		if !_node(parser, _GANode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _PO_prepositionFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _PO_preposition, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "PO_preposition",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _PO_preposition}
	// PO_preposition_1 spaces? GA?
	// PO_preposition_1
	if !_fail(parser, _PO_preposition_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_fail(parser, _GAFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _PO_prepositionAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_PO_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_preposition}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// PO_preposition_1 spaces? GA?
	{
		var node0 string
		// PO_preposition_1
		if p, n := _PO_preposition_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// GA?
		{
			pos6 := pos
			// GA
			if p, n := _GAAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _PO_preposition_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _PO_preposition_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// PO_preposition_tone spaces? argument
	// PO_preposition_tone
	if !_accept(parser, _PO_preposition_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// argument
	if !_accept(parser, _argumentAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _PO_preposition_1, start, pos, perr)
fail:
	return _memoize(parser, _PO_preposition_1, start, -1, perr)
}

func _PO_preposition_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_PO_preposition_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_preposition_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "PO_preposition_1"}
	// PO_preposition_tone spaces? argument
	// PO_preposition_tone
	if !_node(parser, _PO_preposition_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// argument
	if !_node(parser, _argumentNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _PO_preposition_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _PO_preposition_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "PO_preposition_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _PO_preposition_1}
	// PO_preposition_tone spaces? argument
	// PO_preposition_tone
	if !_fail(parser, _PO_preposition_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// argument
	if !_fail(parser, _argumentFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _PO_preposition_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_PO_preposition_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_preposition_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// PO_preposition_tone spaces? argument
	{
		var node0 string
		// PO_preposition_tone
		if p, n := _PO_preposition_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// argument
		if p, n := _argumentAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _PO_preposition_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _PO_preposition_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &PO preposition_syllable
	// &PO
	{
		pos2 := pos
		perr4 := perr
		// PO
		if !_accept(parser, _POAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// preposition_syllable
	if !_accept(parser, _preposition_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _PO_preposition_tone, start, pos, perr)
fail:
	return _memoize(parser, _PO_preposition_tone, start, -1, perr)
}

func _PO_preposition_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_PO_preposition_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_preposition_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "PO_preposition_tone"}
	// &PO preposition_syllable
	// &PO
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// PO
		if !_node(parser, _PONode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// preposition_syllable
	if !_node(parser, _preposition_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _PO_preposition_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _PO_preposition_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "PO_preposition_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _PO_preposition_tone}
	// &PO preposition_syllable
	// &PO
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// PO
		if !_fail(parser, _POFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&PO",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// preposition_syllable
	if !_fail(parser, _preposition_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _PO_preposition_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_PO_preposition_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_preposition_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &PO preposition_syllable
	{
		var node0 string
		// &PO
		{
			pos2 := pos
			// PO
			if p, n := _POAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// preposition_syllable
		if p, n := _preposition_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _quotation_prepositionAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _quotation_preposition, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MO_preposition spaces? TEO
	// MO_preposition
	if !_accept(parser, _MO_prepositionAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// TEO
	if !_accept(parser, _TEOAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _quotation_preposition, start, pos, perr)
fail:
	return _memoize(parser, _quotation_preposition, start, -1, perr)
}

func _quotation_prepositionNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_quotation_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _quotation_preposition}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "quotation_preposition"}
	// MO_preposition spaces? TEO
	// MO_preposition
	if !_node(parser, _MO_prepositionNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// TEO
	if !_node(parser, _TEONode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _quotation_prepositionFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _quotation_preposition, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "quotation_preposition",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _quotation_preposition}
	// MO_preposition spaces? TEO
	// MO_preposition
	if !_fail(parser, _MO_prepositionFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// TEO
	if !_fail(parser, _TEOFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _quotation_prepositionAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_quotation_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _quotation_preposition}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MO_preposition spaces? TEO
	{
		var node0 string
		// MO_preposition
		if p, n := _MO_prepositionAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// TEO
		if p, n := _TEOAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MO_prepositionAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MO_preposition, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MO_preposition_tone spaces? discourse
	// MO_preposition_tone
	if !_accept(parser, _MO_preposition_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// discourse
	if !_accept(parser, _discourseAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _MO_preposition, start, pos, perr)
fail:
	return _memoize(parser, _MO_preposition, start, -1, perr)
}

func _MO_prepositionNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MO_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_preposition}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MO_preposition"}
	// MO_preposition_tone spaces? discourse
	// MO_preposition_tone
	if !_node(parser, _MO_preposition_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// discourse
	if !_node(parser, _discourseNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MO_prepositionFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MO_preposition, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MO_preposition",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MO_preposition}
	// MO_preposition_tone spaces? discourse
	// MO_preposition_tone
	if !_fail(parser, _MO_preposition_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// discourse
	if !_fail(parser, _discourseFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MO_prepositionAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MO_preposition]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_preposition}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MO_preposition_tone spaces? discourse
	{
		var node0 string
		// MO_preposition_tone
		if p, n := _MO_preposition_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// discourse
		if p, n := _discourseAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MO_preposition_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MO_preposition_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &MO preposition_syllable
	// &MO
	{
		pos2 := pos
		perr4 := perr
		// MO
		if !_accept(parser, _MOAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// preposition_syllable
	if !_accept(parser, _preposition_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _MO_preposition_tone, start, pos, perr)
fail:
	return _memoize(parser, _MO_preposition_tone, start, -1, perr)
}

func _MO_preposition_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MO_preposition_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_preposition_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MO_preposition_tone"}
	// &MO preposition_syllable
	// &MO
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// MO
		if !_node(parser, _MONode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// preposition_syllable
	if !_node(parser, _preposition_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MO_preposition_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MO_preposition_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MO_preposition_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MO_preposition_tone}
	// &MO preposition_syllable
	// &MO
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// MO
		if !_fail(parser, _MOFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&MO",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// preposition_syllable
	if !_fail(parser, _preposition_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MO_preposition_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MO_preposition_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_preposition_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &MO preposition_syllable
	{
		var node0 string
		// &MO
		{
			pos2 := pos
			// MO
			if p, n := _MOAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// preposition_syllable
		if p, n := _preposition_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _content_clauseAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _content_clause, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// coP_content_statement/content_clause_1
	{
		pos2 := pos
		// coP_content_statement
		if !_accept(parser, _coP_content_statementAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// content_clause_1
		if !_accept(parser, _content_clause_1Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _content_clause, start, pos, perr)
fail:
	return _memoize(parser, _content_clause, start, -1, perr)
}

func _content_clauseNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_content_clause]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _content_clause}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "content_clause"}
	// coP_content_statement/content_clause_1
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// coP_content_statement
		if !_node(parser, _coP_content_statementNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// content_clause_1
		if !_node(parser, _content_clause_1Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _content_clauseFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _content_clause, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "content_clause",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _content_clause}
	// coP_content_statement/content_clause_1
	{
		pos2 := pos
		// coP_content_statement
		if !_fail(parser, _coP_content_statementFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// content_clause_1
		if !_fail(parser, _content_clause_1Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _content_clauseAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_content_clause]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _content_clause}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// coP_content_statement/content_clause_1
	{
		pos2 := pos
		// coP_content_statement
		if p, n := _coP_content_statementAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// content_clause_1
		if p, n := _content_clause_1Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _content_clause_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _content_clause_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// content_predication spaces? end_statement?/LU_content
	{
		pos2 := pos
		// content_predication spaces? end_statement?
		// content_predication
		if !_accept(parser, _content_predicationAccepts, &pos, &perr) {
			goto fail3
		}
		// spaces?
		{
			pos6 := pos
			// spaces
			if !_accept(parser, _spacesAccepts, &pos, &perr) {
				goto fail7
			}
			goto ok8
		fail7:
			pos = pos6
		ok8:
		}
		// end_statement?
		{
			pos10 := pos
			// end_statement
			if !_accept(parser, _end_statementAccepts, &pos, &perr) {
				goto fail11
			}
			goto ok12
		fail11:
			pos = pos10
		ok12:
		}
		goto ok0
	fail3:
		pos = pos2
		// LU_content
		if !_accept(parser, _LU_contentAccepts, &pos, &perr) {
			goto fail13
		}
		goto ok0
	fail13:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _content_clause_1, start, pos, perr)
fail:
	return _memoize(parser, _content_clause_1, start, -1, perr)
}

func _content_clause_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_content_clause_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _content_clause_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "content_clause_1"}
	// content_predication spaces? end_statement?/LU_content
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// content_predication spaces? end_statement?
		// content_predication
		if !_node(parser, _content_predicationNode, node, &pos) {
			goto fail3
		}
		// spaces?
		{
			nkids5 := len(node.Kids)
			pos6 := pos
			// spaces
			if !_node(parser, _spacesNode, node, &pos) {
				goto fail7
			}
			goto ok8
		fail7:
			node.Kids = node.Kids[:nkids5]
			pos = pos6
		ok8:
		}
		// end_statement?
		{
			nkids9 := len(node.Kids)
			pos10 := pos
			// end_statement
			if !_node(parser, _end_statementNode, node, &pos) {
				goto fail11
			}
			goto ok12
		fail11:
			node.Kids = node.Kids[:nkids9]
			pos = pos10
		ok12:
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// LU_content
		if !_node(parser, _LU_contentNode, node, &pos) {
			goto fail13
		}
		goto ok0
	fail13:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _content_clause_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _content_clause_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "content_clause_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _content_clause_1}
	// content_predication spaces? end_statement?/LU_content
	{
		pos2 := pos
		// content_predication spaces? end_statement?
		// content_predication
		if !_fail(parser, _content_predicationFail, errPos, failure, &pos) {
			goto fail3
		}
		// spaces?
		{
			pos6 := pos
			// spaces
			if !_fail(parser, _spacesFail, errPos, failure, &pos) {
				goto fail7
			}
			goto ok8
		fail7:
			pos = pos6
		ok8:
		}
		// end_statement?
		{
			pos10 := pos
			// end_statement
			if !_fail(parser, _end_statementFail, errPos, failure, &pos) {
				goto fail11
			}
			goto ok12
		fail11:
			pos = pos10
		ok12:
		}
		goto ok0
	fail3:
		pos = pos2
		// LU_content
		if !_fail(parser, _LU_contentFail, errPos, failure, &pos) {
			goto fail13
		}
		goto ok0
	fail13:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _content_clause_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_content_clause_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _content_clause_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// content_predication spaces? end_statement?/LU_content
	{
		pos2 := pos
		// content_predication spaces? end_statement?
		{
			var node4 string
			// content_predication
			if p, n := _content_predicationAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
			// spaces?
			{
				pos6 := pos
				// spaces
				if p, n := _spacesAction(parser, pos); n == nil {
					goto fail7
				} else {
					node4 = *n
					pos = p
				}
				goto ok8
			fail7:
				node4 = ""
				pos = pos6
			ok8:
			}
			node += node4
			// end_statement?
			{
				pos10 := pos
				// end_statement
				if p, n := _end_statementAction(parser, pos); n == nil {
					goto fail11
				} else {
					node4 = *n
					pos = p
				}
				goto ok12
			fail11:
				node4 = ""
				pos = pos10
			ok12:
			}
			node += node4
		}
		goto ok0
	fail3:
		pos = pos2
		// LU_content
		if p, n := _LU_contentAction(parser, pos); n == nil {
			goto fail13
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail13:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _content_predicationAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _content_predication, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// content_predicate spaces? terms?
	// content_predicate
	if !_accept(parser, _content_predicateAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms?
	{
		pos6 := pos
		// terms
		if !_accept(parser, _termsAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	return _memoize(parser, _content_predication, start, pos, perr)
fail:
	return _memoize(parser, _content_predication, start, -1, perr)
}

func _content_predicationNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_content_predication]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _content_predication}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "content_predication"}
	// content_predicate spaces? terms?
	// content_predicate
	if !_node(parser, _content_predicateNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// terms?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// terms
		if !_node(parser, _termsNode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _content_predicationFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _content_predication, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "content_predication",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _content_predication}
	// content_predicate spaces? terms?
	// content_predicate
	if !_fail(parser, _content_predicateFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// terms?
	{
		pos6 := pos
		// terms
		if !_fail(parser, _termsFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _content_predicationAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_content_predication]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _content_predication}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// content_predicate spaces? terms?
	{
		var node0 string
		// content_predicate
		if p, n := _content_predicateAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// terms?
		{
			pos6 := pos
			// terms
			if p, n := _termsAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _coP_content_statementAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _coP_content_statement, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// content_clause_1 spaces? co_bar_statement
	// content_clause_1
	if !_accept(parser, _content_clause_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_statement
	if !_accept(parser, _co_bar_statementAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _coP_content_statement, start, pos, perr)
fail:
	return _memoize(parser, _coP_content_statement, start, -1, perr)
}

func _coP_content_statementNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_coP_content_statement]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_content_statement}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "coP_content_statement"}
	// content_clause_1 spaces? co_bar_statement
	// content_clause_1
	if !_node(parser, _content_clause_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// co_bar_statement
	if !_node(parser, _co_bar_statementNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _coP_content_statementFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _coP_content_statement, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "coP_content_statement",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _coP_content_statement}
	// content_clause_1 spaces? co_bar_statement
	// content_clause_1
	if !_fail(parser, _content_clause_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_statement
	if !_fail(parser, _co_bar_statementFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _coP_content_statementAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_coP_content_statement]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_content_statement}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// content_clause_1 spaces? co_bar_statement
	{
		var node0 string
		// content_clause_1
		if p, n := _content_clause_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// co_bar_statement
		if p, n := _co_bar_statementAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _content_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _content_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// serial_content_predicate/content_predicate_1
	{
		pos2 := pos
		// serial_content_predicate
		if !_accept(parser, _serial_content_predicateAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// content_predicate_1
		if !_accept(parser, _content_predicate_1Accepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _content_predicate, start, pos, perr)
fail:
	return _memoize(parser, _content_predicate, start, -1, perr)
}

func _content_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_content_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _content_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "content_predicate"}
	// serial_content_predicate/content_predicate_1
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// serial_content_predicate
		if !_node(parser, _serial_content_predicateNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// content_predicate_1
		if !_node(parser, _content_predicate_1Node, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _content_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _content_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "content_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _content_predicate}
	// serial_content_predicate/content_predicate_1
	{
		pos2 := pos
		// serial_content_predicate
		if !_fail(parser, _serial_content_predicateFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// content_predicate_1
		if !_fail(parser, _content_predicate_1Fail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _content_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_content_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _content_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// serial_content_predicate/content_predicate_1
	{
		pos2 := pos
		// serial_content_predicate
		if p, n := _serial_content_predicateAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// content_predicate_1
		if p, n := _content_predicate_1Action(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _content_predicate_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _content_predicate_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// coP_pred_content_predicate/forethought_coP_pred_content_predicate/content_predicate_2
	{
		pos2 := pos
		// coP_pred_content_predicate
		if !_accept(parser, _coP_pred_content_predicateAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// forethought_coP_pred_content_predicate
		if !_accept(parser, _forethought_coP_pred_content_predicateAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// content_predicate_2
		if !_accept(parser, _content_predicate_2Accepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _content_predicate_1, start, pos, perr)
fail:
	return _memoize(parser, _content_predicate_1, start, -1, perr)
}

func _content_predicate_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_content_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _content_predicate_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "content_predicate_1"}
	// coP_pred_content_predicate/forethought_coP_pred_content_predicate/content_predicate_2
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// coP_pred_content_predicate
		if !_node(parser, _coP_pred_content_predicateNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// forethought_coP_pred_content_predicate
		if !_node(parser, _forethought_coP_pred_content_predicateNode, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// content_predicate_2
		if !_node(parser, _content_predicate_2Node, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _content_predicate_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _content_predicate_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "content_predicate_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _content_predicate_1}
	// coP_pred_content_predicate/forethought_coP_pred_content_predicate/content_predicate_2
	{
		pos2 := pos
		// coP_pred_content_predicate
		if !_fail(parser, _coP_pred_content_predicateFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// forethought_coP_pred_content_predicate
		if !_fail(parser, _forethought_coP_pred_content_predicateFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// content_predicate_2
		if !_fail(parser, _content_predicate_2Fail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _content_predicate_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_content_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _content_predicate_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// coP_pred_content_predicate/forethought_coP_pred_content_predicate/content_predicate_2
	{
		pos2 := pos
		// coP_pred_content_predicate
		if p, n := _coP_pred_content_predicateAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// forethought_coP_pred_content_predicate
		if p, n := _forethought_coP_pred_content_predicateAction(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		// content_predicate_2
		if p, n := _content_predicate_2Action(parser, pos); n == nil {
			goto fail5
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail5:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _content_predicate_2Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _content_predicate_2, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MI_content_predicate/PO_content_predicate/quotation_content_predicate/content_predicate_3
	{
		pos2 := pos
		// MI_content_predicate
		if !_accept(parser, _MI_content_predicateAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// PO_content_predicate
		if !_accept(parser, _PO_content_predicateAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// quotation_content_predicate
		if !_accept(parser, _quotation_content_predicateAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// content_predicate_3
		if !_accept(parser, _content_predicate_3Accepts, &pos, &perr) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _content_predicate_2, start, pos, perr)
fail:
	return _memoize(parser, _content_predicate_2, start, -1, perr)
}

func _content_predicate_2Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_content_predicate_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _content_predicate_2}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "content_predicate_2"}
	// MI_content_predicate/PO_content_predicate/quotation_content_predicate/content_predicate_3
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// MI_content_predicate
		if !_node(parser, _MI_content_predicateNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// PO_content_predicate
		if !_node(parser, _PO_content_predicateNode, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// quotation_content_predicate
		if !_node(parser, _quotation_content_predicateNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// content_predicate_3
		if !_node(parser, _content_predicate_3Node, node, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _content_predicate_2Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _content_predicate_2, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "content_predicate_2",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _content_predicate_2}
	// MI_content_predicate/PO_content_predicate/quotation_content_predicate/content_predicate_3
	{
		pos2 := pos
		// MI_content_predicate
		if !_fail(parser, _MI_content_predicateFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// PO_content_predicate
		if !_fail(parser, _PO_content_predicateFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// quotation_content_predicate
		if !_fail(parser, _quotation_content_predicateFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// content_predicate_3
		if !_fail(parser, _content_predicate_3Fail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _content_predicate_2Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_content_predicate_2]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _content_predicate_2}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MI_content_predicate/PO_content_predicate/quotation_content_predicate/content_predicate_3
	{
		pos2 := pos
		// MI_content_predicate
		if p, n := _MI_content_predicateAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// PO_content_predicate
		if p, n := _PO_content_predicateAction(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		// quotation_content_predicate
		if p, n := _quotation_content_predicateAction(parser, pos); n == nil {
			goto fail5
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail5:
		pos = pos2
		// content_predicate_3
		if p, n := _content_predicate_3Action(parser, pos); n == nil {
			goto fail6
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail6:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _content_predicate_3Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _content_predicate_3, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// content_syllable compound_syllable+/!function_word content_syllable
	{
		pos2 := pos
		// content_syllable compound_syllable+
		// content_syllable
		if !_accept(parser, _content_syllableAccepts, &pos, &perr) {
			goto fail3
		}
		// compound_syllable+
		// compound_syllable
		if !_accept(parser, _compound_syllableAccepts, &pos, &perr) {
			goto fail3
		}
		for {
			pos6 := pos
			// compound_syllable
			if !_accept(parser, _compound_syllableAccepts, &pos, &perr) {
				goto fail8
			}
			continue
		fail8:
			pos = pos6
			break
		}
		goto ok0
	fail3:
		pos = pos2
		// !function_word content_syllable
		// !function_word
		{
			pos12 := pos
			perr14 := perr
			// function_word
			if !_accept(parser, _function_wordAccepts, &pos, &perr) {
				goto ok11
			}
			pos = pos12
			perr = _max(perr14, pos)
			goto fail9
		ok11:
			pos = pos12
			perr = perr14
		}
		// content_syllable
		if !_accept(parser, _content_syllableAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _content_predicate_3, start, pos, perr)
fail:
	return _memoize(parser, _content_predicate_3, start, -1, perr)
}

func _content_predicate_3Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_content_predicate_3]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _content_predicate_3}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "content_predicate_3"}
	// content_syllable compound_syllable+/!function_word content_syllable
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// content_syllable compound_syllable+
		// content_syllable
		if !_node(parser, _content_syllableNode, node, &pos) {
			goto fail3
		}
		// compound_syllable+
		// compound_syllable
		if !_node(parser, _compound_syllableNode, node, &pos) {
			goto fail3
		}
		for {
			nkids5 := len(node.Kids)
			pos6 := pos
			// compound_syllable
			if !_node(parser, _compound_syllableNode, node, &pos) {
				goto fail8
			}
			continue
		fail8:
			node.Kids = node.Kids[:nkids5]
			pos = pos6
			break
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// !function_word content_syllable
		// !function_word
		{
			pos12 := pos
			nkids13 := len(node.Kids)
			// function_word
			if !_node(parser, _function_wordNode, node, &pos) {
				goto ok11
			}
			pos = pos12
			node.Kids = node.Kids[:nkids13]
			goto fail9
		ok11:
			pos = pos12
			node.Kids = node.Kids[:nkids13]
		}
		// content_syllable
		if !_node(parser, _content_syllableNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _content_predicate_3Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _content_predicate_3, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "content_predicate_3",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _content_predicate_3}
	// content_syllable compound_syllable+/!function_word content_syllable
	{
		pos2 := pos
		// content_syllable compound_syllable+
		// content_syllable
		if !_fail(parser, _content_syllableFail, errPos, failure, &pos) {
			goto fail3
		}
		// compound_syllable+
		// compound_syllable
		if !_fail(parser, _compound_syllableFail, errPos, failure, &pos) {
			goto fail3
		}
		for {
			pos6 := pos
			// compound_syllable
			if !_fail(parser, _compound_syllableFail, errPos, failure, &pos) {
				goto fail8
			}
			continue
		fail8:
			pos = pos6
			break
		}
		goto ok0
	fail3:
		pos = pos2
		// !function_word content_syllable
		// !function_word
		{
			pos12 := pos
			nkids13 := len(failure.Kids)
			// function_word
			if !_fail(parser, _function_wordFail, errPos, failure, &pos) {
				goto ok11
			}
			pos = pos12
			failure.Kids = failure.Kids[:nkids13]
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "!function_word",
				})
			}
			goto fail9
		ok11:
			pos = pos12
			failure.Kids = failure.Kids[:nkids13]
		}
		// content_syllable
		if !_fail(parser, _content_syllableFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _content_predicate_3Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_content_predicate_3]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _content_predicate_3}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// content_syllable compound_syllable+/!function_word content_syllable
	{
		pos2 := pos
		// content_syllable compound_syllable+
		{
			var node4 string
			// content_syllable
			if p, n := _content_syllableAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
			// compound_syllable+
			{
				var node7 string
				// compound_syllable
				if p, n := _compound_syllableAction(parser, pos); n == nil {
					goto fail3
				} else {
					node7 = *n
					pos = p
				}
				node4 += node7
			}
			for {
				pos6 := pos
				var node7 string
				// compound_syllable
				if p, n := _compound_syllableAction(parser, pos); n == nil {
					goto fail8
				} else {
					node7 = *n
					pos = p
				}
				node4 += node7
				continue
			fail8:
				pos = pos6
				break
			}
			node += node4
		}
		goto ok0
	fail3:
		pos = pos2
		// !function_word content_syllable
		{
			var node10 string
			// !function_word
			{
				pos12 := pos
				// function_word
				if p, n := _function_wordAction(parser, pos); n == nil {
					goto ok11
				} else {
					pos = p
				}
				pos = pos12
				goto fail9
			ok11:
				pos = pos12
				node = ""
			}
			node += node10
			// content_syllable
			if p, n := _content_syllableAction(parser, pos); n == nil {
				goto fail9
			} else {
				node10 = *n
				pos = p
			}
			node += node10
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _serial_content_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _serial_content_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// content_predicate_1 spaces? serial_predicate
	// content_predicate_1
	if !_accept(parser, _content_predicate_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// serial_predicate
	if !_accept(parser, _serial_predicateAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _serial_content_predicate, start, pos, perr)
fail:
	return _memoize(parser, _serial_content_predicate, start, -1, perr)
}

func _serial_content_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_serial_content_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _serial_content_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "serial_content_predicate"}
	// content_predicate_1 spaces? serial_predicate
	// content_predicate_1
	if !_node(parser, _content_predicate_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// serial_predicate
	if !_node(parser, _serial_predicateNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _serial_content_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _serial_content_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "serial_content_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _serial_content_predicate}
	// content_predicate_1 spaces? serial_predicate
	// content_predicate_1
	if !_fail(parser, _content_predicate_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// serial_predicate
	if !_fail(parser, _serial_predicateFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _serial_content_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_serial_content_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _serial_content_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// content_predicate_1 spaces? serial_predicate
	{
		var node0 string
		// content_predicate_1
		if p, n := _content_predicate_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// serial_predicate
		if p, n := _serial_predicateAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _coP_pred_content_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _coP_pred_content_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// content_predicate_2 spaces? co_bar_pred
	// content_predicate_2
	if !_accept(parser, _content_predicate_2Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_pred
	if !_accept(parser, _co_bar_predAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _coP_pred_content_predicate, start, pos, perr)
fail:
	return _memoize(parser, _coP_pred_content_predicate, start, -1, perr)
}

func _coP_pred_content_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_coP_pred_content_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_pred_content_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "coP_pred_content_predicate"}
	// content_predicate_2 spaces? co_bar_pred
	// content_predicate_2
	if !_node(parser, _content_predicate_2Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// co_bar_pred
	if !_node(parser, _co_bar_predNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _coP_pred_content_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _coP_pred_content_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "coP_pred_content_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _coP_pred_content_predicate}
	// content_predicate_2 spaces? co_bar_pred
	// content_predicate_2
	if !_fail(parser, _content_predicate_2Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// co_bar_pred
	if !_fail(parser, _co_bar_predFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _coP_pred_content_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_coP_pred_content_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _coP_pred_content_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// content_predicate_2 spaces? co_bar_pred
	{
		var node0 string
		// content_predicate_2
		if p, n := _content_predicate_2Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// co_bar_pred
		if p, n := _co_bar_predAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_pred_content_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_pred_content_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// forethought_connective spaces? forethought_coP_pred_content_predicate_1
	// forethought_connective
	if !_accept(parser, _forethought_connectiveAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_pred_content_predicate_1
	if !_accept(parser, _forethought_coP_pred_content_predicate_1Accepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_pred_content_predicate, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_pred_content_predicate, start, -1, perr)
}

func _forethought_coP_pred_content_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_pred_content_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_content_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_pred_content_predicate"}
	// forethought_connective spaces? forethought_coP_pred_content_predicate_1
	// forethought_connective
	if !_node(parser, _forethought_connectiveNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_coP_pred_content_predicate_1
	if !_node(parser, _forethought_coP_pred_content_predicate_1Node, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_pred_content_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_pred_content_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_pred_content_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_pred_content_predicate}
	// forethought_connective spaces? forethought_coP_pred_content_predicate_1
	// forethought_connective
	if !_fail(parser, _forethought_connectiveFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_coP_pred_content_predicate_1
	if !_fail(parser, _forethought_coP_pred_content_predicate_1Fail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_pred_content_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_pred_content_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_content_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// forethought_connective spaces? forethought_coP_pred_content_predicate_1
	{
		var node0 string
		// forethought_connective
		if p, n := _forethought_connectiveAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_coP_pred_content_predicate_1
		if p, n := _forethought_coP_pred_content_predicate_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _forethought_coP_pred_content_predicate_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _forethought_coP_pred_content_predicate_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// content_predicate spaces? forethought_co_bar_pred
	// content_predicate
	if !_accept(parser, _content_predicateAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_pred
	if !_accept(parser, _forethought_co_bar_predAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _forethought_coP_pred_content_predicate_1, start, pos, perr)
fail:
	return _memoize(parser, _forethought_coP_pred_content_predicate_1, start, -1, perr)
}

func _forethought_coP_pred_content_predicate_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_forethought_coP_pred_content_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_content_predicate_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "forethought_coP_pred_content_predicate_1"}
	// content_predicate spaces? forethought_co_bar_pred
	// content_predicate
	if !_node(parser, _content_predicateNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// forethought_co_bar_pred
	if !_node(parser, _forethought_co_bar_predNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _forethought_coP_pred_content_predicate_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _forethought_coP_pred_content_predicate_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "forethought_coP_pred_content_predicate_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _forethought_coP_pred_content_predicate_1}
	// content_predicate spaces? forethought_co_bar_pred
	// content_predicate
	if !_fail(parser, _content_predicateFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// forethought_co_bar_pred
	if !_fail(parser, _forethought_co_bar_predFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _forethought_coP_pred_content_predicate_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_forethought_coP_pred_content_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _forethought_coP_pred_content_predicate_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// content_predicate spaces? forethought_co_bar_pred
	{
		var node0 string
		// content_predicate
		if p, n := _content_predicateAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// forethought_co_bar_pred
		if p, n := _forethought_co_bar_predAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _LU_contentAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _LU_content, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// LU_content_tone statement
	// LU_content_tone
	if !_accept(parser, _LU_content_toneAccepts, &pos, &perr) {
		goto fail
	}
	// statement
	if !_accept(parser, _statementAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _LU_content, start, pos, perr)
fail:
	return _memoize(parser, _LU_content, start, -1, perr)
}

func _LU_contentNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_LU_content]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_content}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "LU_content"}
	// LU_content_tone statement
	// LU_content_tone
	if !_node(parser, _LU_content_toneNode, node, &pos) {
		goto fail
	}
	// statement
	if !_node(parser, _statementNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _LU_contentFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _LU_content, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "LU_content",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _LU_content}
	// LU_content_tone statement
	// LU_content_tone
	if !_fail(parser, _LU_content_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// statement
	if !_fail(parser, _statementFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _LU_contentAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_LU_content]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_content}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// LU_content_tone statement
	{
		var node0 string
		// LU_content_tone
		if p, n := _LU_content_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// statement
		if p, n := _statementAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _LU_content_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _LU_content_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &LU content_syllable
	// &LU
	{
		pos2 := pos
		perr4 := perr
		// LU
		if !_accept(parser, _LUAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// content_syllable
	if !_accept(parser, _content_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _LU_content_tone, start, pos, perr)
fail:
	return _memoize(parser, _LU_content_tone, start, -1, perr)
}

func _LU_content_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_LU_content_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_content_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "LU_content_tone"}
	// &LU content_syllable
	// &LU
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// LU
		if !_node(parser, _LUNode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// content_syllable
	if !_node(parser, _content_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _LU_content_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _LU_content_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "LU_content_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _LU_content_tone}
	// &LU content_syllable
	// &LU
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// LU
		if !_fail(parser, _LUFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&LU",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// content_syllable
	if !_fail(parser, _content_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _LU_content_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_LU_content_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU_content_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &LU content_syllable
	{
		var node0 string
		// &LU
		{
			pos2 := pos
			// LU
			if p, n := _LUAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// content_syllable
		if p, n := _content_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MI_content_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MI_content_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MI_content_predicate_1 spaces? GA?
	// MI_content_predicate_1
	if !_accept(parser, _MI_content_predicate_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_accept(parser, _GAAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	return _memoize(parser, _MI_content_predicate, start, pos, perr)
fail:
	return _memoize(parser, _MI_content_predicate, start, -1, perr)
}

func _MI_content_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MI_content_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_content_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MI_content_predicate"}
	// MI_content_predicate_1 spaces? GA?
	// MI_content_predicate_1
	if !_node(parser, _MI_content_predicate_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// GA?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// GA
		if !_node(parser, _GANode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MI_content_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MI_content_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MI_content_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MI_content_predicate}
	// MI_content_predicate_1 spaces? GA?
	// MI_content_predicate_1
	if !_fail(parser, _MI_content_predicate_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_fail(parser, _GAFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MI_content_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MI_content_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_content_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MI_content_predicate_1 spaces? GA?
	{
		var node0 string
		// MI_content_predicate_1
		if p, n := _MI_content_predicate_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// GA?
		{
			pos6 := pos
			// GA
			if p, n := _GAAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MI_content_predicate_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MI_content_predicate_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MI_content_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	// MI_content_tone
	if !_accept(parser, _MI_content_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// (predicate/argument/adverb/prepositional_phrase)
	// predicate/argument/adverb/prepositional_phrase
	{
		pos7 := pos
		// predicate
		if !_accept(parser, _predicateAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok5
	fail8:
		pos = pos7
		// argument
		if !_accept(parser, _argumentAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok5
	fail9:
		pos = pos7
		// adverb
		if !_accept(parser, _adverbAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok5
	fail10:
		pos = pos7
		// prepositional_phrase
		if !_accept(parser, _prepositional_phraseAccepts, &pos, &perr) {
			goto fail11
		}
		goto ok5
	fail11:
		pos = pos7
		goto fail
	ok5:
	}
	return _memoize(parser, _MI_content_predicate_1, start, pos, perr)
fail:
	return _memoize(parser, _MI_content_predicate_1, start, -1, perr)
}

func _MI_content_predicate_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MI_content_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_content_predicate_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MI_content_predicate_1"}
	// MI_content_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	// MI_content_tone
	if !_node(parser, _MI_content_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// (predicate/argument/adverb/prepositional_phrase)
	{
		nkids5 := len(node.Kids)
		pos06 := pos
		// predicate/argument/adverb/prepositional_phrase
		{
			pos9 := pos
			nkids8 := len(node.Kids)
			// predicate
			if !_node(parser, _predicateNode, node, &pos) {
				goto fail10
			}
			goto ok7
		fail10:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// argument
			if !_node(parser, _argumentNode, node, &pos) {
				goto fail11
			}
			goto ok7
		fail11:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// adverb
			if !_node(parser, _adverbNode, node, &pos) {
				goto fail12
			}
			goto ok7
		fail12:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// prepositional_phrase
			if !_node(parser, _prepositional_phraseNode, node, &pos) {
				goto fail13
			}
			goto ok7
		fail13:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			goto fail
		ok7:
		}
		sub := _sub(parser, pos06, pos, node.Kids[nkids5:])
		node.Kids = append(node.Kids[:nkids5], sub)
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MI_content_predicate_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MI_content_predicate_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MI_content_predicate_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MI_content_predicate_1}
	// MI_content_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	// MI_content_tone
	if !_fail(parser, _MI_content_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// (predicate/argument/adverb/prepositional_phrase)
	// predicate/argument/adverb/prepositional_phrase
	{
		pos7 := pos
		// predicate
		if !_fail(parser, _predicateFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok5
	fail8:
		pos = pos7
		// argument
		if !_fail(parser, _argumentFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok5
	fail9:
		pos = pos7
		// adverb
		if !_fail(parser, _adverbFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok5
	fail10:
		pos = pos7
		// prepositional_phrase
		if !_fail(parser, _prepositional_phraseFail, errPos, failure, &pos) {
			goto fail11
		}
		goto ok5
	fail11:
		pos = pos7
		goto fail
	ok5:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MI_content_predicate_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MI_content_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_content_predicate_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MI_content_tone spaces? (predicate/argument/adverb/prepositional_phrase)
	{
		var node0 string
		// MI_content_tone
		if p, n := _MI_content_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// (predicate/argument/adverb/prepositional_phrase)
		// predicate/argument/adverb/prepositional_phrase
		{
			pos7 := pos
			// predicate
			if p, n := _predicateAction(parser, pos); n == nil {
				goto fail8
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail8:
			pos = pos7
			// argument
			if p, n := _argumentAction(parser, pos); n == nil {
				goto fail9
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail9:
			pos = pos7
			// adverb
			if p, n := _adverbAction(parser, pos); n == nil {
				goto fail10
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail10:
			pos = pos7
			// prepositional_phrase
			if p, n := _prepositional_phraseAction(parser, pos); n == nil {
				goto fail11
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail11:
			pos = pos7
			goto fail
		ok5:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MI_content_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MI_content_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &MI content_syllable
	// &MI
	{
		pos2 := pos
		perr4 := perr
		// MI
		if !_accept(parser, _MIAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// content_syllable
	if !_accept(parser, _content_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _MI_content_tone, start, pos, perr)
fail:
	return _memoize(parser, _MI_content_tone, start, -1, perr)
}

func _MI_content_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MI_content_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_content_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MI_content_tone"}
	// &MI content_syllable
	// &MI
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// MI
		if !_node(parser, _MINode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// content_syllable
	if !_node(parser, _content_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MI_content_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MI_content_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MI_content_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MI_content_tone}
	// &MI content_syllable
	// &MI
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// MI
		if !_fail(parser, _MIFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&MI",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// content_syllable
	if !_fail(parser, _content_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MI_content_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MI_content_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI_content_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &MI content_syllable
	{
		var node0 string
		// &MI
		{
			pos2 := pos
			// MI
			if p, n := _MIAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// content_syllable
		if p, n := _content_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _PO_content_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _PO_content_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// PO_content_predicate_1 spaces? GA?
	// PO_content_predicate_1
	if !_accept(parser, _PO_content_predicate_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_accept(parser, _GAAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	return _memoize(parser, _PO_content_predicate, start, pos, perr)
fail:
	return _memoize(parser, _PO_content_predicate, start, -1, perr)
}

func _PO_content_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_PO_content_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_content_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "PO_content_predicate"}
	// PO_content_predicate_1 spaces? GA?
	// PO_content_predicate_1
	if !_node(parser, _PO_content_predicate_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// GA?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// GA
		if !_node(parser, _GANode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _PO_content_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _PO_content_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "PO_content_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _PO_content_predicate}
	// PO_content_predicate_1 spaces? GA?
	// PO_content_predicate_1
	if !_fail(parser, _PO_content_predicate_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// GA?
	{
		pos6 := pos
		// GA
		if !_fail(parser, _GAFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _PO_content_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_PO_content_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_content_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// PO_content_predicate_1 spaces? GA?
	{
		var node0 string
		// PO_content_predicate_1
		if p, n := _PO_content_predicate_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// GA?
		{
			pos6 := pos
			// GA
			if p, n := _GAAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _PO_content_predicate_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _PO_content_predicate_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// PO_content_tone spaces? argument
	// PO_content_tone
	if !_accept(parser, _PO_content_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// argument
	if !_accept(parser, _argumentAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _PO_content_predicate_1, start, pos, perr)
fail:
	return _memoize(parser, _PO_content_predicate_1, start, -1, perr)
}

func _PO_content_predicate_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_PO_content_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_content_predicate_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "PO_content_predicate_1"}
	// PO_content_tone spaces? argument
	// PO_content_tone
	if !_node(parser, _PO_content_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// argument
	if !_node(parser, _argumentNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _PO_content_predicate_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _PO_content_predicate_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "PO_content_predicate_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _PO_content_predicate_1}
	// PO_content_tone spaces? argument
	// PO_content_tone
	if !_fail(parser, _PO_content_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// argument
	if !_fail(parser, _argumentFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _PO_content_predicate_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_PO_content_predicate_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_content_predicate_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// PO_content_tone spaces? argument
	{
		var node0 string
		// PO_content_tone
		if p, n := _PO_content_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// argument
		if p, n := _argumentAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _PO_content_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _PO_content_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &PO content_syllable
	// &PO
	{
		pos2 := pos
		perr4 := perr
		// PO
		if !_accept(parser, _POAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// content_syllable
	if !_accept(parser, _content_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _PO_content_tone, start, pos, perr)
fail:
	return _memoize(parser, _PO_content_tone, start, -1, perr)
}

func _PO_content_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_PO_content_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_content_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "PO_content_tone"}
	// &PO content_syllable
	// &PO
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// PO
		if !_node(parser, _PONode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// content_syllable
	if !_node(parser, _content_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _PO_content_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _PO_content_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "PO_content_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _PO_content_tone}
	// &PO content_syllable
	// &PO
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// PO
		if !_fail(parser, _POFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&PO",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// content_syllable
	if !_fail(parser, _content_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _PO_content_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_PO_content_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO_content_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &PO content_syllable
	{
		var node0 string
		// &PO
		{
			pos2 := pos
			// PO
			if p, n := _POAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// content_syllable
		if p, n := _content_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _quotation_content_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _quotation_content_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MO_content_predicate spaces? TEO
	// MO_content_predicate
	if !_accept(parser, _MO_content_predicateAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// TEO
	if !_accept(parser, _TEOAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _quotation_content_predicate, start, pos, perr)
fail:
	return _memoize(parser, _quotation_content_predicate, start, -1, perr)
}

func _quotation_content_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_quotation_content_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _quotation_content_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "quotation_content_predicate"}
	// MO_content_predicate spaces? TEO
	// MO_content_predicate
	if !_node(parser, _MO_content_predicateNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// TEO
	if !_node(parser, _TEONode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _quotation_content_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _quotation_content_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "quotation_content_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _quotation_content_predicate}
	// MO_content_predicate spaces? TEO
	// MO_content_predicate
	if !_fail(parser, _MO_content_predicateFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// TEO
	if !_fail(parser, _TEOFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _quotation_content_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_quotation_content_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _quotation_content_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MO_content_predicate spaces? TEO
	{
		var node0 string
		// MO_content_predicate
		if p, n := _MO_content_predicateAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// TEO
		if p, n := _TEOAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MO_content_predicateAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MO_content_predicate, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MO_content_predicate_tone spaces? discourse
	// MO_content_predicate_tone
	if !_accept(parser, _MO_content_predicate_toneAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// discourse
	if !_accept(parser, _discourseAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _MO_content_predicate, start, pos, perr)
fail:
	return _memoize(parser, _MO_content_predicate, start, -1, perr)
}

func _MO_content_predicateNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MO_content_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_content_predicate}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MO_content_predicate"}
	// MO_content_predicate_tone spaces? discourse
	// MO_content_predicate_tone
	if !_node(parser, _MO_content_predicate_toneNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// discourse
	if !_node(parser, _discourseNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MO_content_predicateFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MO_content_predicate, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MO_content_predicate",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MO_content_predicate}
	// MO_content_predicate_tone spaces? discourse
	// MO_content_predicate_tone
	if !_fail(parser, _MO_content_predicate_toneFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// discourse
	if !_fail(parser, _discourseFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MO_content_predicateAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MO_content_predicate]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_content_predicate}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MO_content_predicate_tone spaces? discourse
	{
		var node0 string
		// MO_content_predicate_tone
		if p, n := _MO_content_predicate_toneAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// discourse
		if p, n := _discourseAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MO_content_predicate_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MO_content_predicate_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// &MO content_syllable
	// &MO
	{
		pos2 := pos
		perr4 := perr
		// MO
		if !_accept(parser, _MOAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	// content_syllable
	if !_accept(parser, _content_syllableAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _MO_content_predicate_tone, start, pos, perr)
fail:
	return _memoize(parser, _MO_content_predicate_tone, start, -1, perr)
}

func _MO_content_predicate_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MO_content_predicate_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_content_predicate_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MO_content_predicate_tone"}
	// &MO content_syllable
	// &MO
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// MO
		if !_node(parser, _MONode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	// content_syllable
	if !_node(parser, _content_syllableNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MO_content_predicate_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MO_content_predicate_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MO_content_predicate_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MO_content_predicate_tone}
	// &MO content_syllable
	// &MO
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// MO
		if !_fail(parser, _MOFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&MO",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	// content_syllable
	if !_fail(parser, _content_syllableFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MO_content_predicate_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MO_content_predicate_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO_content_predicate_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// &MO content_syllable
	{
		var node0 string
		// &MO
		{
			pos2 := pos
			// MO
			if p, n := _MOAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
		// content_syllable
		if p, n := _content_syllableAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _freemodAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _freemod, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// spaces? (interjection/parenthetical/incidental/vocative) spaces?
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// (interjection/parenthetical/incidental/vocative)
	// interjection/parenthetical/incidental/vocative
	{
		pos7 := pos
		// interjection
		if !_accept(parser, _interjectionAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok5
	fail8:
		pos = pos7
		// parenthetical
		if !_accept(parser, _parentheticalAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok5
	fail9:
		pos = pos7
		// incidental
		if !_accept(parser, _incidentalAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok5
	fail10:
		pos = pos7
		// vocative
		if !_accept(parser, _vocativeAccepts, &pos, &perr) {
			goto fail11
		}
		goto ok5
	fail11:
		pos = pos7
		goto fail
	ok5:
	}
	// spaces?
	{
		pos13 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail14
		}
		goto ok15
	fail14:
		pos = pos13
	ok15:
	}
	return _memoize(parser, _freemod, start, pos, perr)
fail:
	return _memoize(parser, _freemod, start, -1, perr)
}

func _freemodNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_freemod]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _freemod}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "freemod"}
	// spaces? (interjection/parenthetical/incidental/vocative) spaces?
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// (interjection/parenthetical/incidental/vocative)
	{
		nkids5 := len(node.Kids)
		pos06 := pos
		// interjection/parenthetical/incidental/vocative
		{
			pos9 := pos
			nkids8 := len(node.Kids)
			// interjection
			if !_node(parser, _interjectionNode, node, &pos) {
				goto fail10
			}
			goto ok7
		fail10:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// parenthetical
			if !_node(parser, _parentheticalNode, node, &pos) {
				goto fail11
			}
			goto ok7
		fail11:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// incidental
			if !_node(parser, _incidentalNode, node, &pos) {
				goto fail12
			}
			goto ok7
		fail12:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			// vocative
			if !_node(parser, _vocativeNode, node, &pos) {
				goto fail13
			}
			goto ok7
		fail13:
			node.Kids = node.Kids[:nkids8]
			pos = pos9
			goto fail
		ok7:
		}
		sub := _sub(parser, pos06, pos, node.Kids[nkids5:])
		node.Kids = append(node.Kids[:nkids5], sub)
	}
	// spaces?
	{
		nkids14 := len(node.Kids)
		pos15 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail16
		}
		goto ok17
	fail16:
		node.Kids = node.Kids[:nkids14]
		pos = pos15
	ok17:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _freemodFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _freemod, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "freemod",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _freemod}
	// spaces? (interjection/parenthetical/incidental/vocative) spaces?
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// (interjection/parenthetical/incidental/vocative)
	// interjection/parenthetical/incidental/vocative
	{
		pos7 := pos
		// interjection
		if !_fail(parser, _interjectionFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok5
	fail8:
		pos = pos7
		// parenthetical
		if !_fail(parser, _parentheticalFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok5
	fail9:
		pos = pos7
		// incidental
		if !_fail(parser, _incidentalFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok5
	fail10:
		pos = pos7
		// vocative
		if !_fail(parser, _vocativeFail, errPos, failure, &pos) {
			goto fail11
		}
		goto ok5
	fail11:
		pos = pos7
		goto fail
	ok5:
	}
	// spaces?
	{
		pos13 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail14
		}
		goto ok15
	fail14:
		pos = pos13
	ok15:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _freemodAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_freemod]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _freemod}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// spaces? (interjection/parenthetical/incidental/vocative) spaces?
	{
		var node0 string
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// (interjection/parenthetical/incidental/vocative)
		// interjection/parenthetical/incidental/vocative
		{
			pos7 := pos
			// interjection
			if p, n := _interjectionAction(parser, pos); n == nil {
				goto fail8
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail8:
			pos = pos7
			// parenthetical
			if p, n := _parentheticalAction(parser, pos); n == nil {
				goto fail9
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail9:
			pos = pos7
			// incidental
			if p, n := _incidentalAction(parser, pos); n == nil {
				goto fail10
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail10:
			pos = pos7
			// vocative
			if p, n := _vocativeAction(parser, pos); n == nil {
				goto fail11
			} else {
				node0 = *n
				pos = p
			}
			goto ok5
		fail11:
			pos = pos7
			goto fail
		ok5:
		}
		node += node0
		// spaces?
		{
			pos13 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail14
			} else {
				node0 = *n
				pos = p
			}
			goto ok15
		fail14:
			node0 = ""
			pos = pos13
		ok15:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _parentheticalAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _parenthetical, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// parenthetical_1 spaces? end_parenthetical
	// parenthetical_1
	if !_accept(parser, _parenthetical_1Accepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// end_parenthetical
	if !_accept(parser, _end_parentheticalAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _parenthetical, start, pos, perr)
fail:
	return _memoize(parser, _parenthetical, start, -1, perr)
}

func _parentheticalNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_parenthetical]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _parenthetical}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "parenthetical"}
	// parenthetical_1 spaces? end_parenthetical
	// parenthetical_1
	if !_node(parser, _parenthetical_1Node, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// end_parenthetical
	if !_node(parser, _end_parentheticalNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _parentheticalFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _parenthetical, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "parenthetical",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _parenthetical}
	// parenthetical_1 spaces? end_parenthetical
	// parenthetical_1
	if !_fail(parser, _parenthetical_1Fail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// end_parenthetical
	if !_fail(parser, _end_parentheticalFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _parentheticalAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_parenthetical]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _parenthetical}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// parenthetical_1 spaces? end_parenthetical
	{
		var node0 string
		// parenthetical_1
		if p, n := _parenthetical_1Action(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// end_parenthetical
		if p, n := _end_parentheticalAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _parenthetical_1Accepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _parenthetical_1, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// start_parenthetical spaces? discourse
	// start_parenthetical
	if !_accept(parser, _start_parentheticalAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// discourse
	if !_accept(parser, _discourseAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _parenthetical_1, start, pos, perr)
fail:
	return _memoize(parser, _parenthetical_1, start, -1, perr)
}

func _parenthetical_1Node(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_parenthetical_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _parenthetical_1}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "parenthetical_1"}
	// start_parenthetical spaces? discourse
	// start_parenthetical
	if !_node(parser, _start_parentheticalNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// discourse
	if !_node(parser, _discourseNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _parenthetical_1Fail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _parenthetical_1, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "parenthetical_1",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _parenthetical_1}
	// start_parenthetical spaces? discourse
	// start_parenthetical
	if !_fail(parser, _start_parentheticalFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// discourse
	if !_fail(parser, _discourseFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _parenthetical_1Action(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_parenthetical_1]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _parenthetical_1}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// start_parenthetical spaces? discourse
	{
		var node0 string
		// start_parenthetical
		if p, n := _start_parentheticalAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// discourse
		if p, n := _discourseAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _incidentalAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _incidental, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// spaces? start_incidental freemod? statement
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// start_incidental
	if !_accept(parser, _start_incidentalAccepts, &pos, &perr) {
		goto fail
	}
	// freemod?
	{
		pos6 := pos
		// freemod
		if !_accept(parser, _freemodAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	// statement
	if !_accept(parser, _statementAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _incidental, start, pos, perr)
fail:
	return _memoize(parser, _incidental, start, -1, perr)
}

func _incidentalNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_incidental]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _incidental}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "incidental"}
	// spaces? start_incidental freemod? statement
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// start_incidental
	if !_node(parser, _start_incidentalNode, node, &pos) {
		goto fail
	}
	// freemod?
	{
		nkids5 := len(node.Kids)
		pos6 := pos
		// freemod
		if !_node(parser, _freemodNode, node, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		node.Kids = node.Kids[:nkids5]
		pos = pos6
	ok8:
	}
	// statement
	if !_node(parser, _statementNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _incidentalFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _incidental, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "incidental",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _incidental}
	// spaces? start_incidental freemod? statement
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// start_incidental
	if !_fail(parser, _start_incidentalFail, errPos, failure, &pos) {
		goto fail
	}
	// freemod?
	{
		pos6 := pos
		// freemod
		if !_fail(parser, _freemodFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok8
	fail7:
		pos = pos6
	ok8:
	}
	// statement
	if !_fail(parser, _statementFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _incidentalAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_incidental]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _incidental}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// spaces? start_incidental freemod? statement
	{
		var node0 string
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// start_incidental
		if p, n := _start_incidentalAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// freemod?
		{
			pos6 := pos
			// freemod
			if p, n := _freemodAction(parser, pos); n == nil {
				goto fail7
			} else {
				node0 = *n
				pos = p
			}
			goto ok8
		fail7:
			node0 = ""
			pos = pos6
		ok8:
		}
		node += node0
		// statement
		if p, n := _statementAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _vocativeAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _vocative, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// vocative_marker spaces? argument
	// vocative_marker
	if !_accept(parser, _vocative_markerAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// argument
	if !_accept(parser, _argumentAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _vocative, start, pos, perr)
fail:
	return _memoize(parser, _vocative, start, -1, perr)
}

func _vocativeNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_vocative]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _vocative}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "vocative"}
	// vocative_marker spaces? argument
	// vocative_marker
	if !_node(parser, _vocative_markerNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	// argument
	if !_node(parser, _argumentNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _vocativeFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _vocative, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "vocative",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _vocative}
	// vocative_marker spaces? argument
	// vocative_marker
	if !_fail(parser, _vocative_markerFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	// argument
	if !_fail(parser, _argumentFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _vocativeAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_vocative]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _vocative}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// vocative_marker spaces? argument
	{
		var node0 string
		// vocative_marker
		if p, n := _vocative_markerAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
		// argument
		if p, n := _argumentAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _prefixAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _prefix, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// MU freemod?
	// MU
	if !_accept(parser, _MUAccepts, &pos, &perr) {
		goto fail
	}
	// freemod?
	{
		pos2 := pos
		// freemod
		if !_accept(parser, _freemodAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	return _memoize(parser, _prefix, start, pos, perr)
fail:
	return _memoize(parser, _prefix, start, -1, perr)
}

func _prefixNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_prefix]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _prefix}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "prefix"}
	// MU freemod?
	// MU
	if !_node(parser, _MUNode, node, &pos) {
		goto fail
	}
	// freemod?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// freemod
		if !_node(parser, _freemodNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _prefixFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _prefix, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "prefix",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _prefix}
	// MU freemod?
	// MU
	if !_fail(parser, _MUFail, errPos, failure, &pos) {
		goto fail
	}
	// freemod?
	{
		pos2 := pos
		// freemod
		if !_fail(parser, _freemodFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _prefixAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_prefix]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _prefix}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// MU freemod?
	{
		var node0 string
		// MU
		if p, n := _MUAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// freemod?
		{
			pos2 := pos
			// freemod
			if p, n := _freemodAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _focusAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _focus, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// KU
	if !_accept(parser, _KUAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _focus, start, pos, perr)
fail:
	return _memoize(parser, _focus, start, -1, perr)
}

func _focusNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_focus]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _focus}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "focus"}
	// KU
	if !_node(parser, _KUNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _focusFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _focus, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "focus",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _focus}
	// KU
	if !_fail(parser, _KUFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _focusAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_focus]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _focus}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// KU
	if p, n := _KUAction(parser, pos); n == nil {
		goto fail
	} else {
		node = *n
		pos = p
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _function_wordAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _function_word, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// sentence_prefix/connective/start_incidental/start_parenthetical/end_parenthetical/quantifier/illocutionary/end_statement/end_prenex/LU/MI/PO/MO/TEO/GA/linking_word/vocative
	{
		pos2 := pos
		// sentence_prefix
		if !_accept(parser, _sentence_prefixAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// connective
		if !_accept(parser, _connectiveAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// start_incidental
		if !_accept(parser, _start_incidentalAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// start_parenthetical
		if !_accept(parser, _start_parentheticalAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// end_parenthetical
		if !_accept(parser, _end_parentheticalAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// quantifier
		if !_accept(parser, _quantifierAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// illocutionary
		if !_accept(parser, _illocutionaryAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// end_statement
		if !_accept(parser, _end_statementAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		// end_prenex
		if !_accept(parser, _end_prenexAccepts, &pos, &perr) {
			goto fail11
		}
		goto ok0
	fail11:
		pos = pos2
		// LU
		if !_accept(parser, _LUAccepts, &pos, &perr) {
			goto fail12
		}
		goto ok0
	fail12:
		pos = pos2
		// MI
		if !_accept(parser, _MIAccepts, &pos, &perr) {
			goto fail13
		}
		goto ok0
	fail13:
		pos = pos2
		// PO
		if !_accept(parser, _POAccepts, &pos, &perr) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// MO
		if !_accept(parser, _MOAccepts, &pos, &perr) {
			goto fail15
		}
		goto ok0
	fail15:
		pos = pos2
		// TEO
		if !_accept(parser, _TEOAccepts, &pos, &perr) {
			goto fail16
		}
		goto ok0
	fail16:
		pos = pos2
		// GA
		if !_accept(parser, _GAAccepts, &pos, &perr) {
			goto fail17
		}
		goto ok0
	fail17:
		pos = pos2
		// linking_word
		if !_accept(parser, _linking_wordAccepts, &pos, &perr) {
			goto fail18
		}
		goto ok0
	fail18:
		pos = pos2
		// vocative
		if !_accept(parser, _vocativeAccepts, &pos, &perr) {
			goto fail19
		}
		goto ok0
	fail19:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _function_word, start, pos, perr)
fail:
	return _memoize(parser, _function_word, start, -1, perr)
}

func _function_wordNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_function_word]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _function_word}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "function_word"}
	// sentence_prefix/connective/start_incidental/start_parenthetical/end_parenthetical/quantifier/illocutionary/end_statement/end_prenex/LU/MI/PO/MO/TEO/GA/linking_word/vocative
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// sentence_prefix
		if !_node(parser, _sentence_prefixNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// connective
		if !_node(parser, _connectiveNode, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// start_incidental
		if !_node(parser, _start_incidentalNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// start_parenthetical
		if !_node(parser, _start_parentheticalNode, node, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// end_parenthetical
		if !_node(parser, _end_parentheticalNode, node, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// quantifier
		if !_node(parser, _quantifierNode, node, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// illocutionary
		if !_node(parser, _illocutionaryNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// end_statement
		if !_node(parser, _end_statementNode, node, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// end_prenex
		if !_node(parser, _end_prenexNode, node, &pos) {
			goto fail11
		}
		goto ok0
	fail11:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// LU
		if !_node(parser, _LUNode, node, &pos) {
			goto fail12
		}
		goto ok0
	fail12:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// MI
		if !_node(parser, _MINode, node, &pos) {
			goto fail13
		}
		goto ok0
	fail13:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// PO
		if !_node(parser, _PONode, node, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// MO
		if !_node(parser, _MONode, node, &pos) {
			goto fail15
		}
		goto ok0
	fail15:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// TEO
		if !_node(parser, _TEONode, node, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// GA
		if !_node(parser, _GANode, node, &pos) {
			goto fail17
		}
		goto ok0
	fail17:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// linking_word
		if !_node(parser, _linking_wordNode, node, &pos) {
			goto fail18
		}
		goto ok0
	fail18:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// vocative
		if !_node(parser, _vocativeNode, node, &pos) {
			goto fail19
		}
		goto ok0
	fail19:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _function_wordFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _function_word, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "function_word",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _function_word}
	// sentence_prefix/connective/start_incidental/start_parenthetical/end_parenthetical/quantifier/illocutionary/end_statement/end_prenex/LU/MI/PO/MO/TEO/GA/linking_word/vocative
	{
		pos2 := pos
		// sentence_prefix
		if !_fail(parser, _sentence_prefixFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// connective
		if !_fail(parser, _connectiveFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// start_incidental
		if !_fail(parser, _start_incidentalFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// start_parenthetical
		if !_fail(parser, _start_parentheticalFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// end_parenthetical
		if !_fail(parser, _end_parentheticalFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// quantifier
		if !_fail(parser, _quantifierFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// illocutionary
		if !_fail(parser, _illocutionaryFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// end_statement
		if !_fail(parser, _end_statementFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		// end_prenex
		if !_fail(parser, _end_prenexFail, errPos, failure, &pos) {
			goto fail11
		}
		goto ok0
	fail11:
		pos = pos2
		// LU
		if !_fail(parser, _LUFail, errPos, failure, &pos) {
			goto fail12
		}
		goto ok0
	fail12:
		pos = pos2
		// MI
		if !_fail(parser, _MIFail, errPos, failure, &pos) {
			goto fail13
		}
		goto ok0
	fail13:
		pos = pos2
		// PO
		if !_fail(parser, _POFail, errPos, failure, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// MO
		if !_fail(parser, _MOFail, errPos, failure, &pos) {
			goto fail15
		}
		goto ok0
	fail15:
		pos = pos2
		// TEO
		if !_fail(parser, _TEOFail, errPos, failure, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		pos = pos2
		// GA
		if !_fail(parser, _GAFail, errPos, failure, &pos) {
			goto fail17
		}
		goto ok0
	fail17:
		pos = pos2
		// linking_word
		if !_fail(parser, _linking_wordFail, errPos, failure, &pos) {
			goto fail18
		}
		goto ok0
	fail18:
		pos = pos2
		// vocative
		if !_fail(parser, _vocativeFail, errPos, failure, &pos) {
			goto fail19
		}
		goto ok0
	fail19:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _function_wordAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_function_word]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _function_word}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// sentence_prefix/connective/start_incidental/start_parenthetical/end_parenthetical/quantifier/illocutionary/end_statement/end_prenex/LU/MI/PO/MO/TEO/GA/linking_word/vocative
	{
		pos2 := pos
		// sentence_prefix
		if p, n := _sentence_prefixAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// connective
		if p, n := _connectiveAction(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		// start_incidental
		if p, n := _start_incidentalAction(parser, pos); n == nil {
			goto fail5
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail5:
		pos = pos2
		// start_parenthetical
		if p, n := _start_parentheticalAction(parser, pos); n == nil {
			goto fail6
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail6:
		pos = pos2
		// end_parenthetical
		if p, n := _end_parentheticalAction(parser, pos); n == nil {
			goto fail7
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail7:
		pos = pos2
		// quantifier
		if p, n := _quantifierAction(parser, pos); n == nil {
			goto fail8
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail8:
		pos = pos2
		// illocutionary
		if p, n := _illocutionaryAction(parser, pos); n == nil {
			goto fail9
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail9:
		pos = pos2
		// end_statement
		if p, n := _end_statementAction(parser, pos); n == nil {
			goto fail10
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail10:
		pos = pos2
		// end_prenex
		if p, n := _end_prenexAction(parser, pos); n == nil {
			goto fail11
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail11:
		pos = pos2
		// LU
		if p, n := _LUAction(parser, pos); n == nil {
			goto fail12
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail12:
		pos = pos2
		// MI
		if p, n := _MIAction(parser, pos); n == nil {
			goto fail13
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail13:
		pos = pos2
		// PO
		if p, n := _POAction(parser, pos); n == nil {
			goto fail14
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail14:
		pos = pos2
		// MO
		if p, n := _MOAction(parser, pos); n == nil {
			goto fail15
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail15:
		pos = pos2
		// TEO
		if p, n := _TEOAction(parser, pos); n == nil {
			goto fail16
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail16:
		pos = pos2
		// GA
		if p, n := _GAAction(parser, pos); n == nil {
			goto fail17
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail17:
		pos = pos2
		// linking_word
		if p, n := _linking_wordAction(parser, pos); n == nil {
			goto fail18
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail18:
		pos = pos2
		// vocative
		if p, n := _vocativeAction(parser, pos); n == nil {
			goto fail19
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail19:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _LUAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _LU, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// (l U/l I/l O/m A/t I o) &(tone/boundary)
	// (l U/l I/l O/m A/t I o)
	// l U/l I/l O/m A/t I o
	{
		pos3 := pos
		// l U
		// l
		if !_accept(parser, _lAccepts, &pos, &perr) {
			goto fail4
		}
		// U
		if !_accept(parser, _UAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// l I
		// l
		if !_accept(parser, _lAccepts, &pos, &perr) {
			goto fail6
		}
		// I
		if !_accept(parser, _IAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok1
	fail6:
		pos = pos3
		// l O
		// l
		if !_accept(parser, _lAccepts, &pos, &perr) {
			goto fail8
		}
		// O
		if !_accept(parser, _OAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok1
	fail8:
		pos = pos3
		// m A
		// m
		if !_accept(parser, _mAccepts, &pos, &perr) {
			goto fail10
		}
		// A
		if !_accept(parser, _AAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok1
	fail10:
		pos = pos3
		// t I o
		// t
		if !_accept(parser, _tAccepts, &pos, &perr) {
			goto fail12
		}
		// I
		if !_accept(parser, _IAccepts, &pos, &perr) {
			goto fail12
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail12
		}
		goto ok1
	fail12:
		pos = pos3
		goto fail
	ok1:
	}
	// &(tone/boundary)
	{
		pos15 := pos
		perr17 := perr
		// (tone/boundary)
		// tone/boundary
		{
			pos21 := pos
			// tone
			if !_accept(parser, _toneAccepts, &pos, &perr) {
				goto fail22
			}
			goto ok19
		fail22:
			pos = pos21
			// boundary
			if !_accept(parser, _boundaryAccepts, &pos, &perr) {
				goto fail23
			}
			goto ok19
		fail23:
			pos = pos21
			goto fail18
		ok19:
		}
		goto ok14
	fail18:
		pos = pos15
		perr = _max(perr17, pos)
		goto fail
	ok14:
		pos = pos15
		perr = perr17
	}
	return _memoize(parser, _LU, start, pos, perr)
fail:
	return _memoize(parser, _LU, start, -1, perr)
}

func _LUNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_LU]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "LU"}
	// (l U/l I/l O/m A/t I o) &(tone/boundary)
	// (l U/l I/l O/m A/t I o)
	{
		nkids1 := len(node.Kids)
		pos02 := pos
		// l U/l I/l O/m A/t I o
		{
			pos5 := pos
			nkids4 := len(node.Kids)
			// l U
			// l
			if !_node(parser, _lNode, node, &pos) {
				goto fail6
			}
			// U
			if !_node(parser, _UNode, node, &pos) {
				goto fail6
			}
			goto ok3
		fail6:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// l I
			// l
			if !_node(parser, _lNode, node, &pos) {
				goto fail8
			}
			// I
			if !_node(parser, _INode, node, &pos) {
				goto fail8
			}
			goto ok3
		fail8:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// l O
			// l
			if !_node(parser, _lNode, node, &pos) {
				goto fail10
			}
			// O
			if !_node(parser, _ONode, node, &pos) {
				goto fail10
			}
			goto ok3
		fail10:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// m A
			// m
			if !_node(parser, _mNode, node, &pos) {
				goto fail12
			}
			// A
			if !_node(parser, _ANode, node, &pos) {
				goto fail12
			}
			goto ok3
		fail12:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// t I o
			// t
			if !_node(parser, _tNode, node, &pos) {
				goto fail14
			}
			// I
			if !_node(parser, _INode, node, &pos) {
				goto fail14
			}
			// o
			if !_node(parser, _oNode, node, &pos) {
				goto fail14
			}
			goto ok3
		fail14:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			goto fail
		ok3:
		}
		sub := _sub(parser, pos02, pos, node.Kids[nkids1:])
		node.Kids = append(node.Kids[:nkids1], sub)
	}
	// &(tone/boundary)
	{
		pos17 := pos
		nkids18 := len(node.Kids)
		// (tone/boundary)
		{
			nkids21 := len(node.Kids)
			pos022 := pos
			// tone/boundary
			{
				pos25 := pos
				nkids24 := len(node.Kids)
				// tone
				if !_node(parser, _toneNode, node, &pos) {
					goto fail26
				}
				goto ok23
			fail26:
				node.Kids = node.Kids[:nkids24]
				pos = pos25
				// boundary
				if !_node(parser, _boundaryNode, node, &pos) {
					goto fail27
				}
				goto ok23
			fail27:
				node.Kids = node.Kids[:nkids24]
				pos = pos25
				goto fail20
			ok23:
			}
			sub := _sub(parser, pos022, pos, node.Kids[nkids21:])
			node.Kids = append(node.Kids[:nkids21], sub)
		}
		goto ok16
	fail20:
		pos = pos17
		goto fail
	ok16:
		pos = pos17
		node.Kids = node.Kids[:nkids18]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _LUFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _LU, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "LU",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _LU}
	// (l U/l I/l O/m A/t I o) &(tone/boundary)
	// (l U/l I/l O/m A/t I o)
	// l U/l I/l O/m A/t I o
	{
		pos3 := pos
		// l U
		// l
		if !_fail(parser, _lFail, errPos, failure, &pos) {
			goto fail4
		}
		// U
		if !_fail(parser, _UFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// l I
		// l
		if !_fail(parser, _lFail, errPos, failure, &pos) {
			goto fail6
		}
		// I
		if !_fail(parser, _IFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok1
	fail6:
		pos = pos3
		// l O
		// l
		if !_fail(parser, _lFail, errPos, failure, &pos) {
			goto fail8
		}
		// O
		if !_fail(parser, _OFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok1
	fail8:
		pos = pos3
		// m A
		// m
		if !_fail(parser, _mFail, errPos, failure, &pos) {
			goto fail10
		}
		// A
		if !_fail(parser, _AFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok1
	fail10:
		pos = pos3
		// t I o
		// t
		if !_fail(parser, _tFail, errPos, failure, &pos) {
			goto fail12
		}
		// I
		if !_fail(parser, _IFail, errPos, failure, &pos) {
			goto fail12
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail12
		}
		goto ok1
	fail12:
		pos = pos3
		goto fail
	ok1:
	}
	// &(tone/boundary)
	{
		pos15 := pos
		nkids16 := len(failure.Kids)
		// (tone/boundary)
		// tone/boundary
		{
			pos21 := pos
			// tone
			if !_fail(parser, _toneFail, errPos, failure, &pos) {
				goto fail22
			}
			goto ok19
		fail22:
			pos = pos21
			// boundary
			if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
				goto fail23
			}
			goto ok19
		fail23:
			pos = pos21
			goto fail18
		ok19:
		}
		goto ok14
	fail18:
		pos = pos15
		failure.Kids = failure.Kids[:nkids16]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&(tone/boundary)",
			})
		}
		goto fail
	ok14:
		pos = pos15
		failure.Kids = failure.Kids[:nkids16]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _LUAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_LU]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _LU}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// (l U/l I/l O/m A/t I o) &(tone/boundary)
	{
		var node0 string
		// (l U/l I/l O/m A/t I o)
		// l U/l I/l O/m A/t I o
		{
			pos3 := pos
			// l U
			{
				var node5 string
				// l
				if p, n := _lAction(parser, pos); n == nil {
					goto fail4
				} else {
					node5 = *n
					pos = p
				}
				node0 += node5
				// U
				if p, n := _UAction(parser, pos); n == nil {
					goto fail4
				} else {
					node5 = *n
					pos = p
				}
				node0 += node5
			}
			goto ok1
		fail4:
			pos = pos3
			// l I
			{
				var node7 string
				// l
				if p, n := _lAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
				// I
				if p, n := _IAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
			}
			goto ok1
		fail6:
			pos = pos3
			// l O
			{
				var node9 string
				// l
				if p, n := _lAction(parser, pos); n == nil {
					goto fail8
				} else {
					node9 = *n
					pos = p
				}
				node0 += node9
				// O
				if p, n := _OAction(parser, pos); n == nil {
					goto fail8
				} else {
					node9 = *n
					pos = p
				}
				node0 += node9
			}
			goto ok1
		fail8:
			pos = pos3
			// m A
			{
				var node11 string
				// m
				if p, n := _mAction(parser, pos); n == nil {
					goto fail10
				} else {
					node11 = *n
					pos = p
				}
				node0 += node11
				// A
				if p, n := _AAction(parser, pos); n == nil {
					goto fail10
				} else {
					node11 = *n
					pos = p
				}
				node0 += node11
			}
			goto ok1
		fail10:
			pos = pos3
			// t I o
			{
				var node13 string
				// t
				if p, n := _tAction(parser, pos); n == nil {
					goto fail12
				} else {
					node13 = *n
					pos = p
				}
				node0 += node13
				// I
				if p, n := _IAction(parser, pos); n == nil {
					goto fail12
				} else {
					node13 = *n
					pos = p
				}
				node0 += node13
				// o
				if p, n := _oAction(parser, pos); n == nil {
					goto fail12
				} else {
					node13 = *n
					pos = p
				}
				node0 += node13
			}
			goto ok1
		fail12:
			pos = pos3
			goto fail
		ok1:
		}
		node += node0
		// &(tone/boundary)
		{
			pos15 := pos
			// (tone/boundary)
			// tone/boundary
			{
				pos21 := pos
				// tone
				if p, n := _toneAction(parser, pos); n == nil {
					goto fail22
				} else {
					pos = p
				}
				goto ok19
			fail22:
				pos = pos21
				// boundary
				if p, n := _boundaryAction(parser, pos); n == nil {
					goto fail23
				} else {
					pos = p
				}
				goto ok19
			fail23:
				pos = pos21
				goto fail18
			ok19:
			}
			goto ok14
		fail18:
			pos = pos15
			goto fail
		ok14:
			pos = pos15
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MIAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MI, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// (m I/s h U) &(tone/boundary)
	// (m I/s h U)
	// m I/s h U
	{
		pos3 := pos
		// m I
		// m
		if !_accept(parser, _mAccepts, &pos, &perr) {
			goto fail4
		}
		// I
		if !_accept(parser, _IAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// s h U
		// s
		if !_accept(parser, _sAccepts, &pos, &perr) {
			goto fail6
		}
		// h
		if !_accept(parser, _hAccepts, &pos, &perr) {
			goto fail6
		}
		// U
		if !_accept(parser, _UAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok1
	fail6:
		pos = pos3
		goto fail
	ok1:
	}
	// &(tone/boundary)
	{
		pos9 := pos
		perr11 := perr
		// (tone/boundary)
		// tone/boundary
		{
			pos15 := pos
			// tone
			if !_accept(parser, _toneAccepts, &pos, &perr) {
				goto fail16
			}
			goto ok13
		fail16:
			pos = pos15
			// boundary
			if !_accept(parser, _boundaryAccepts, &pos, &perr) {
				goto fail17
			}
			goto ok13
		fail17:
			pos = pos15
			goto fail12
		ok13:
		}
		goto ok8
	fail12:
		pos = pos9
		perr = _max(perr11, pos)
		goto fail
	ok8:
		pos = pos9
		perr = perr11
	}
	return _memoize(parser, _MI, start, pos, perr)
fail:
	return _memoize(parser, _MI, start, -1, perr)
}

func _MINode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MI]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MI"}
	// (m I/s h U) &(tone/boundary)
	// (m I/s h U)
	{
		nkids1 := len(node.Kids)
		pos02 := pos
		// m I/s h U
		{
			pos5 := pos
			nkids4 := len(node.Kids)
			// m I
			// m
			if !_node(parser, _mNode, node, &pos) {
				goto fail6
			}
			// I
			if !_node(parser, _INode, node, &pos) {
				goto fail6
			}
			goto ok3
		fail6:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// s h U
			// s
			if !_node(parser, _sNode, node, &pos) {
				goto fail8
			}
			// h
			if !_node(parser, _hNode, node, &pos) {
				goto fail8
			}
			// U
			if !_node(parser, _UNode, node, &pos) {
				goto fail8
			}
			goto ok3
		fail8:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			goto fail
		ok3:
		}
		sub := _sub(parser, pos02, pos, node.Kids[nkids1:])
		node.Kids = append(node.Kids[:nkids1], sub)
	}
	// &(tone/boundary)
	{
		pos11 := pos
		nkids12 := len(node.Kids)
		// (tone/boundary)
		{
			nkids15 := len(node.Kids)
			pos016 := pos
			// tone/boundary
			{
				pos19 := pos
				nkids18 := len(node.Kids)
				// tone
				if !_node(parser, _toneNode, node, &pos) {
					goto fail20
				}
				goto ok17
			fail20:
				node.Kids = node.Kids[:nkids18]
				pos = pos19
				// boundary
				if !_node(parser, _boundaryNode, node, &pos) {
					goto fail21
				}
				goto ok17
			fail21:
				node.Kids = node.Kids[:nkids18]
				pos = pos19
				goto fail14
			ok17:
			}
			sub := _sub(parser, pos016, pos, node.Kids[nkids15:])
			node.Kids = append(node.Kids[:nkids15], sub)
		}
		goto ok10
	fail14:
		pos = pos11
		goto fail
	ok10:
		pos = pos11
		node.Kids = node.Kids[:nkids12]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MIFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MI, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MI",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MI}
	// (m I/s h U) &(tone/boundary)
	// (m I/s h U)
	// m I/s h U
	{
		pos3 := pos
		// m I
		// m
		if !_fail(parser, _mFail, errPos, failure, &pos) {
			goto fail4
		}
		// I
		if !_fail(parser, _IFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// s h U
		// s
		if !_fail(parser, _sFail, errPos, failure, &pos) {
			goto fail6
		}
		// h
		if !_fail(parser, _hFail, errPos, failure, &pos) {
			goto fail6
		}
		// U
		if !_fail(parser, _UFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok1
	fail6:
		pos = pos3
		goto fail
	ok1:
	}
	// &(tone/boundary)
	{
		pos9 := pos
		nkids10 := len(failure.Kids)
		// (tone/boundary)
		// tone/boundary
		{
			pos15 := pos
			// tone
			if !_fail(parser, _toneFail, errPos, failure, &pos) {
				goto fail16
			}
			goto ok13
		fail16:
			pos = pos15
			// boundary
			if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
				goto fail17
			}
			goto ok13
		fail17:
			pos = pos15
			goto fail12
		ok13:
		}
		goto ok8
	fail12:
		pos = pos9
		failure.Kids = failure.Kids[:nkids10]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&(tone/boundary)",
			})
		}
		goto fail
	ok8:
		pos = pos9
		failure.Kids = failure.Kids[:nkids10]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MIAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MI]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MI}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// (m I/s h U) &(tone/boundary)
	{
		var node0 string
		// (m I/s h U)
		// m I/s h U
		{
			pos3 := pos
			// m I
			{
				var node5 string
				// m
				if p, n := _mAction(parser, pos); n == nil {
					goto fail4
				} else {
					node5 = *n
					pos = p
				}
				node0 += node5
				// I
				if p, n := _IAction(parser, pos); n == nil {
					goto fail4
				} else {
					node5 = *n
					pos = p
				}
				node0 += node5
			}
			goto ok1
		fail4:
			pos = pos3
			// s h U
			{
				var node7 string
				// s
				if p, n := _sAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
				// h
				if p, n := _hAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
				// U
				if p, n := _UAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
			}
			goto ok1
		fail6:
			pos = pos3
			goto fail
		ok1:
		}
		node += node0
		// &(tone/boundary)
		{
			pos9 := pos
			// (tone/boundary)
			// tone/boundary
			{
				pos15 := pos
				// tone
				if p, n := _toneAction(parser, pos); n == nil {
					goto fail16
				} else {
					pos = p
				}
				goto ok13
			fail16:
				pos = pos15
				// boundary
				if p, n := _boundaryAction(parser, pos); n == nil {
					goto fail17
				} else {
					pos = p
				}
				goto ok13
			fail17:
				pos = pos15
				goto fail12
			ok13:
			}
			goto ok8
		fail12:
			pos = pos9
			goto fail
		ok8:
			pos = pos9
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _POAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _PO, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// (p O/p E) &(tone/boundary)
	// (p O/p E)
	// p O/p E
	{
		pos3 := pos
		// p O
		// p
		if !_accept(parser, _pAccepts, &pos, &perr) {
			goto fail4
		}
		// O
		if !_accept(parser, _OAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// p E
		// p
		if !_accept(parser, _pAccepts, &pos, &perr) {
			goto fail6
		}
		// E
		if !_accept(parser, _EAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok1
	fail6:
		pos = pos3
		goto fail
	ok1:
	}
	// &(tone/boundary)
	{
		pos9 := pos
		perr11 := perr
		// (tone/boundary)
		// tone/boundary
		{
			pos15 := pos
			// tone
			if !_accept(parser, _toneAccepts, &pos, &perr) {
				goto fail16
			}
			goto ok13
		fail16:
			pos = pos15
			// boundary
			if !_accept(parser, _boundaryAccepts, &pos, &perr) {
				goto fail17
			}
			goto ok13
		fail17:
			pos = pos15
			goto fail12
		ok13:
		}
		goto ok8
	fail12:
		pos = pos9
		perr = _max(perr11, pos)
		goto fail
	ok8:
		pos = pos9
		perr = perr11
	}
	return _memoize(parser, _PO, start, pos, perr)
fail:
	return _memoize(parser, _PO, start, -1, perr)
}

func _PONode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_PO]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "PO"}
	// (p O/p E) &(tone/boundary)
	// (p O/p E)
	{
		nkids1 := len(node.Kids)
		pos02 := pos
		// p O/p E
		{
			pos5 := pos
			nkids4 := len(node.Kids)
			// p O
			// p
			if !_node(parser, _pNode, node, &pos) {
				goto fail6
			}
			// O
			if !_node(parser, _ONode, node, &pos) {
				goto fail6
			}
			goto ok3
		fail6:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// p E
			// p
			if !_node(parser, _pNode, node, &pos) {
				goto fail8
			}
			// E
			if !_node(parser, _ENode, node, &pos) {
				goto fail8
			}
			goto ok3
		fail8:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			goto fail
		ok3:
		}
		sub := _sub(parser, pos02, pos, node.Kids[nkids1:])
		node.Kids = append(node.Kids[:nkids1], sub)
	}
	// &(tone/boundary)
	{
		pos11 := pos
		nkids12 := len(node.Kids)
		// (tone/boundary)
		{
			nkids15 := len(node.Kids)
			pos016 := pos
			// tone/boundary
			{
				pos19 := pos
				nkids18 := len(node.Kids)
				// tone
				if !_node(parser, _toneNode, node, &pos) {
					goto fail20
				}
				goto ok17
			fail20:
				node.Kids = node.Kids[:nkids18]
				pos = pos19
				// boundary
				if !_node(parser, _boundaryNode, node, &pos) {
					goto fail21
				}
				goto ok17
			fail21:
				node.Kids = node.Kids[:nkids18]
				pos = pos19
				goto fail14
			ok17:
			}
			sub := _sub(parser, pos016, pos, node.Kids[nkids15:])
			node.Kids = append(node.Kids[:nkids15], sub)
		}
		goto ok10
	fail14:
		pos = pos11
		goto fail
	ok10:
		pos = pos11
		node.Kids = node.Kids[:nkids12]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _POFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _PO, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "PO",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _PO}
	// (p O/p E) &(tone/boundary)
	// (p O/p E)
	// p O/p E
	{
		pos3 := pos
		// p O
		// p
		if !_fail(parser, _pFail, errPos, failure, &pos) {
			goto fail4
		}
		// O
		if !_fail(parser, _OFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// p E
		// p
		if !_fail(parser, _pFail, errPos, failure, &pos) {
			goto fail6
		}
		// E
		if !_fail(parser, _EFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok1
	fail6:
		pos = pos3
		goto fail
	ok1:
	}
	// &(tone/boundary)
	{
		pos9 := pos
		nkids10 := len(failure.Kids)
		// (tone/boundary)
		// tone/boundary
		{
			pos15 := pos
			// tone
			if !_fail(parser, _toneFail, errPos, failure, &pos) {
				goto fail16
			}
			goto ok13
		fail16:
			pos = pos15
			// boundary
			if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
				goto fail17
			}
			goto ok13
		fail17:
			pos = pos15
			goto fail12
		ok13:
		}
		goto ok8
	fail12:
		pos = pos9
		failure.Kids = failure.Kids[:nkids10]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&(tone/boundary)",
			})
		}
		goto fail
	ok8:
		pos = pos9
		failure.Kids = failure.Kids[:nkids10]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _POAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_PO]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _PO}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// (p O/p E) &(tone/boundary)
	{
		var node0 string
		// (p O/p E)
		// p O/p E
		{
			pos3 := pos
			// p O
			{
				var node5 string
				// p
				if p, n := _pAction(parser, pos); n == nil {
					goto fail4
				} else {
					node5 = *n
					pos = p
				}
				node0 += node5
				// O
				if p, n := _OAction(parser, pos); n == nil {
					goto fail4
				} else {
					node5 = *n
					pos = p
				}
				node0 += node5
			}
			goto ok1
		fail4:
			pos = pos3
			// p E
			{
				var node7 string
				// p
				if p, n := _pAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
				// E
				if p, n := _EAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
			}
			goto ok1
		fail6:
			pos = pos3
			goto fail
		ok1:
		}
		node += node0
		// &(tone/boundary)
		{
			pos9 := pos
			// (tone/boundary)
			// tone/boundary
			{
				pos15 := pos
				// tone
				if p, n := _toneAction(parser, pos); n == nil {
					goto fail16
				} else {
					pos = p
				}
				goto ok13
			fail16:
				pos = pos15
				// boundary
				if p, n := _boundaryAction(parser, pos); n == nil {
					goto fail17
				} else {
					pos = p
				}
				goto ok13
			fail17:
				pos = pos15
				goto fail12
			ok13:
			}
			goto ok8
		fail12:
			pos = pos9
			goto fail
		ok8:
			pos = pos9
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MOAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MO, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// m O &(tone/boundary)
	// m
	if !_accept(parser, _mAccepts, &pos, &perr) {
		goto fail
	}
	// O
	if !_accept(parser, _OAccepts, &pos, &perr) {
		goto fail
	}
	// &(tone/boundary)
	{
		pos2 := pos
		perr4 := perr
		// (tone/boundary)
		// tone/boundary
		{
			pos8 := pos
			// tone
			if !_accept(parser, _toneAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// boundary
			if !_accept(parser, _boundaryAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail5
		ok6:
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	return _memoize(parser, _MO, start, pos, perr)
fail:
	return _memoize(parser, _MO, start, -1, perr)
}

func _MONode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MO]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MO"}
	// m O &(tone/boundary)
	// m
	if !_node(parser, _mNode, node, &pos) {
		goto fail
	}
	// O
	if !_node(parser, _ONode, node, &pos) {
		goto fail
	}
	// &(tone/boundary)
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// (tone/boundary)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// tone/boundary
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// tone
				if !_node(parser, _toneNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// boundary
				if !_node(parser, _boundaryNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail5
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MOFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MO, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MO",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MO}
	// m O &(tone/boundary)
	// m
	if !_fail(parser, _mFail, errPos, failure, &pos) {
		goto fail
	}
	// O
	if !_fail(parser, _OFail, errPos, failure, &pos) {
		goto fail
	}
	// &(tone/boundary)
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// (tone/boundary)
		// tone/boundary
		{
			pos8 := pos
			// tone
			if !_fail(parser, _toneFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// boundary
			if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail5
		ok6:
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&(tone/boundary)",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MOAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MO]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MO}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// m O &(tone/boundary)
	{
		var node0 string
		// m
		if p, n := _mAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// O
		if p, n := _OAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// &(tone/boundary)
		{
			pos2 := pos
			// (tone/boundary)
			// tone/boundary
			{
				pos8 := pos
				// tone
				if p, n := _toneAction(parser, pos); n == nil {
					goto fail9
				} else {
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// boundary
				if p, n := _boundaryAction(parser, pos); n == nil {
					goto fail10
				} else {
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail5
			ok6:
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _TEOAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _TEO, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// t e o &boundary
	// t
	if !_accept(parser, _tAccepts, &pos, &perr) {
		goto fail
	}
	// e
	if !_accept(parser, _eAccepts, &pos, &perr) {
		goto fail
	}
	// o
	if !_accept(parser, _oAccepts, &pos, &perr) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		perr4 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	return _memoize(parser, _TEO, start, pos, perr)
fail:
	return _memoize(parser, _TEO, start, -1, perr)
}

func _TEONode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_TEO]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _TEO}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "TEO"}
	// t e o &boundary
	// t
	if !_node(parser, _tNode, node, &pos) {
		goto fail
	}
	// e
	if !_node(parser, _eNode, node, &pos) {
		goto fail
	}
	// o
	if !_node(parser, _oNode, node, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _TEOFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _TEO, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "TEO",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _TEO}
	// t e o &boundary
	// t
	if !_fail(parser, _tFail, errPos, failure, &pos) {
		goto fail
	}
	// e
	if !_fail(parser, _eFail, errPos, failure, &pos) {
		goto fail
	}
	// o
	if !_fail(parser, _oFail, errPos, failure, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _TEOAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_TEO]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _TEO}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// t e o &boundary
	{
		var node0 string
		// t
		if p, n := _tAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// e
		if p, n := _eAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// o
		if p, n := _oAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// &boundary
		{
			pos2 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _GAAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _GA, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// g a &boundary
	// g
	if !_accept(parser, _gAccepts, &pos, &perr) {
		goto fail
	}
	// a
	if !_accept(parser, _aAccepts, &pos, &perr) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		perr4 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	return _memoize(parser, _GA, start, pos, perr)
fail:
	return _memoize(parser, _GA, start, -1, perr)
}

func _GANode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_GA]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _GA}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "GA"}
	// g a &boundary
	// g
	if !_node(parser, _gNode, node, &pos) {
		goto fail
	}
	// a
	if !_node(parser, _aNode, node, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _GAFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _GA, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "GA",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _GA}
	// g a &boundary
	// g
	if !_fail(parser, _gFail, errPos, failure, &pos) {
		goto fail
	}
	// a
	if !_fail(parser, _aFail, errPos, failure, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _GAAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_GA]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _GA}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// g a &boundary
	{
		var node0 string
		// g
		if p, n := _gAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// a
		if p, n := _aAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// &boundary
		{
			pos2 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _NAAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _NA, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// n a &boundary
	// n
	if !_accept(parser, _nAccepts, &pos, &perr) {
		goto fail
	}
	// a
	if !_accept(parser, _aAccepts, &pos, &perr) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		perr4 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	return _memoize(parser, _NA, start, pos, perr)
fail:
	return _memoize(parser, _NA, start, -1, perr)
}

func _NANode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_NA]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _NA}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "NA"}
	// n a &boundary
	// n
	if !_node(parser, _nNode, node, &pos) {
		goto fail
	}
	// a
	if !_node(parser, _aNode, node, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _NAFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _NA, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "NA",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _NA}
	// n a &boundary
	// n
	if !_fail(parser, _nFail, errPos, failure, &pos) {
		goto fail
	}
	// a
	if !_fail(parser, _aFail, errPos, failure, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _NAAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_NA]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _NA}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// n a &boundary
	{
		var node0 string
		// n
		if p, n := _nAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// a
		if p, n := _aAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// &boundary
		{
			pos2 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _MUAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _MU, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// m u &boundary
	// m
	if !_accept(parser, _mAccepts, &pos, &perr) {
		goto fail
	}
	// u
	if !_accept(parser, _uAccepts, &pos, &perr) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		perr4 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	return _memoize(parser, _MU, start, pos, perr)
fail:
	return _memoize(parser, _MU, start, -1, perr)
}

func _MUNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_MU]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MU}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "MU"}
	// m u &boundary
	// m
	if !_node(parser, _mNode, node, &pos) {
		goto fail
	}
	// u
	if !_node(parser, _uNode, node, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _MUFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _MU, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "MU",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _MU}
	// m u &boundary
	// m
	if !_fail(parser, _mFail, errPos, failure, &pos) {
		goto fail
	}
	// u
	if !_fail(parser, _uFail, errPos, failure, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _MUAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_MU]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _MU}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// m u &boundary
	{
		var node0 string
		// m
		if p, n := _mAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// u
		if p, n := _uAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// &boundary
		{
			pos2 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _KUAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _KU, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// k u &boundary
	// k
	if !_accept(parser, _kAccepts, &pos, &perr) {
		goto fail
	}
	// u
	if !_accept(parser, _uAccepts, &pos, &perr) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		perr4 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	return _memoize(parser, _KU, start, pos, perr)
fail:
	return _memoize(parser, _KU, start, -1, perr)
}

func _KUNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_KU]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _KU}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "KU"}
	// k u &boundary
	// k
	if !_node(parser, _kNode, node, &pos) {
		goto fail
	}
	// u
	if !_node(parser, _uNode, node, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _KUFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _KU, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "KU",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _KU}
	// k u &boundary
	// k
	if !_fail(parser, _kFail, errPos, failure, &pos) {
		goto fail
	}
	// u
	if !_fail(parser, _uFail, errPos, failure, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _KUAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_KU]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _KU}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// k u &boundary
	{
		var node0 string
		// k
		if p, n := _kAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// u
		if p, n := _uAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// &boundary
		{
			pos2 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _end_prenexAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _end_prenex, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// (b i/p a) &boundary
	// (b i/p a)
	// b i/p a
	{
		pos3 := pos
		// b i
		// b
		if !_accept(parser, _bAccepts, &pos, &perr) {
			goto fail4
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// p a
		// p
		if !_accept(parser, _pAccepts, &pos, &perr) {
			goto fail6
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok1
	fail6:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos9 := pos
		perr11 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail12
		}
		goto ok8
	fail12:
		pos = pos9
		perr = _max(perr11, pos)
		goto fail
	ok8:
		pos = pos9
		perr = perr11
	}
	return _memoize(parser, _end_prenex, start, pos, perr)
fail:
	return _memoize(parser, _end_prenex, start, -1, perr)
}

func _end_prenexNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_end_prenex]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _end_prenex}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "end_prenex"}
	// (b i/p a) &boundary
	// (b i/p a)
	{
		nkids1 := len(node.Kids)
		pos02 := pos
		// b i/p a
		{
			pos5 := pos
			nkids4 := len(node.Kids)
			// b i
			// b
			if !_node(parser, _bNode, node, &pos) {
				goto fail6
			}
			// i
			if !_node(parser, _iNode, node, &pos) {
				goto fail6
			}
			goto ok3
		fail6:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// p a
			// p
			if !_node(parser, _pNode, node, &pos) {
				goto fail8
			}
			// a
			if !_node(parser, _aNode, node, &pos) {
				goto fail8
			}
			goto ok3
		fail8:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			goto fail
		ok3:
		}
		sub := _sub(parser, pos02, pos, node.Kids[nkids1:])
		node.Kids = append(node.Kids[:nkids1], sub)
	}
	// &boundary
	{
		pos11 := pos
		nkids12 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail14
		}
		goto ok10
	fail14:
		pos = pos11
		goto fail
	ok10:
		pos = pos11
		node.Kids = node.Kids[:nkids12]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _end_prenexFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _end_prenex, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "end_prenex",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _end_prenex}
	// (b i/p a) &boundary
	// (b i/p a)
	// b i/p a
	{
		pos3 := pos
		// b i
		// b
		if !_fail(parser, _bFail, errPos, failure, &pos) {
			goto fail4
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// p a
		// p
		if !_fail(parser, _pFail, errPos, failure, &pos) {
			goto fail6
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok1
	fail6:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos9 := pos
		nkids10 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail12
		}
		goto ok8
	fail12:
		pos = pos9
		failure.Kids = failure.Kids[:nkids10]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok8:
		pos = pos9
		failure.Kids = failure.Kids[:nkids10]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _end_prenexAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_end_prenex]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _end_prenex}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// (b i/p a) &boundary
	{
		var node0 string
		// (b i/p a)
		// b i/p a
		{
			pos3 := pos
			// b i
			{
				var node5 string
				// b
				if p, n := _bAction(parser, pos); n == nil {
					goto fail4
				} else {
					node5 = *n
					pos = p
				}
				node0 += node5
				// i
				if p, n := _iAction(parser, pos); n == nil {
					goto fail4
				} else {
					node5 = *n
					pos = p
				}
				node0 += node5
			}
			goto ok1
		fail4:
			pos = pos3
			// p a
			{
				var node7 string
				// p
				if p, n := _pAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
				// a
				if p, n := _aAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
			}
			goto ok1
		fail6:
			pos = pos3
			goto fail
		ok1:
		}
		node += node0
		// &boundary
		{
			pos9 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail12
			} else {
				pos = p
			}
			goto ok8
		fail12:
			pos = pos9
			goto fail
		ok8:
			pos = pos9
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _start_incidentalAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _start_incidental, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// j u &boundary
	// j
	if !_accept(parser, _jAccepts, &pos, &perr) {
		goto fail
	}
	// u
	if !_accept(parser, _uAccepts, &pos, &perr) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		perr4 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	return _memoize(parser, _start_incidental, start, pos, perr)
fail:
	return _memoize(parser, _start_incidental, start, -1, perr)
}

func _start_incidentalNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_start_incidental]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _start_incidental}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "start_incidental"}
	// j u &boundary
	// j
	if !_node(parser, _jNode, node, &pos) {
		goto fail
	}
	// u
	if !_node(parser, _uNode, node, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _start_incidentalFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _start_incidental, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "start_incidental",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _start_incidental}
	// j u &boundary
	// j
	if !_fail(parser, _jFail, errPos, failure, &pos) {
		goto fail
	}
	// u
	if !_fail(parser, _uFail, errPos, failure, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _start_incidentalAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_start_incidental]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _start_incidental}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// j u &boundary
	{
		var node0 string
		// j
		if p, n := _jAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// u
		if p, n := _uAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// &boundary
		{
			pos2 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _start_parentheticalAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _start_parenthetical, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// k i o &boundary
	// k
	if !_accept(parser, _kAccepts, &pos, &perr) {
		goto fail
	}
	// i
	if !_accept(parser, _iAccepts, &pos, &perr) {
		goto fail
	}
	// o
	if !_accept(parser, _oAccepts, &pos, &perr) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		perr4 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	return _memoize(parser, _start_parenthetical, start, pos, perr)
fail:
	return _memoize(parser, _start_parenthetical, start, -1, perr)
}

func _start_parentheticalNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_start_parenthetical]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _start_parenthetical}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "start_parenthetical"}
	// k i o &boundary
	// k
	if !_node(parser, _kNode, node, &pos) {
		goto fail
	}
	// i
	if !_node(parser, _iNode, node, &pos) {
		goto fail
	}
	// o
	if !_node(parser, _oNode, node, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _start_parentheticalFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _start_parenthetical, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "start_parenthetical",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _start_parenthetical}
	// k i o &boundary
	// k
	if !_fail(parser, _kFail, errPos, failure, &pos) {
		goto fail
	}
	// i
	if !_fail(parser, _iFail, errPos, failure, &pos) {
		goto fail
	}
	// o
	if !_fail(parser, _oFail, errPos, failure, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _start_parentheticalAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_start_parenthetical]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _start_parenthetical}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// k i o &boundary
	{
		var node0 string
		// k
		if p, n := _kAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// i
		if p, n := _iAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// o
		if p, n := _oAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// &boundary
		{
			pos2 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _end_parentheticalAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _end_parenthetical, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// k i &boundary
	// k
	if !_accept(parser, _kAccepts, &pos, &perr) {
		goto fail
	}
	// i
	if !_accept(parser, _iAccepts, &pos, &perr) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		perr4 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	return _memoize(parser, _end_parenthetical, start, pos, perr)
fail:
	return _memoize(parser, _end_parenthetical, start, -1, perr)
}

func _end_parentheticalNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_end_parenthetical]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _end_parenthetical}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "end_parenthetical"}
	// k i &boundary
	// k
	if !_node(parser, _kNode, node, &pos) {
		goto fail
	}
	// i
	if !_node(parser, _iNode, node, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _end_parentheticalFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _end_parenthetical, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "end_parenthetical",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _end_parenthetical}
	// k i &boundary
	// k
	if !_fail(parser, _kFail, errPos, failure, &pos) {
		goto fail
	}
	// i
	if !_fail(parser, _iFail, errPos, failure, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _end_parentheticalAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_end_parenthetical]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _end_parenthetical}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// k i &boundary
	{
		var node0 string
		// k
		if p, n := _kAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// i
		if p, n := _iAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// &boundary
		{
			pos2 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _vocative_markerAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _vocative_marker, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// h u &boundary
	// h
	if !_accept(parser, _hAccepts, &pos, &perr) {
		goto fail
	}
	// u
	if !_accept(parser, _uAccepts, &pos, &perr) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		perr4 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		perr = _max(perr4, pos)
		goto fail
	ok1:
		pos = pos2
		perr = perr4
	}
	return _memoize(parser, _vocative_marker, start, pos, perr)
fail:
	return _memoize(parser, _vocative_marker, start, -1, perr)
}

func _vocative_markerNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_vocative_marker]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _vocative_marker}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "vocative_marker"}
	// h u &boundary
	// h
	if !_node(parser, _hNode, node, &pos) {
		goto fail
	}
	// u
	if !_node(parser, _uNode, node, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		goto fail
	ok1:
		pos = pos2
		node.Kids = node.Kids[:nkids3]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _vocative_markerFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _vocative_marker, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "vocative_marker",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _vocative_marker}
	// h u &boundary
	// h
	if !_fail(parser, _hFail, errPos, failure, &pos) {
		goto fail
	}
	// u
	if !_fail(parser, _uFail, errPos, failure, &pos) {
		goto fail
	}
	// &boundary
	{
		pos2 := pos
		nkids3 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok1:
		pos = pos2
		failure.Kids = failure.Kids[:nkids3]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _vocative_markerAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_vocative_marker]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _vocative_marker}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// h u &boundary
	{
		var node0 string
		// h
		if p, n := _hAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// u
		if p, n := _uAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// &boundary
		{
			pos2 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail5
			} else {
				pos = p
			}
			goto ok1
		fail5:
			pos = pos2
			goto fail
		ok1:
			pos = pos2
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _linking_wordAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _linking_word, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// (f i/g o/c u/k e) &boundary
	// (f i/g o/c u/k e)
	// f i/g o/c u/k e
	{
		pos3 := pos
		// f i
		// f
		if !_accept(parser, _fAccepts, &pos, &perr) {
			goto fail4
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// g o
		// g
		if !_accept(parser, _gAccepts, &pos, &perr) {
			goto fail6
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok1
	fail6:
		pos = pos3
		// c u
		// c
		if !_accept(parser, _cAccepts, &pos, &perr) {
			goto fail8
		}
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok1
	fail8:
		pos = pos3
		// k e
		// k
		if !_accept(parser, _kAccepts, &pos, &perr) {
			goto fail10
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok1
	fail10:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos13 := pos
		perr15 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail16
		}
		goto ok12
	fail16:
		pos = pos13
		perr = _max(perr15, pos)
		goto fail
	ok12:
		pos = pos13
		perr = perr15
	}
	return _memoize(parser, _linking_word, start, pos, perr)
fail:
	return _memoize(parser, _linking_word, start, -1, perr)
}

func _linking_wordNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_linking_word]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _linking_word}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "linking_word"}
	// (f i/g o/c u/k e) &boundary
	// (f i/g o/c u/k e)
	{
		nkids1 := len(node.Kids)
		pos02 := pos
		// f i/g o/c u/k e
		{
			pos5 := pos
			nkids4 := len(node.Kids)
			// f i
			// f
			if !_node(parser, _fNode, node, &pos) {
				goto fail6
			}
			// i
			if !_node(parser, _iNode, node, &pos) {
				goto fail6
			}
			goto ok3
		fail6:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// g o
			// g
			if !_node(parser, _gNode, node, &pos) {
				goto fail8
			}
			// o
			if !_node(parser, _oNode, node, &pos) {
				goto fail8
			}
			goto ok3
		fail8:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// c u
			// c
			if !_node(parser, _cNode, node, &pos) {
				goto fail10
			}
			// u
			if !_node(parser, _uNode, node, &pos) {
				goto fail10
			}
			goto ok3
		fail10:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// k e
			// k
			if !_node(parser, _kNode, node, &pos) {
				goto fail12
			}
			// e
			if !_node(parser, _eNode, node, &pos) {
				goto fail12
			}
			goto ok3
		fail12:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			goto fail
		ok3:
		}
		sub := _sub(parser, pos02, pos, node.Kids[nkids1:])
		node.Kids = append(node.Kids[:nkids1], sub)
	}
	// &boundary
	{
		pos15 := pos
		nkids16 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail18
		}
		goto ok14
	fail18:
		pos = pos15
		goto fail
	ok14:
		pos = pos15
		node.Kids = node.Kids[:nkids16]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _linking_wordFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _linking_word, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "linking_word",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _linking_word}
	// (f i/g o/c u/k e) &boundary
	// (f i/g o/c u/k e)
	// f i/g o/c u/k e
	{
		pos3 := pos
		// f i
		// f
		if !_fail(parser, _fFail, errPos, failure, &pos) {
			goto fail4
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// g o
		// g
		if !_fail(parser, _gFail, errPos, failure, &pos) {
			goto fail6
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok1
	fail6:
		pos = pos3
		// c u
		// c
		if !_fail(parser, _cFail, errPos, failure, &pos) {
			goto fail8
		}
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok1
	fail8:
		pos = pos3
		// k e
		// k
		if !_fail(parser, _kFail, errPos, failure, &pos) {
			goto fail10
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok1
	fail10:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos13 := pos
		nkids14 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail16
		}
		goto ok12
	fail16:
		pos = pos13
		failure.Kids = failure.Kids[:nkids14]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok12:
		pos = pos13
		failure.Kids = failure.Kids[:nkids14]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _linking_wordAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_linking_word]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _linking_word}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// (f i/g o/c u/k e) &boundary
	{
		var node0 string
		// (f i/g o/c u/k e)
		// f i/g o/c u/k e
		{
			pos3 := pos
			// f i
			{
				var node5 string
				// f
				if p, n := _fAction(parser, pos); n == nil {
					goto fail4
				} else {
					node5 = *n
					pos = p
				}
				node0 += node5
				// i
				if p, n := _iAction(parser, pos); n == nil {
					goto fail4
				} else {
					node5 = *n
					pos = p
				}
				node0 += node5
			}
			goto ok1
		fail4:
			pos = pos3
			// g o
			{
				var node7 string
				// g
				if p, n := _gAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
				// o
				if p, n := _oAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
			}
			goto ok1
		fail6:
			pos = pos3
			// c u
			{
				var node9 string
				// c
				if p, n := _cAction(parser, pos); n == nil {
					goto fail8
				} else {
					node9 = *n
					pos = p
				}
				node0 += node9
				// u
				if p, n := _uAction(parser, pos); n == nil {
					goto fail8
				} else {
					node9 = *n
					pos = p
				}
				node0 += node9
			}
			goto ok1
		fail8:
			pos = pos3
			// k e
			{
				var node11 string
				// k
				if p, n := _kAction(parser, pos); n == nil {
					goto fail10
				} else {
					node11 = *n
					pos = p
				}
				node0 += node11
				// e
				if p, n := _eAction(parser, pos); n == nil {
					goto fail10
				} else {
					node11 = *n
					pos = p
				}
				node0 += node11
			}
			goto ok1
		fail10:
			pos = pos3
			goto fail
		ok1:
		}
		node += node0
		// &boundary
		{
			pos13 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail16
			} else {
				pos = p
			}
			goto ok12
		fail16:
			pos = pos13
			goto fail
		ok12:
			pos = pos13
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _connectiveAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _connective, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// (r a/r u/r i/r o i/r o/r e) &boundary
	// (r a/r u/r i/r o i/r o/r e)
	// r a/r u/r i/r o i/r o/r e
	{
		pos3 := pos
		// r a
		// r
		if !_accept(parser, _rAccepts, &pos, &perr) {
			goto fail4
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// r u
		// r
		if !_accept(parser, _rAccepts, &pos, &perr) {
			goto fail6
		}
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok1
	fail6:
		pos = pos3
		// r i
		// r
		if !_accept(parser, _rAccepts, &pos, &perr) {
			goto fail8
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok1
	fail8:
		pos = pos3
		// r o i
		// r
		if !_accept(parser, _rAccepts, &pos, &perr) {
			goto fail10
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail10
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok1
	fail10:
		pos = pos3
		// r o
		// r
		if !_accept(parser, _rAccepts, &pos, &perr) {
			goto fail12
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail12
		}
		goto ok1
	fail12:
		pos = pos3
		// r e
		// r
		if !_accept(parser, _rAccepts, &pos, &perr) {
			goto fail14
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail14
		}
		goto ok1
	fail14:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos17 := pos
		perr19 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail20
		}
		goto ok16
	fail20:
		pos = pos17
		perr = _max(perr19, pos)
		goto fail
	ok16:
		pos = pos17
		perr = perr19
	}
	return _memoize(parser, _connective, start, pos, perr)
fail:
	return _memoize(parser, _connective, start, -1, perr)
}

func _connectiveNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_connective]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _connective}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "connective"}
	// (r a/r u/r i/r o i/r o/r e) &boundary
	// (r a/r u/r i/r o i/r o/r e)
	{
		nkids1 := len(node.Kids)
		pos02 := pos
		// r a/r u/r i/r o i/r o/r e
		{
			pos5 := pos
			nkids4 := len(node.Kids)
			// r a
			// r
			if !_node(parser, _rNode, node, &pos) {
				goto fail6
			}
			// a
			if !_node(parser, _aNode, node, &pos) {
				goto fail6
			}
			goto ok3
		fail6:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// r u
			// r
			if !_node(parser, _rNode, node, &pos) {
				goto fail8
			}
			// u
			if !_node(parser, _uNode, node, &pos) {
				goto fail8
			}
			goto ok3
		fail8:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// r i
			// r
			if !_node(parser, _rNode, node, &pos) {
				goto fail10
			}
			// i
			if !_node(parser, _iNode, node, &pos) {
				goto fail10
			}
			goto ok3
		fail10:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// r o i
			// r
			if !_node(parser, _rNode, node, &pos) {
				goto fail12
			}
			// o
			if !_node(parser, _oNode, node, &pos) {
				goto fail12
			}
			// i
			if !_node(parser, _iNode, node, &pos) {
				goto fail12
			}
			goto ok3
		fail12:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// r o
			// r
			if !_node(parser, _rNode, node, &pos) {
				goto fail14
			}
			// o
			if !_node(parser, _oNode, node, &pos) {
				goto fail14
			}
			goto ok3
		fail14:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// r e
			// r
			if !_node(parser, _rNode, node, &pos) {
				goto fail16
			}
			// e
			if !_node(parser, _eNode, node, &pos) {
				goto fail16
			}
			goto ok3
		fail16:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			goto fail
		ok3:
		}
		sub := _sub(parser, pos02, pos, node.Kids[nkids1:])
		node.Kids = append(node.Kids[:nkids1], sub)
	}
	// &boundary
	{
		pos19 := pos
		nkids20 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail22
		}
		goto ok18
	fail22:
		pos = pos19
		goto fail
	ok18:
		pos = pos19
		node.Kids = node.Kids[:nkids20]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _connectiveFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _connective, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "connective",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _connective}
	// (r a/r u/r i/r o i/r o/r e) &boundary
	// (r a/r u/r i/r o i/r o/r e)
	// r a/r u/r i/r o i/r o/r e
	{
		pos3 := pos
		// r a
		// r
		if !_fail(parser, _rFail, errPos, failure, &pos) {
			goto fail4
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// r u
		// r
		if !_fail(parser, _rFail, errPos, failure, &pos) {
			goto fail6
		}
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok1
	fail6:
		pos = pos3
		// r i
		// r
		if !_fail(parser, _rFail, errPos, failure, &pos) {
			goto fail8
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok1
	fail8:
		pos = pos3
		// r o i
		// r
		if !_fail(parser, _rFail, errPos, failure, &pos) {
			goto fail10
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail10
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok1
	fail10:
		pos = pos3
		// r o
		// r
		if !_fail(parser, _rFail, errPos, failure, &pos) {
			goto fail12
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail12
		}
		goto ok1
	fail12:
		pos = pos3
		// r e
		// r
		if !_fail(parser, _rFail, errPos, failure, &pos) {
			goto fail14
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail14
		}
		goto ok1
	fail14:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos17 := pos
		nkids18 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail20
		}
		goto ok16
	fail20:
		pos = pos17
		failure.Kids = failure.Kids[:nkids18]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok16:
		pos = pos17
		failure.Kids = failure.Kids[:nkids18]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _connectiveAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_connective]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _connective}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// (r a/r u/r i/r o i/r o/r e) &boundary
	{
		var node0 string
		// (r a/r u/r i/r o i/r o/r e)
		// r a/r u/r i/r o i/r o/r e
		{
			pos3 := pos
			// r a
			{
				var node5 string
				// r
				if p, n := _rAction(parser, pos); n == nil {
					goto fail4
				} else {
					node5 = *n
					pos = p
				}
				node0 += node5
				// a
				if p, n := _aAction(parser, pos); n == nil {
					goto fail4
				} else {
					node5 = *n
					pos = p
				}
				node0 += node5
			}
			goto ok1
		fail4:
			pos = pos3
			// r u
			{
				var node7 string
				// r
				if p, n := _rAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
				// u
				if p, n := _uAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
			}
			goto ok1
		fail6:
			pos = pos3
			// r i
			{
				var node9 string
				// r
				if p, n := _rAction(parser, pos); n == nil {
					goto fail8
				} else {
					node9 = *n
					pos = p
				}
				node0 += node9
				// i
				if p, n := _iAction(parser, pos); n == nil {
					goto fail8
				} else {
					node9 = *n
					pos = p
				}
				node0 += node9
			}
			goto ok1
		fail8:
			pos = pos3
			// r o i
			{
				var node11 string
				// r
				if p, n := _rAction(parser, pos); n == nil {
					goto fail10
				} else {
					node11 = *n
					pos = p
				}
				node0 += node11
				// o
				if p, n := _oAction(parser, pos); n == nil {
					goto fail10
				} else {
					node11 = *n
					pos = p
				}
				node0 += node11
				// i
				if p, n := _iAction(parser, pos); n == nil {
					goto fail10
				} else {
					node11 = *n
					pos = p
				}
				node0 += node11
			}
			goto ok1
		fail10:
			pos = pos3
			// r o
			{
				var node13 string
				// r
				if p, n := _rAction(parser, pos); n == nil {
					goto fail12
				} else {
					node13 = *n
					pos = p
				}
				node0 += node13
				// o
				if p, n := _oAction(parser, pos); n == nil {
					goto fail12
				} else {
					node13 = *n
					pos = p
				}
				node0 += node13
			}
			goto ok1
		fail12:
			pos = pos3
			// r e
			{
				var node15 string
				// r
				if p, n := _rAction(parser, pos); n == nil {
					goto fail14
				} else {
					node15 = *n
					pos = p
				}
				node0 += node15
				// e
				if p, n := _eAction(parser, pos); n == nil {
					goto fail14
				} else {
					node15 = *n
					pos = p
				}
				node0 += node15
			}
			goto ok1
		fail14:
			pos = pos3
			goto fail
		ok1:
		}
		node += node0
		// &boundary
		{
			pos17 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail20
			} else {
				pos = p
			}
			goto ok16
		fail20:
			pos = pos17
			goto fail
		ok16:
			pos = pos17
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _illocutionaryAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _illocutionary, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// (m o q/d a/k a/s o/b a) &boundary
	// (m o q/d a/k a/s o/b a)
	// m o q/d a/k a/s o/b a
	{
		pos3 := pos
		// m o q
		// m
		if !_accept(parser, _mAccepts, &pos, &perr) {
			goto fail4
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail4
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// d a
		// d
		if !_accept(parser, _dAccepts, &pos, &perr) {
			goto fail6
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok1
	fail6:
		pos = pos3
		// k a
		// k
		if !_accept(parser, _kAccepts, &pos, &perr) {
			goto fail8
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok1
	fail8:
		pos = pos3
		// s o
		// s
		if !_accept(parser, _sAccepts, &pos, &perr) {
			goto fail10
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok1
	fail10:
		pos = pos3
		// b a
		// b
		if !_accept(parser, _bAccepts, &pos, &perr) {
			goto fail12
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail12
		}
		goto ok1
	fail12:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos15 := pos
		perr17 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail18
		}
		goto ok14
	fail18:
		pos = pos15
		perr = _max(perr17, pos)
		goto fail
	ok14:
		pos = pos15
		perr = perr17
	}
	return _memoize(parser, _illocutionary, start, pos, perr)
fail:
	return _memoize(parser, _illocutionary, start, -1, perr)
}

func _illocutionaryNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_illocutionary]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _illocutionary}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "illocutionary"}
	// (m o q/d a/k a/s o/b a) &boundary
	// (m o q/d a/k a/s o/b a)
	{
		nkids1 := len(node.Kids)
		pos02 := pos
		// m o q/d a/k a/s o/b a
		{
			pos5 := pos
			nkids4 := len(node.Kids)
			// m o q
			// m
			if !_node(parser, _mNode, node, &pos) {
				goto fail6
			}
			// o
			if !_node(parser, _oNode, node, &pos) {
				goto fail6
			}
			// q
			if !_node(parser, _qNode, node, &pos) {
				goto fail6
			}
			goto ok3
		fail6:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// d a
			// d
			if !_node(parser, _dNode, node, &pos) {
				goto fail8
			}
			// a
			if !_node(parser, _aNode, node, &pos) {
				goto fail8
			}
			goto ok3
		fail8:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// k a
			// k
			if !_node(parser, _kNode, node, &pos) {
				goto fail10
			}
			// a
			if !_node(parser, _aNode, node, &pos) {
				goto fail10
			}
			goto ok3
		fail10:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// s o
			// s
			if !_node(parser, _sNode, node, &pos) {
				goto fail12
			}
			// o
			if !_node(parser, _oNode, node, &pos) {
				goto fail12
			}
			goto ok3
		fail12:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// b a
			// b
			if !_node(parser, _bNode, node, &pos) {
				goto fail14
			}
			// a
			if !_node(parser, _aNode, node, &pos) {
				goto fail14
			}
			goto ok3
		fail14:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			goto fail
		ok3:
		}
		sub := _sub(parser, pos02, pos, node.Kids[nkids1:])
		node.Kids = append(node.Kids[:nkids1], sub)
	}
	// &boundary
	{
		pos17 := pos
		nkids18 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail20
		}
		goto ok16
	fail20:
		pos = pos17
		goto fail
	ok16:
		pos = pos17
		node.Kids = node.Kids[:nkids18]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _illocutionaryFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _illocutionary, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "illocutionary",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _illocutionary}
	// (m o q/d a/k a/s o/b a) &boundary
	// (m o q/d a/k a/s o/b a)
	// m o q/d a/k a/s o/b a
	{
		pos3 := pos
		// m o q
		// m
		if !_fail(parser, _mFail, errPos, failure, &pos) {
			goto fail4
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail4
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// d a
		// d
		if !_fail(parser, _dFail, errPos, failure, &pos) {
			goto fail6
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok1
	fail6:
		pos = pos3
		// k a
		// k
		if !_fail(parser, _kFail, errPos, failure, &pos) {
			goto fail8
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok1
	fail8:
		pos = pos3
		// s o
		// s
		if !_fail(parser, _sFail, errPos, failure, &pos) {
			goto fail10
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok1
	fail10:
		pos = pos3
		// b a
		// b
		if !_fail(parser, _bFail, errPos, failure, &pos) {
			goto fail12
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail12
		}
		goto ok1
	fail12:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos15 := pos
		nkids16 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail18
		}
		goto ok14
	fail18:
		pos = pos15
		failure.Kids = failure.Kids[:nkids16]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok14:
		pos = pos15
		failure.Kids = failure.Kids[:nkids16]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _illocutionaryAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_illocutionary]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _illocutionary}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// (m o q/d a/k a/s o/b a) &boundary
	{
		var node0 string
		// (m o q/d a/k a/s o/b a)
		// m o q/d a/k a/s o/b a
		{
			pos3 := pos
			// m o q
			{
				var node5 string
				// m
				if p, n := _mAction(parser, pos); n == nil {
					goto fail4
				} else {
					node5 = *n
					pos = p
				}
				node0 += node5
				// o
				if p, n := _oAction(parser, pos); n == nil {
					goto fail4
				} else {
					node5 = *n
					pos = p
				}
				node0 += node5
				// q
				if p, n := _qAction(parser, pos); n == nil {
					goto fail4
				} else {
					node5 = *n
					pos = p
				}
				node0 += node5
			}
			goto ok1
		fail4:
			pos = pos3
			// d a
			{
				var node7 string
				// d
				if p, n := _dAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
				// a
				if p, n := _aAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
			}
			goto ok1
		fail6:
			pos = pos3
			// k a
			{
				var node9 string
				// k
				if p, n := _kAction(parser, pos); n == nil {
					goto fail8
				} else {
					node9 = *n
					pos = p
				}
				node0 += node9
				// a
				if p, n := _aAction(parser, pos); n == nil {
					goto fail8
				} else {
					node9 = *n
					pos = p
				}
				node0 += node9
			}
			goto ok1
		fail8:
			pos = pos3
			// s o
			{
				var node11 string
				// s
				if p, n := _sAction(parser, pos); n == nil {
					goto fail10
				} else {
					node11 = *n
					pos = p
				}
				node0 += node11
				// o
				if p, n := _oAction(parser, pos); n == nil {
					goto fail10
				} else {
					node11 = *n
					pos = p
				}
				node0 += node11
			}
			goto ok1
		fail10:
			pos = pos3
			// b a
			{
				var node13 string
				// b
				if p, n := _bAction(parser, pos); n == nil {
					goto fail12
				} else {
					node13 = *n
					pos = p
				}
				node0 += node13
				// a
				if p, n := _aAction(parser, pos); n == nil {
					goto fail12
				} else {
					node13 = *n
					pos = p
				}
				node0 += node13
			}
			goto ok1
		fail12:
			pos = pos3
			goto fail
		ok1:
		}
		node += node0
		// &boundary
		{
			pos15 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail18
			} else {
				pos = p
			}
			goto ok14
		fail18:
			pos = pos15
			goto fail
		ok14:
			pos = pos15
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _quantifierAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _quantifier, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// (t u/s i a/s a/h i/j a) &boundary
	// (t u/s i a/s a/h i/j a)
	// t u/s i a/s a/h i/j a
	{
		pos3 := pos
		// t u
		// t
		if !_accept(parser, _tAccepts, &pos, &perr) {
			goto fail4
		}
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// s i a
		// s
		if !_accept(parser, _sAccepts, &pos, &perr) {
			goto fail6
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail6
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok1
	fail6:
		pos = pos3
		// s a
		// s
		if !_accept(parser, _sAccepts, &pos, &perr) {
			goto fail8
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok1
	fail8:
		pos = pos3
		// h i
		// h
		if !_accept(parser, _hAccepts, &pos, &perr) {
			goto fail10
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok1
	fail10:
		pos = pos3
		// j a
		// j
		if !_accept(parser, _jAccepts, &pos, &perr) {
			goto fail12
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail12
		}
		goto ok1
	fail12:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos15 := pos
		perr17 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail18
		}
		goto ok14
	fail18:
		pos = pos15
		perr = _max(perr17, pos)
		goto fail
	ok14:
		pos = pos15
		perr = perr17
	}
	return _memoize(parser, _quantifier, start, pos, perr)
fail:
	return _memoize(parser, _quantifier, start, -1, perr)
}

func _quantifierNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_quantifier]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _quantifier}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "quantifier"}
	// (t u/s i a/s a/h i/j a) &boundary
	// (t u/s i a/s a/h i/j a)
	{
		nkids1 := len(node.Kids)
		pos02 := pos
		// t u/s i a/s a/h i/j a
		{
			pos5 := pos
			nkids4 := len(node.Kids)
			// t u
			// t
			if !_node(parser, _tNode, node, &pos) {
				goto fail6
			}
			// u
			if !_node(parser, _uNode, node, &pos) {
				goto fail6
			}
			goto ok3
		fail6:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// s i a
			// s
			if !_node(parser, _sNode, node, &pos) {
				goto fail8
			}
			// i
			if !_node(parser, _iNode, node, &pos) {
				goto fail8
			}
			// a
			if !_node(parser, _aNode, node, &pos) {
				goto fail8
			}
			goto ok3
		fail8:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// s a
			// s
			if !_node(parser, _sNode, node, &pos) {
				goto fail10
			}
			// a
			if !_node(parser, _aNode, node, &pos) {
				goto fail10
			}
			goto ok3
		fail10:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// h i
			// h
			if !_node(parser, _hNode, node, &pos) {
				goto fail12
			}
			// i
			if !_node(parser, _iNode, node, &pos) {
				goto fail12
			}
			goto ok3
		fail12:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// j a
			// j
			if !_node(parser, _jNode, node, &pos) {
				goto fail14
			}
			// a
			if !_node(parser, _aNode, node, &pos) {
				goto fail14
			}
			goto ok3
		fail14:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			goto fail
		ok3:
		}
		sub := _sub(parser, pos02, pos, node.Kids[nkids1:])
		node.Kids = append(node.Kids[:nkids1], sub)
	}
	// &boundary
	{
		pos17 := pos
		nkids18 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail20
		}
		goto ok16
	fail20:
		pos = pos17
		goto fail
	ok16:
		pos = pos17
		node.Kids = node.Kids[:nkids18]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _quantifierFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _quantifier, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "quantifier",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _quantifier}
	// (t u/s i a/s a/h i/j a) &boundary
	// (t u/s i a/s a/h i/j a)
	// t u/s i a/s a/h i/j a
	{
		pos3 := pos
		// t u
		// t
		if !_fail(parser, _tFail, errPos, failure, &pos) {
			goto fail4
		}
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// s i a
		// s
		if !_fail(parser, _sFail, errPos, failure, &pos) {
			goto fail6
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail6
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok1
	fail6:
		pos = pos3
		// s a
		// s
		if !_fail(parser, _sFail, errPos, failure, &pos) {
			goto fail8
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok1
	fail8:
		pos = pos3
		// h i
		// h
		if !_fail(parser, _hFail, errPos, failure, &pos) {
			goto fail10
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok1
	fail10:
		pos = pos3
		// j a
		// j
		if !_fail(parser, _jFail, errPos, failure, &pos) {
			goto fail12
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail12
		}
		goto ok1
	fail12:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos15 := pos
		nkids16 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail18
		}
		goto ok14
	fail18:
		pos = pos15
		failure.Kids = failure.Kids[:nkids16]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok14:
		pos = pos15
		failure.Kids = failure.Kids[:nkids16]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _quantifierAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_quantifier]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _quantifier}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// (t u/s i a/s a/h i/j a) &boundary
	{
		var node0 string
		// (t u/s i a/s a/h i/j a)
		// t u/s i a/s a/h i/j a
		{
			pos3 := pos
			// t u
			{
				var node5 string
				// t
				if p, n := _tAction(parser, pos); n == nil {
					goto fail4
				} else {
					node5 = *n
					pos = p
				}
				node0 += node5
				// u
				if p, n := _uAction(parser, pos); n == nil {
					goto fail4
				} else {
					node5 = *n
					pos = p
				}
				node0 += node5
			}
			goto ok1
		fail4:
			pos = pos3
			// s i a
			{
				var node7 string
				// s
				if p, n := _sAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
				// i
				if p, n := _iAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
				// a
				if p, n := _aAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
			}
			goto ok1
		fail6:
			pos = pos3
			// s a
			{
				var node9 string
				// s
				if p, n := _sAction(parser, pos); n == nil {
					goto fail8
				} else {
					node9 = *n
					pos = p
				}
				node0 += node9
				// a
				if p, n := _aAction(parser, pos); n == nil {
					goto fail8
				} else {
					node9 = *n
					pos = p
				}
				node0 += node9
			}
			goto ok1
		fail8:
			pos = pos3
			// h i
			{
				var node11 string
				// h
				if p, n := _hAction(parser, pos); n == nil {
					goto fail10
				} else {
					node11 = *n
					pos = p
				}
				node0 += node11
				// i
				if p, n := _iAction(parser, pos); n == nil {
					goto fail10
				} else {
					node11 = *n
					pos = p
				}
				node0 += node11
			}
			goto ok1
		fail10:
			pos = pos3
			// j a
			{
				var node13 string
				// j
				if p, n := _jAction(parser, pos); n == nil {
					goto fail12
				} else {
					node13 = *n
					pos = p
				}
				node0 += node13
				// a
				if p, n := _aAction(parser, pos); n == nil {
					goto fail12
				} else {
					node13 = *n
					pos = p
				}
				node0 += node13
			}
			goto ok1
		fail12:
			pos = pos3
			goto fail
		ok1:
		}
		node += node0
		// &boundary
		{
			pos15 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail18
			} else {
				pos = p
			}
			goto ok14
		fail18:
			pos = pos15
			goto fail
		ok14:
			pos = pos15
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _interjectionAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _interjection, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// (h a/h u e/h i a/m) &boundary
	// (h a/h u e/h i a/m)
	// h a/h u e/h i a/m
	{
		pos3 := pos
		// h a
		// h
		if !_accept(parser, _hAccepts, &pos, &perr) {
			goto fail4
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// h u e
		// h
		if !_accept(parser, _hAccepts, &pos, &perr) {
			goto fail6
		}
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail6
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok1
	fail6:
		pos = pos3
		// h i a
		// h
		if !_accept(parser, _hAccepts, &pos, &perr) {
			goto fail8
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail8
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok1
	fail8:
		pos = pos3
		// m
		if !_accept(parser, _mAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok1
	fail10:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos12 := pos
		perr14 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail15
		}
		goto ok11
	fail15:
		pos = pos12
		perr = _max(perr14, pos)
		goto fail
	ok11:
		pos = pos12
		perr = perr14
	}
	return _memoize(parser, _interjection, start, pos, perr)
fail:
	return _memoize(parser, _interjection, start, -1, perr)
}

func _interjectionNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_interjection]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _interjection}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "interjection"}
	// (h a/h u e/h i a/m) &boundary
	// (h a/h u e/h i a/m)
	{
		nkids1 := len(node.Kids)
		pos02 := pos
		// h a/h u e/h i a/m
		{
			pos5 := pos
			nkids4 := len(node.Kids)
			// h a
			// h
			if !_node(parser, _hNode, node, &pos) {
				goto fail6
			}
			// a
			if !_node(parser, _aNode, node, &pos) {
				goto fail6
			}
			goto ok3
		fail6:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// h u e
			// h
			if !_node(parser, _hNode, node, &pos) {
				goto fail8
			}
			// u
			if !_node(parser, _uNode, node, &pos) {
				goto fail8
			}
			// e
			if !_node(parser, _eNode, node, &pos) {
				goto fail8
			}
			goto ok3
		fail8:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// h i a
			// h
			if !_node(parser, _hNode, node, &pos) {
				goto fail10
			}
			// i
			if !_node(parser, _iNode, node, &pos) {
				goto fail10
			}
			// a
			if !_node(parser, _aNode, node, &pos) {
				goto fail10
			}
			goto ok3
		fail10:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// m
			if !_node(parser, _mNode, node, &pos) {
				goto fail12
			}
			goto ok3
		fail12:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			goto fail
		ok3:
		}
		sub := _sub(parser, pos02, pos, node.Kids[nkids1:])
		node.Kids = append(node.Kids[:nkids1], sub)
	}
	// &boundary
	{
		pos14 := pos
		nkids15 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail17
		}
		goto ok13
	fail17:
		pos = pos14
		goto fail
	ok13:
		pos = pos14
		node.Kids = node.Kids[:nkids15]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _interjectionFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _interjection, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "interjection",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _interjection}
	// (h a/h u e/h i a/m) &boundary
	// (h a/h u e/h i a/m)
	// h a/h u e/h i a/m
	{
		pos3 := pos
		// h a
		// h
		if !_fail(parser, _hFail, errPos, failure, &pos) {
			goto fail4
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// h u e
		// h
		if !_fail(parser, _hFail, errPos, failure, &pos) {
			goto fail6
		}
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail6
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok1
	fail6:
		pos = pos3
		// h i a
		// h
		if !_fail(parser, _hFail, errPos, failure, &pos) {
			goto fail8
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail8
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok1
	fail8:
		pos = pos3
		// m
		if !_fail(parser, _mFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok1
	fail10:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos12 := pos
		nkids13 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail15
		}
		goto ok11
	fail15:
		pos = pos12
		failure.Kids = failure.Kids[:nkids13]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok11:
		pos = pos12
		failure.Kids = failure.Kids[:nkids13]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _interjectionAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_interjection]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _interjection}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// (h a/h u e/h i a/m) &boundary
	{
		var node0 string
		// (h a/h u e/h i a/m)
		// h a/h u e/h i a/m
		{
			pos3 := pos
			// h a
			{
				var node5 string
				// h
				if p, n := _hAction(parser, pos); n == nil {
					goto fail4
				} else {
					node5 = *n
					pos = p
				}
				node0 += node5
				// a
				if p, n := _aAction(parser, pos); n == nil {
					goto fail4
				} else {
					node5 = *n
					pos = p
				}
				node0 += node5
			}
			goto ok1
		fail4:
			pos = pos3
			// h u e
			{
				var node7 string
				// h
				if p, n := _hAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
				// u
				if p, n := _uAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
				// e
				if p, n := _eAction(parser, pos); n == nil {
					goto fail6
				} else {
					node7 = *n
					pos = p
				}
				node0 += node7
			}
			goto ok1
		fail6:
			pos = pos3
			// h i a
			{
				var node9 string
				// h
				if p, n := _hAction(parser, pos); n == nil {
					goto fail8
				} else {
					node9 = *n
					pos = p
				}
				node0 += node9
				// i
				if p, n := _iAction(parser, pos); n == nil {
					goto fail8
				} else {
					node9 = *n
					pos = p
				}
				node0 += node9
				// a
				if p, n := _aAction(parser, pos); n == nil {
					goto fail8
				} else {
					node9 = *n
					pos = p
				}
				node0 += node9
			}
			goto ok1
		fail8:
			pos = pos3
			// m
			if p, n := _mAction(parser, pos); n == nil {
				goto fail10
			} else {
				node0 = *n
				pos = p
			}
			goto ok1
		fail10:
			pos = pos3
			goto fail
		ok1:
		}
		node += node0
		// &boundary
		{
			pos12 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail15
			} else {
				pos = p
			}
			goto ok11
		fail15:
			pos = pos12
			goto fail
		ok11:
			pos = pos12
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _syllable__compound_desinence__compound_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _syllable__compound_desinence__compound_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// initial (compound_desinence/neutral_desinence compound_tone) &boundary
	// initial
	if !_accept(parser, _initialAccepts, &pos, &perr) {
		goto fail
	}
	// (compound_desinence/neutral_desinence compound_tone)
	// compound_desinence/neutral_desinence compound_tone
	{
		pos3 := pos
		// compound_desinence
		if !_accept(parser, _compound_desinenceAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// neutral_desinence compound_tone
		// neutral_desinence
		if !_accept(parser, _neutral_desinenceAccepts, &pos, &perr) {
			goto fail5
		}
		// compound_tone
		if !_accept(parser, _compound_toneAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos8 := pos
		perr10 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail11
		}
		goto ok7
	fail11:
		pos = pos8
		perr = _max(perr10, pos)
		goto fail
	ok7:
		pos = pos8
		perr = perr10
	}
	return _memoize(parser, _syllable__compound_desinence__compound_tone, start, pos, perr)
fail:
	return _memoize(parser, _syllable__compound_desinence__compound_tone, start, -1, perr)
}

func _syllable__compound_desinence__compound_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_syllable__compound_desinence__compound_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _syllable__compound_desinence__compound_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "syllable<compound_desinence, compound_tone>"}
	// initial (compound_desinence/neutral_desinence compound_tone) &boundary
	// initial
	if !_node(parser, _initialNode, node, &pos) {
		goto fail
	}
	// (compound_desinence/neutral_desinence compound_tone)
	{
		nkids1 := len(node.Kids)
		pos02 := pos
		// compound_desinence/neutral_desinence compound_tone
		{
			pos5 := pos
			nkids4 := len(node.Kids)
			// compound_desinence
			if !_node(parser, _compound_desinenceNode, node, &pos) {
				goto fail6
			}
			goto ok3
		fail6:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// neutral_desinence compound_tone
			// neutral_desinence
			if !_node(parser, _neutral_desinenceNode, node, &pos) {
				goto fail7
			}
			// compound_tone
			if !_node(parser, _compound_toneNode, node, &pos) {
				goto fail7
			}
			goto ok3
		fail7:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			goto fail
		ok3:
		}
		sub := _sub(parser, pos02, pos, node.Kids[nkids1:])
		node.Kids = append(node.Kids[:nkids1], sub)
	}
	// &boundary
	{
		pos10 := pos
		nkids11 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail13
		}
		goto ok9
	fail13:
		pos = pos10
		goto fail
	ok9:
		pos = pos10
		node.Kids = node.Kids[:nkids11]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _syllable__compound_desinence__compound_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _syllable__compound_desinence__compound_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "syllable__compound_desinence__compound_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _syllable__compound_desinence__compound_tone}
	// initial (compound_desinence/neutral_desinence compound_tone) &boundary
	// initial
	if !_fail(parser, _initialFail, errPos, failure, &pos) {
		goto fail
	}
	// (compound_desinence/neutral_desinence compound_tone)
	// compound_desinence/neutral_desinence compound_tone
	{
		pos3 := pos
		// compound_desinence
		if !_fail(parser, _compound_desinenceFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// neutral_desinence compound_tone
		// neutral_desinence
		if !_fail(parser, _neutral_desinenceFail, errPos, failure, &pos) {
			goto fail5
		}
		// compound_tone
		if !_fail(parser, _compound_toneFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos8 := pos
		nkids9 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail11
		}
		goto ok7
	fail11:
		pos = pos8
		failure.Kids = failure.Kids[:nkids9]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok7:
		pos = pos8
		failure.Kids = failure.Kids[:nkids9]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _syllable__compound_desinence__compound_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_syllable__compound_desinence__compound_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _syllable__compound_desinence__compound_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// initial (compound_desinence/neutral_desinence compound_tone) &boundary
	{
		var node0 string
		// initial
		if p, n := _initialAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// (compound_desinence/neutral_desinence compound_tone)
		// compound_desinence/neutral_desinence compound_tone
		{
			pos3 := pos
			// compound_desinence
			if p, n := _compound_desinenceAction(parser, pos); n == nil {
				goto fail4
			} else {
				node0 = *n
				pos = p
			}
			goto ok1
		fail4:
			pos = pos3
			// neutral_desinence compound_tone
			{
				var node6 string
				// neutral_desinence
				if p, n := _neutral_desinenceAction(parser, pos); n == nil {
					goto fail5
				} else {
					node6 = *n
					pos = p
				}
				node0 += node6
				// compound_tone
				if p, n := _compound_toneAction(parser, pos); n == nil {
					goto fail5
				} else {
					node6 = *n
					pos = p
				}
				node0 += node6
			}
			goto ok1
		fail5:
			pos = pos3
			goto fail
		ok1:
		}
		node += node0
		// &boundary
		{
			pos8 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail11
			} else {
				pos = p
			}
			goto ok7
		fail11:
			pos = pos8
			goto fail
		ok7:
			pos = pos8
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _syllable__arg_desinence__arg_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _syllable__arg_desinence__arg_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// initial (arg_desinence/neutral_desinence arg_tone) &boundary
	// initial
	if !_accept(parser, _initialAccepts, &pos, &perr) {
		goto fail
	}
	// (arg_desinence/neutral_desinence arg_tone)
	// arg_desinence/neutral_desinence arg_tone
	{
		pos3 := pos
		// arg_desinence
		if !_accept(parser, _arg_desinenceAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// neutral_desinence arg_tone
		// neutral_desinence
		if !_accept(parser, _neutral_desinenceAccepts, &pos, &perr) {
			goto fail5
		}
		// arg_tone
		if !_accept(parser, _arg_toneAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos8 := pos
		perr10 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail11
		}
		goto ok7
	fail11:
		pos = pos8
		perr = _max(perr10, pos)
		goto fail
	ok7:
		pos = pos8
		perr = perr10
	}
	return _memoize(parser, _syllable__arg_desinence__arg_tone, start, pos, perr)
fail:
	return _memoize(parser, _syllable__arg_desinence__arg_tone, start, -1, perr)
}

func _syllable__arg_desinence__arg_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_syllable__arg_desinence__arg_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _syllable__arg_desinence__arg_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "syllable<arg_desinence, arg_tone>"}
	// initial (arg_desinence/neutral_desinence arg_tone) &boundary
	// initial
	if !_node(parser, _initialNode, node, &pos) {
		goto fail
	}
	// (arg_desinence/neutral_desinence arg_tone)
	{
		nkids1 := len(node.Kids)
		pos02 := pos
		// arg_desinence/neutral_desinence arg_tone
		{
			pos5 := pos
			nkids4 := len(node.Kids)
			// arg_desinence
			if !_node(parser, _arg_desinenceNode, node, &pos) {
				goto fail6
			}
			goto ok3
		fail6:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// neutral_desinence arg_tone
			// neutral_desinence
			if !_node(parser, _neutral_desinenceNode, node, &pos) {
				goto fail7
			}
			// arg_tone
			if !_node(parser, _arg_toneNode, node, &pos) {
				goto fail7
			}
			goto ok3
		fail7:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			goto fail
		ok3:
		}
		sub := _sub(parser, pos02, pos, node.Kids[nkids1:])
		node.Kids = append(node.Kids[:nkids1], sub)
	}
	// &boundary
	{
		pos10 := pos
		nkids11 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail13
		}
		goto ok9
	fail13:
		pos = pos10
		goto fail
	ok9:
		pos = pos10
		node.Kids = node.Kids[:nkids11]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _syllable__arg_desinence__arg_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _syllable__arg_desinence__arg_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "syllable__arg_desinence__arg_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _syllable__arg_desinence__arg_tone}
	// initial (arg_desinence/neutral_desinence arg_tone) &boundary
	// initial
	if !_fail(parser, _initialFail, errPos, failure, &pos) {
		goto fail
	}
	// (arg_desinence/neutral_desinence arg_tone)
	// arg_desinence/neutral_desinence arg_tone
	{
		pos3 := pos
		// arg_desinence
		if !_fail(parser, _arg_desinenceFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// neutral_desinence arg_tone
		// neutral_desinence
		if !_fail(parser, _neutral_desinenceFail, errPos, failure, &pos) {
			goto fail5
		}
		// arg_tone
		if !_fail(parser, _arg_toneFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos8 := pos
		nkids9 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail11
		}
		goto ok7
	fail11:
		pos = pos8
		failure.Kids = failure.Kids[:nkids9]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok7:
		pos = pos8
		failure.Kids = failure.Kids[:nkids9]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _syllable__arg_desinence__arg_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_syllable__arg_desinence__arg_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _syllable__arg_desinence__arg_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// initial (arg_desinence/neutral_desinence arg_tone) &boundary
	{
		var node0 string
		// initial
		if p, n := _initialAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// (arg_desinence/neutral_desinence arg_tone)
		// arg_desinence/neutral_desinence arg_tone
		{
			pos3 := pos
			// arg_desinence
			if p, n := _arg_desinenceAction(parser, pos); n == nil {
				goto fail4
			} else {
				node0 = *n
				pos = p
			}
			goto ok1
		fail4:
			pos = pos3
			// neutral_desinence arg_tone
			{
				var node6 string
				// neutral_desinence
				if p, n := _neutral_desinenceAction(parser, pos); n == nil {
					goto fail5
				} else {
					node6 = *n
					pos = p
				}
				node0 += node6
				// arg_tone
				if p, n := _arg_toneAction(parser, pos); n == nil {
					goto fail5
				} else {
					node6 = *n
					pos = p
				}
				node0 += node6
			}
			goto ok1
		fail5:
			pos = pos3
			goto fail
		ok1:
		}
		node += node0
		// &boundary
		{
			pos8 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail11
			} else {
				pos = p
			}
			goto ok7
		fail11:
			pos = pos8
			goto fail
		ok7:
			pos = pos8
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _syllable__relative_desinence__relative_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _syllable__relative_desinence__relative_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// initial (relative_desinence/neutral_desinence relative_tone) &boundary
	// initial
	if !_accept(parser, _initialAccepts, &pos, &perr) {
		goto fail
	}
	// (relative_desinence/neutral_desinence relative_tone)
	// relative_desinence/neutral_desinence relative_tone
	{
		pos3 := pos
		// relative_desinence
		if !_accept(parser, _relative_desinenceAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// neutral_desinence relative_tone
		// neutral_desinence
		if !_accept(parser, _neutral_desinenceAccepts, &pos, &perr) {
			goto fail5
		}
		// relative_tone
		if !_accept(parser, _relative_toneAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos8 := pos
		perr10 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail11
		}
		goto ok7
	fail11:
		pos = pos8
		perr = _max(perr10, pos)
		goto fail
	ok7:
		pos = pos8
		perr = perr10
	}
	return _memoize(parser, _syllable__relative_desinence__relative_tone, start, pos, perr)
fail:
	return _memoize(parser, _syllable__relative_desinence__relative_tone, start, -1, perr)
}

func _syllable__relative_desinence__relative_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_syllable__relative_desinence__relative_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _syllable__relative_desinence__relative_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "syllable<relative_desinence, relative_tone>"}
	// initial (relative_desinence/neutral_desinence relative_tone) &boundary
	// initial
	if !_node(parser, _initialNode, node, &pos) {
		goto fail
	}
	// (relative_desinence/neutral_desinence relative_tone)
	{
		nkids1 := len(node.Kids)
		pos02 := pos
		// relative_desinence/neutral_desinence relative_tone
		{
			pos5 := pos
			nkids4 := len(node.Kids)
			// relative_desinence
			if !_node(parser, _relative_desinenceNode, node, &pos) {
				goto fail6
			}
			goto ok3
		fail6:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// neutral_desinence relative_tone
			// neutral_desinence
			if !_node(parser, _neutral_desinenceNode, node, &pos) {
				goto fail7
			}
			// relative_tone
			if !_node(parser, _relative_toneNode, node, &pos) {
				goto fail7
			}
			goto ok3
		fail7:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			goto fail
		ok3:
		}
		sub := _sub(parser, pos02, pos, node.Kids[nkids1:])
		node.Kids = append(node.Kids[:nkids1], sub)
	}
	// &boundary
	{
		pos10 := pos
		nkids11 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail13
		}
		goto ok9
	fail13:
		pos = pos10
		goto fail
	ok9:
		pos = pos10
		node.Kids = node.Kids[:nkids11]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _syllable__relative_desinence__relative_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _syllable__relative_desinence__relative_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "syllable__relative_desinence__relative_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _syllable__relative_desinence__relative_tone}
	// initial (relative_desinence/neutral_desinence relative_tone) &boundary
	// initial
	if !_fail(parser, _initialFail, errPos, failure, &pos) {
		goto fail
	}
	// (relative_desinence/neutral_desinence relative_tone)
	// relative_desinence/neutral_desinence relative_tone
	{
		pos3 := pos
		// relative_desinence
		if !_fail(parser, _relative_desinenceFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// neutral_desinence relative_tone
		// neutral_desinence
		if !_fail(parser, _neutral_desinenceFail, errPos, failure, &pos) {
			goto fail5
		}
		// relative_tone
		if !_fail(parser, _relative_toneFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos8 := pos
		nkids9 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail11
		}
		goto ok7
	fail11:
		pos = pos8
		failure.Kids = failure.Kids[:nkids9]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok7:
		pos = pos8
		failure.Kids = failure.Kids[:nkids9]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _syllable__relative_desinence__relative_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_syllable__relative_desinence__relative_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _syllable__relative_desinence__relative_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// initial (relative_desinence/neutral_desinence relative_tone) &boundary
	{
		var node0 string
		// initial
		if p, n := _initialAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// (relative_desinence/neutral_desinence relative_tone)
		// relative_desinence/neutral_desinence relative_tone
		{
			pos3 := pos
			// relative_desinence
			if p, n := _relative_desinenceAction(parser, pos); n == nil {
				goto fail4
			} else {
				node0 = *n
				pos = p
			}
			goto ok1
		fail4:
			pos = pos3
			// neutral_desinence relative_tone
			{
				var node6 string
				// neutral_desinence
				if p, n := _neutral_desinenceAction(parser, pos); n == nil {
					goto fail5
				} else {
					node6 = *n
					pos = p
				}
				node0 += node6
				// relative_tone
				if p, n := _relative_toneAction(parser, pos); n == nil {
					goto fail5
				} else {
					node6 = *n
					pos = p
				}
				node0 += node6
			}
			goto ok1
		fail5:
			pos = pos3
			goto fail
		ok1:
		}
		node += node0
		// &boundary
		{
			pos8 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail11
			} else {
				pos = p
			}
			goto ok7
		fail11:
			pos = pos8
			goto fail
		ok7:
			pos = pos8
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _syllable__verb_desinence__verb_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _syllable__verb_desinence__verb_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// initial (verb_desinence/neutral_desinence verb_tone) &boundary
	// initial
	if !_accept(parser, _initialAccepts, &pos, &perr) {
		goto fail
	}
	// (verb_desinence/neutral_desinence verb_tone)
	// verb_desinence/neutral_desinence verb_tone
	{
		pos3 := pos
		// verb_desinence
		if !_accept(parser, _verb_desinenceAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// neutral_desinence verb_tone
		// neutral_desinence
		if !_accept(parser, _neutral_desinenceAccepts, &pos, &perr) {
			goto fail5
		}
		// verb_tone
		if !_accept(parser, _verb_toneAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos8 := pos
		perr10 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail11
		}
		goto ok7
	fail11:
		pos = pos8
		perr = _max(perr10, pos)
		goto fail
	ok7:
		pos = pos8
		perr = perr10
	}
	return _memoize(parser, _syllable__verb_desinence__verb_tone, start, pos, perr)
fail:
	return _memoize(parser, _syllable__verb_desinence__verb_tone, start, -1, perr)
}

func _syllable__verb_desinence__verb_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_syllable__verb_desinence__verb_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _syllable__verb_desinence__verb_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "syllable<verb_desinence, verb_tone>"}
	// initial (verb_desinence/neutral_desinence verb_tone) &boundary
	// initial
	if !_node(parser, _initialNode, node, &pos) {
		goto fail
	}
	// (verb_desinence/neutral_desinence verb_tone)
	{
		nkids1 := len(node.Kids)
		pos02 := pos
		// verb_desinence/neutral_desinence verb_tone
		{
			pos5 := pos
			nkids4 := len(node.Kids)
			// verb_desinence
			if !_node(parser, _verb_desinenceNode, node, &pos) {
				goto fail6
			}
			goto ok3
		fail6:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// neutral_desinence verb_tone
			// neutral_desinence
			if !_node(parser, _neutral_desinenceNode, node, &pos) {
				goto fail7
			}
			// verb_tone
			if !_node(parser, _verb_toneNode, node, &pos) {
				goto fail7
			}
			goto ok3
		fail7:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			goto fail
		ok3:
		}
		sub := _sub(parser, pos02, pos, node.Kids[nkids1:])
		node.Kids = append(node.Kids[:nkids1], sub)
	}
	// &boundary
	{
		pos10 := pos
		nkids11 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail13
		}
		goto ok9
	fail13:
		pos = pos10
		goto fail
	ok9:
		pos = pos10
		node.Kids = node.Kids[:nkids11]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _syllable__verb_desinence__verb_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _syllable__verb_desinence__verb_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "syllable__verb_desinence__verb_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _syllable__verb_desinence__verb_tone}
	// initial (verb_desinence/neutral_desinence verb_tone) &boundary
	// initial
	if !_fail(parser, _initialFail, errPos, failure, &pos) {
		goto fail
	}
	// (verb_desinence/neutral_desinence verb_tone)
	// verb_desinence/neutral_desinence verb_tone
	{
		pos3 := pos
		// verb_desinence
		if !_fail(parser, _verb_desinenceFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// neutral_desinence verb_tone
		// neutral_desinence
		if !_fail(parser, _neutral_desinenceFail, errPos, failure, &pos) {
			goto fail5
		}
		// verb_tone
		if !_fail(parser, _verb_toneFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos8 := pos
		nkids9 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail11
		}
		goto ok7
	fail11:
		pos = pos8
		failure.Kids = failure.Kids[:nkids9]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok7:
		pos = pos8
		failure.Kids = failure.Kids[:nkids9]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _syllable__verb_desinence__verb_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_syllable__verb_desinence__verb_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _syllable__verb_desinence__verb_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// initial (verb_desinence/neutral_desinence verb_tone) &boundary
	{
		var node0 string
		// initial
		if p, n := _initialAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// (verb_desinence/neutral_desinence verb_tone)
		// verb_desinence/neutral_desinence verb_tone
		{
			pos3 := pos
			// verb_desinence
			if p, n := _verb_desinenceAction(parser, pos); n == nil {
				goto fail4
			} else {
				node0 = *n
				pos = p
			}
			goto ok1
		fail4:
			pos = pos3
			// neutral_desinence verb_tone
			{
				var node6 string
				// neutral_desinence
				if p, n := _neutral_desinenceAction(parser, pos); n == nil {
					goto fail5
				} else {
					node6 = *n
					pos = p
				}
				node0 += node6
				// verb_tone
				if p, n := _verb_toneAction(parser, pos); n == nil {
					goto fail5
				} else {
					node6 = *n
					pos = p
				}
				node0 += node6
			}
			goto ok1
		fail5:
			pos = pos3
			goto fail
		ok1:
		}
		node += node0
		// &boundary
		{
			pos8 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail11
			} else {
				pos = p
			}
			goto ok7
		fail11:
			pos = pos8
			goto fail
		ok7:
			pos = pos8
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _syllable__content_desinence__content_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _syllable__content_desinence__content_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// initial (content_desinence/neutral_desinence content_tone) &boundary
	// initial
	if !_accept(parser, _initialAccepts, &pos, &perr) {
		goto fail
	}
	// (content_desinence/neutral_desinence content_tone)
	// content_desinence/neutral_desinence content_tone
	{
		pos3 := pos
		// content_desinence
		if !_accept(parser, _content_desinenceAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// neutral_desinence content_tone
		// neutral_desinence
		if !_accept(parser, _neutral_desinenceAccepts, &pos, &perr) {
			goto fail5
		}
		// content_tone
		if !_accept(parser, _content_toneAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos8 := pos
		perr10 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail11
		}
		goto ok7
	fail11:
		pos = pos8
		perr = _max(perr10, pos)
		goto fail
	ok7:
		pos = pos8
		perr = perr10
	}
	return _memoize(parser, _syllable__content_desinence__content_tone, start, pos, perr)
fail:
	return _memoize(parser, _syllable__content_desinence__content_tone, start, -1, perr)
}

func _syllable__content_desinence__content_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_syllable__content_desinence__content_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _syllable__content_desinence__content_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "syllable<content_desinence, content_tone>"}
	// initial (content_desinence/neutral_desinence content_tone) &boundary
	// initial
	if !_node(parser, _initialNode, node, &pos) {
		goto fail
	}
	// (content_desinence/neutral_desinence content_tone)
	{
		nkids1 := len(node.Kids)
		pos02 := pos
		// content_desinence/neutral_desinence content_tone
		{
			pos5 := pos
			nkids4 := len(node.Kids)
			// content_desinence
			if !_node(parser, _content_desinenceNode, node, &pos) {
				goto fail6
			}
			goto ok3
		fail6:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// neutral_desinence content_tone
			// neutral_desinence
			if !_node(parser, _neutral_desinenceNode, node, &pos) {
				goto fail7
			}
			// content_tone
			if !_node(parser, _content_toneNode, node, &pos) {
				goto fail7
			}
			goto ok3
		fail7:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			goto fail
		ok3:
		}
		sub := _sub(parser, pos02, pos, node.Kids[nkids1:])
		node.Kids = append(node.Kids[:nkids1], sub)
	}
	// &boundary
	{
		pos10 := pos
		nkids11 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail13
		}
		goto ok9
	fail13:
		pos = pos10
		goto fail
	ok9:
		pos = pos10
		node.Kids = node.Kids[:nkids11]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _syllable__content_desinence__content_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _syllable__content_desinence__content_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "syllable__content_desinence__content_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _syllable__content_desinence__content_tone}
	// initial (content_desinence/neutral_desinence content_tone) &boundary
	// initial
	if !_fail(parser, _initialFail, errPos, failure, &pos) {
		goto fail
	}
	// (content_desinence/neutral_desinence content_tone)
	// content_desinence/neutral_desinence content_tone
	{
		pos3 := pos
		// content_desinence
		if !_fail(parser, _content_desinenceFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// neutral_desinence content_tone
		// neutral_desinence
		if !_fail(parser, _neutral_desinenceFail, errPos, failure, &pos) {
			goto fail5
		}
		// content_tone
		if !_fail(parser, _content_toneFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos8 := pos
		nkids9 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail11
		}
		goto ok7
	fail11:
		pos = pos8
		failure.Kids = failure.Kids[:nkids9]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok7:
		pos = pos8
		failure.Kids = failure.Kids[:nkids9]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _syllable__content_desinence__content_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_syllable__content_desinence__content_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _syllable__content_desinence__content_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// initial (content_desinence/neutral_desinence content_tone) &boundary
	{
		var node0 string
		// initial
		if p, n := _initialAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// (content_desinence/neutral_desinence content_tone)
		// content_desinence/neutral_desinence content_tone
		{
			pos3 := pos
			// content_desinence
			if p, n := _content_desinenceAction(parser, pos); n == nil {
				goto fail4
			} else {
				node0 = *n
				pos = p
			}
			goto ok1
		fail4:
			pos = pos3
			// neutral_desinence content_tone
			{
				var node6 string
				// neutral_desinence
				if p, n := _neutral_desinenceAction(parser, pos); n == nil {
					goto fail5
				} else {
					node6 = *n
					pos = p
				}
				node0 += node6
				// content_tone
				if p, n := _content_toneAction(parser, pos); n == nil {
					goto fail5
				} else {
					node6 = *n
					pos = p
				}
				node0 += node6
			}
			goto ok1
		fail5:
			pos = pos3
			goto fail
		ok1:
		}
		node += node0
		// &boundary
		{
			pos8 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail11
			} else {
				pos = p
			}
			goto ok7
		fail11:
			pos = pos8
			goto fail
		ok7:
			pos = pos8
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _syllable__preposition_desinence__preposition_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _syllable__preposition_desinence__preposition_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// initial (preposition_desinence/neutral_desinence preposition_tone) &boundary
	// initial
	if !_accept(parser, _initialAccepts, &pos, &perr) {
		goto fail
	}
	// (preposition_desinence/neutral_desinence preposition_tone)
	// preposition_desinence/neutral_desinence preposition_tone
	{
		pos3 := pos
		// preposition_desinence
		if !_accept(parser, _preposition_desinenceAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// neutral_desinence preposition_tone
		// neutral_desinence
		if !_accept(parser, _neutral_desinenceAccepts, &pos, &perr) {
			goto fail5
		}
		// preposition_tone
		if !_accept(parser, _preposition_toneAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos8 := pos
		perr10 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail11
		}
		goto ok7
	fail11:
		pos = pos8
		perr = _max(perr10, pos)
		goto fail
	ok7:
		pos = pos8
		perr = perr10
	}
	return _memoize(parser, _syllable__preposition_desinence__preposition_tone, start, pos, perr)
fail:
	return _memoize(parser, _syllable__preposition_desinence__preposition_tone, start, -1, perr)
}

func _syllable__preposition_desinence__preposition_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_syllable__preposition_desinence__preposition_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _syllable__preposition_desinence__preposition_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "syllable<preposition_desinence, preposition_tone>"}
	// initial (preposition_desinence/neutral_desinence preposition_tone) &boundary
	// initial
	if !_node(parser, _initialNode, node, &pos) {
		goto fail
	}
	// (preposition_desinence/neutral_desinence preposition_tone)
	{
		nkids1 := len(node.Kids)
		pos02 := pos
		// preposition_desinence/neutral_desinence preposition_tone
		{
			pos5 := pos
			nkids4 := len(node.Kids)
			// preposition_desinence
			if !_node(parser, _preposition_desinenceNode, node, &pos) {
				goto fail6
			}
			goto ok3
		fail6:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// neutral_desinence preposition_tone
			// neutral_desinence
			if !_node(parser, _neutral_desinenceNode, node, &pos) {
				goto fail7
			}
			// preposition_tone
			if !_node(parser, _preposition_toneNode, node, &pos) {
				goto fail7
			}
			goto ok3
		fail7:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			goto fail
		ok3:
		}
		sub := _sub(parser, pos02, pos, node.Kids[nkids1:])
		node.Kids = append(node.Kids[:nkids1], sub)
	}
	// &boundary
	{
		pos10 := pos
		nkids11 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail13
		}
		goto ok9
	fail13:
		pos = pos10
		goto fail
	ok9:
		pos = pos10
		node.Kids = node.Kids[:nkids11]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _syllable__preposition_desinence__preposition_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _syllable__preposition_desinence__preposition_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "syllable__preposition_desinence__preposition_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _syllable__preposition_desinence__preposition_tone}
	// initial (preposition_desinence/neutral_desinence preposition_tone) &boundary
	// initial
	if !_fail(parser, _initialFail, errPos, failure, &pos) {
		goto fail
	}
	// (preposition_desinence/neutral_desinence preposition_tone)
	// preposition_desinence/neutral_desinence preposition_tone
	{
		pos3 := pos
		// preposition_desinence
		if !_fail(parser, _preposition_desinenceFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// neutral_desinence preposition_tone
		// neutral_desinence
		if !_fail(parser, _neutral_desinenceFail, errPos, failure, &pos) {
			goto fail5
		}
		// preposition_tone
		if !_fail(parser, _preposition_toneFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos8 := pos
		nkids9 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail11
		}
		goto ok7
	fail11:
		pos = pos8
		failure.Kids = failure.Kids[:nkids9]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok7:
		pos = pos8
		failure.Kids = failure.Kids[:nkids9]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _syllable__preposition_desinence__preposition_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_syllable__preposition_desinence__preposition_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _syllable__preposition_desinence__preposition_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// initial (preposition_desinence/neutral_desinence preposition_tone) &boundary
	{
		var node0 string
		// initial
		if p, n := _initialAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// (preposition_desinence/neutral_desinence preposition_tone)
		// preposition_desinence/neutral_desinence preposition_tone
		{
			pos3 := pos
			// preposition_desinence
			if p, n := _preposition_desinenceAction(parser, pos); n == nil {
				goto fail4
			} else {
				node0 = *n
				pos = p
			}
			goto ok1
		fail4:
			pos = pos3
			// neutral_desinence preposition_tone
			{
				var node6 string
				// neutral_desinence
				if p, n := _neutral_desinenceAction(parser, pos); n == nil {
					goto fail5
				} else {
					node6 = *n
					pos = p
				}
				node0 += node6
				// preposition_tone
				if p, n := _preposition_toneAction(parser, pos); n == nil {
					goto fail5
				} else {
					node6 = *n
					pos = p
				}
				node0 += node6
			}
			goto ok1
		fail5:
			pos = pos3
			goto fail
		ok1:
		}
		node += node0
		// &boundary
		{
			pos8 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail11
			} else {
				pos = p
			}
			goto ok7
		fail11:
			pos = pos8
			goto fail
		ok7:
			pos = pos8
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _syllable__adverb_desinence__adverb_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _syllable__adverb_desinence__adverb_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// initial (adverb_desinence/neutral_desinence adverb_tone) &boundary
	// initial
	if !_accept(parser, _initialAccepts, &pos, &perr) {
		goto fail
	}
	// (adverb_desinence/neutral_desinence adverb_tone)
	// adverb_desinence/neutral_desinence adverb_tone
	{
		pos3 := pos
		// adverb_desinence
		if !_accept(parser, _adverb_desinenceAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// neutral_desinence adverb_tone
		// neutral_desinence
		if !_accept(parser, _neutral_desinenceAccepts, &pos, &perr) {
			goto fail5
		}
		// adverb_tone
		if !_accept(parser, _adverb_toneAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos8 := pos
		perr10 := perr
		// boundary
		if !_accept(parser, _boundaryAccepts, &pos, &perr) {
			goto fail11
		}
		goto ok7
	fail11:
		pos = pos8
		perr = _max(perr10, pos)
		goto fail
	ok7:
		pos = pos8
		perr = perr10
	}
	return _memoize(parser, _syllable__adverb_desinence__adverb_tone, start, pos, perr)
fail:
	return _memoize(parser, _syllable__adverb_desinence__adverb_tone, start, -1, perr)
}

func _syllable__adverb_desinence__adverb_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_syllable__adverb_desinence__adverb_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _syllable__adverb_desinence__adverb_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "syllable<adverb_desinence, adverb_tone>"}
	// initial (adverb_desinence/neutral_desinence adverb_tone) &boundary
	// initial
	if !_node(parser, _initialNode, node, &pos) {
		goto fail
	}
	// (adverb_desinence/neutral_desinence adverb_tone)
	{
		nkids1 := len(node.Kids)
		pos02 := pos
		// adverb_desinence/neutral_desinence adverb_tone
		{
			pos5 := pos
			nkids4 := len(node.Kids)
			// adverb_desinence
			if !_node(parser, _adverb_desinenceNode, node, &pos) {
				goto fail6
			}
			goto ok3
		fail6:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			// neutral_desinence adverb_tone
			// neutral_desinence
			if !_node(parser, _neutral_desinenceNode, node, &pos) {
				goto fail7
			}
			// adverb_tone
			if !_node(parser, _adverb_toneNode, node, &pos) {
				goto fail7
			}
			goto ok3
		fail7:
			node.Kids = node.Kids[:nkids4]
			pos = pos5
			goto fail
		ok3:
		}
		sub := _sub(parser, pos02, pos, node.Kids[nkids1:])
		node.Kids = append(node.Kids[:nkids1], sub)
	}
	// &boundary
	{
		pos10 := pos
		nkids11 := len(node.Kids)
		// boundary
		if !_node(parser, _boundaryNode, node, &pos) {
			goto fail13
		}
		goto ok9
	fail13:
		pos = pos10
		goto fail
	ok9:
		pos = pos10
		node.Kids = node.Kids[:nkids11]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _syllable__adverb_desinence__adverb_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _syllable__adverb_desinence__adverb_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "syllable__adverb_desinence__adverb_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _syllable__adverb_desinence__adverb_tone}
	// initial (adverb_desinence/neutral_desinence adverb_tone) &boundary
	// initial
	if !_fail(parser, _initialFail, errPos, failure, &pos) {
		goto fail
	}
	// (adverb_desinence/neutral_desinence adverb_tone)
	// adverb_desinence/neutral_desinence adverb_tone
	{
		pos3 := pos
		// adverb_desinence
		if !_fail(parser, _adverb_desinenceFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok1
	fail4:
		pos = pos3
		// neutral_desinence adverb_tone
		// neutral_desinence
		if !_fail(parser, _neutral_desinenceFail, errPos, failure, &pos) {
			goto fail5
		}
		// adverb_tone
		if !_fail(parser, _adverb_toneFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok1
	fail5:
		pos = pos3
		goto fail
	ok1:
	}
	// &boundary
	{
		pos8 := pos
		nkids9 := len(failure.Kids)
		// boundary
		if !_fail(parser, _boundaryFail, errPos, failure, &pos) {
			goto fail11
		}
		goto ok7
	fail11:
		pos = pos8
		failure.Kids = failure.Kids[:nkids9]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "&boundary",
			})
		}
		goto fail
	ok7:
		pos = pos8
		failure.Kids = failure.Kids[:nkids9]
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _syllable__adverb_desinence__adverb_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_syllable__adverb_desinence__adverb_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _syllable__adverb_desinence__adverb_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// initial (adverb_desinence/neutral_desinence adverb_tone) &boundary
	{
		var node0 string
		// initial
		if p, n := _initialAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// (adverb_desinence/neutral_desinence adverb_tone)
		// adverb_desinence/neutral_desinence adverb_tone
		{
			pos3 := pos
			// adverb_desinence
			if p, n := _adverb_desinenceAction(parser, pos); n == nil {
				goto fail4
			} else {
				node0 = *n
				pos = p
			}
			goto ok1
		fail4:
			pos = pos3
			// neutral_desinence adverb_tone
			{
				var node6 string
				// neutral_desinence
				if p, n := _neutral_desinenceAction(parser, pos); n == nil {
					goto fail5
				} else {
					node6 = *n
					pos = p
				}
				node0 += node6
				// adverb_tone
				if p, n := _adverb_toneAction(parser, pos); n == nil {
					goto fail5
				} else {
					node6 = *n
					pos = p
				}
				node0 += node6
			}
			goto ok1
		fail5:
			pos = pos3
			goto fail
		ok1:
		}
		node += node0
		// &boundary
		{
			pos8 := pos
			// boundary
			if p, n := _boundaryAction(parser, pos); n == nil {
				goto fail11
			} else {
				pos = p
			}
			goto ok7
		fail11:
			pos = pos8
			goto fail
		ok7:
			pos = pos8
			node = ""
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _neutral_syllableAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _neutral_syllable, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// initial neutral_desinence spaces?
	// initial
	if !_accept(parser, _initialAccepts, &pos, &perr) {
		goto fail
	}
	// neutral_desinence
	if !_accept(parser, _neutral_desinenceAccepts, &pos, &perr) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	return _memoize(parser, _neutral_syllable, start, pos, perr)
fail:
	return _memoize(parser, _neutral_syllable, start, -1, perr)
}

func _neutral_syllableNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_neutral_syllable]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _neutral_syllable}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "neutral_syllable"}
	// initial neutral_desinence spaces?
	// initial
	if !_node(parser, _initialNode, node, &pos) {
		goto fail
	}
	// neutral_desinence
	if !_node(parser, _neutral_desinenceNode, node, &pos) {
		goto fail
	}
	// spaces?
	{
		nkids1 := len(node.Kids)
		pos2 := pos
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
	ok4:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _neutral_syllableFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _neutral_syllable, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "neutral_syllable",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _neutral_syllable}
	// initial neutral_desinence spaces?
	// initial
	if !_fail(parser, _initialFail, errPos, failure, &pos) {
		goto fail
	}
	// neutral_desinence
	if !_fail(parser, _neutral_desinenceFail, errPos, failure, &pos) {
		goto fail
	}
	// spaces?
	{
		pos2 := pos
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok4
	fail3:
		pos = pos2
	ok4:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _neutral_syllableAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_neutral_syllable]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _neutral_syllable}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// initial neutral_desinence spaces?
	{
		var node0 string
		// initial
		if p, n := _initialAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// neutral_desinence
		if p, n := _neutral_desinenceAction(parser, pos); n == nil {
			goto fail
		} else {
			node0 = *n
			pos = p
		}
		node += node0
		// spaces?
		{
			pos2 := pos
			// spaces
			if p, n := _spacesAction(parser, pos); n == nil {
				goto fail3
			} else {
				node0 = *n
				pos = p
			}
			goto ok4
		fail3:
			node0 = ""
			pos = pos2
		ok4:
		}
		node += node0
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _compound_syllableAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _compound_syllable, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// syllable<compound_desinence, compound_tone>
	if !_accept(parser, _syllable__compound_desinence__compound_toneAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _compound_syllable, start, pos, perr)
fail:
	return _memoize(parser, _compound_syllable, start, -1, perr)
}

func _compound_syllableNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_compound_syllable]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _compound_syllable}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "compound_syllable"}
	// syllable<compound_desinence, compound_tone>
	if !_node(parser, _syllable__compound_desinence__compound_toneNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _compound_syllableFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _compound_syllable, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "compound_syllable",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _compound_syllable}
	// syllable<compound_desinence, compound_tone>
	if !_fail(parser, _syllable__compound_desinence__compound_toneFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _compound_syllableAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_compound_syllable]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _compound_syllable}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// syllable<compound_desinence, compound_tone>
	if p, n := _syllable__compound_desinence__compound_toneAction(parser, pos); n == nil {
		goto fail
	} else {
		node = *n
		pos = p
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _arg_syllableAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _arg_syllable, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// syllable<arg_desinence, arg_tone>
	if !_accept(parser, _syllable__arg_desinence__arg_toneAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _arg_syllable, start, pos, perr)
fail:
	return _memoize(parser, _arg_syllable, start, -1, perr)
}

func _arg_syllableNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_arg_syllable]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _arg_syllable}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "arg_syllable"}
	// syllable<arg_desinence, arg_tone>
	if !_node(parser, _syllable__arg_desinence__arg_toneNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _arg_syllableFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _arg_syllable, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "arg_syllable",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _arg_syllable}
	// syllable<arg_desinence, arg_tone>
	if !_fail(parser, _syllable__arg_desinence__arg_toneFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _arg_syllableAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_arg_syllable]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _arg_syllable}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// syllable<arg_desinence, arg_tone>
	if p, n := _syllable__arg_desinence__arg_toneAction(parser, pos); n == nil {
		goto fail
	} else {
		node = *n
		pos = p
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _relative_syllableAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _relative_syllable, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// syllable<relative_desinence, relative_tone>
	if !_accept(parser, _syllable__relative_desinence__relative_toneAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _relative_syllable, start, pos, perr)
fail:
	return _memoize(parser, _relative_syllable, start, -1, perr)
}

func _relative_syllableNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_relative_syllable]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_syllable}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "relative_syllable"}
	// syllable<relative_desinence, relative_tone>
	if !_node(parser, _syllable__relative_desinence__relative_toneNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _relative_syllableFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _relative_syllable, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "relative_syllable",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _relative_syllable}
	// syllable<relative_desinence, relative_tone>
	if !_fail(parser, _syllable__relative_desinence__relative_toneFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _relative_syllableAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_relative_syllable]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_syllable}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// syllable<relative_desinence, relative_tone>
	if p, n := _syllable__relative_desinence__relative_toneAction(parser, pos); n == nil {
		goto fail
	} else {
		node = *n
		pos = p
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _verb_syllableAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _verb_syllable, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// syllable<verb_desinence, verb_tone>
	if !_accept(parser, _syllable__verb_desinence__verb_toneAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _verb_syllable, start, pos, perr)
fail:
	return _memoize(parser, _verb_syllable, start, -1, perr)
}

func _verb_syllableNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_verb_syllable]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _verb_syllable}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "verb_syllable"}
	// syllable<verb_desinence, verb_tone>
	if !_node(parser, _syllable__verb_desinence__verb_toneNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _verb_syllableFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _verb_syllable, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "verb_syllable",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _verb_syllable}
	// syllable<verb_desinence, verb_tone>
	if !_fail(parser, _syllable__verb_desinence__verb_toneFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _verb_syllableAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_verb_syllable]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _verb_syllable}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// syllable<verb_desinence, verb_tone>
	if p, n := _syllable__verb_desinence__verb_toneAction(parser, pos); n == nil {
		goto fail
	} else {
		node = *n
		pos = p
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _content_syllableAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _content_syllable, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// syllable<content_desinence, content_tone>
	if !_accept(parser, _syllable__content_desinence__content_toneAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _content_syllable, start, pos, perr)
fail:
	return _memoize(parser, _content_syllable, start, -1, perr)
}

func _content_syllableNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_content_syllable]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _content_syllable}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "content_syllable"}
	// syllable<content_desinence, content_tone>
	if !_node(parser, _syllable__content_desinence__content_toneNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _content_syllableFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _content_syllable, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "content_syllable",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _content_syllable}
	// syllable<content_desinence, content_tone>
	if !_fail(parser, _syllable__content_desinence__content_toneFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _content_syllableAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_content_syllable]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _content_syllable}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// syllable<content_desinence, content_tone>
	if p, n := _syllable__content_desinence__content_toneAction(parser, pos); n == nil {
		goto fail
	} else {
		node = *n
		pos = p
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _preposition_syllableAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _preposition_syllable, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// syllable<preposition_desinence, preposition_tone>
	if !_accept(parser, _syllable__preposition_desinence__preposition_toneAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _preposition_syllable, start, pos, perr)
fail:
	return _memoize(parser, _preposition_syllable, start, -1, perr)
}

func _preposition_syllableNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_preposition_syllable]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _preposition_syllable}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "preposition_syllable"}
	// syllable<preposition_desinence, preposition_tone>
	if !_node(parser, _syllable__preposition_desinence__preposition_toneNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _preposition_syllableFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _preposition_syllable, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "preposition_syllable",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _preposition_syllable}
	// syllable<preposition_desinence, preposition_tone>
	if !_fail(parser, _syllable__preposition_desinence__preposition_toneFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _preposition_syllableAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_preposition_syllable]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _preposition_syllable}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// syllable<preposition_desinence, preposition_tone>
	if p, n := _syllable__preposition_desinence__preposition_toneAction(parser, pos); n == nil {
		goto fail
	} else {
		node = *n
		pos = p
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _adverb_syllableAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _adverb_syllable, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// syllable<adverb_desinence, adverb_tone>
	if !_accept(parser, _syllable__adverb_desinence__adverb_toneAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _adverb_syllable, start, pos, perr)
fail:
	return _memoize(parser, _adverb_syllable, start, -1, perr)
}

func _adverb_syllableNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_adverb_syllable]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _adverb_syllable}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "adverb_syllable"}
	// syllable<adverb_desinence, adverb_tone>
	if !_node(parser, _syllable__adverb_desinence__adverb_toneNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _adverb_syllableFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _adverb_syllable, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "adverb_syllable",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _adverb_syllable}
	// syllable<adverb_desinence, adverb_tone>
	if !_fail(parser, _syllable__adverb_desinence__adverb_toneFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _adverb_syllableAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_adverb_syllable]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _adverb_syllable}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// syllable<adverb_desinence, adverb_tone>
	if p, n := _syllable__adverb_desinence__adverb_toneAction(parser, pos); n == nil {
		goto fail
	} else {
		node = *n
		pos = p
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _boundaryAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _boundary, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// initial/spaces/EOF
	{
		pos2 := pos
		// initial
		if !_accept(parser, _initialAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// spaces
		if !_accept(parser, _spacesAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// EOF
		if !_accept(parser, _EOFAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _boundary, start, pos, perr)
fail:
	return _memoize(parser, _boundary, start, -1, perr)
}

func _boundaryNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_boundary]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _boundary}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "boundary"}
	// initial/spaces/EOF
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// initial
		if !_node(parser, _initialNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// spaces
		if !_node(parser, _spacesNode, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// EOF
		if !_node(parser, _EOFNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _boundaryFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _boundary, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "boundary",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _boundary}
	// initial/spaces/EOF
	{
		pos2 := pos
		// initial
		if !_fail(parser, _initialFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// spaces
		if !_fail(parser, _spacesFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// EOF
		if !_fail(parser, _EOFFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _boundaryAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_boundary]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _boundary}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// initial/spaces/EOF
	{
		pos2 := pos
		// initial
		if p, n := _initialAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// spaces
		if p, n := _spacesAction(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		// EOF
		if p, n := _EOFAction(parser, pos); n == nil {
			goto fail5
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail5:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _initialAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _initial, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// b/c h/c/d/f/g/h/j/k/l/m/n/p/r/s h/s/t
	{
		pos2 := pos
		// b
		if !_accept(parser, _bAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// c h
		// c
		if !_accept(parser, _cAccepts, &pos, &perr) {
			goto fail4
		}
		// h
		if !_accept(parser, _hAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// c
		if !_accept(parser, _cAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// d
		if !_accept(parser, _dAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// f
		if !_accept(parser, _fAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// g
		if !_accept(parser, _gAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// h
		if !_accept(parser, _hAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		// j
		if !_accept(parser, _jAccepts, &pos, &perr) {
			goto fail11
		}
		goto ok0
	fail11:
		pos = pos2
		// k
		if !_accept(parser, _kAccepts, &pos, &perr) {
			goto fail12
		}
		goto ok0
	fail12:
		pos = pos2
		// l
		if !_accept(parser, _lAccepts, &pos, &perr) {
			goto fail13
		}
		goto ok0
	fail13:
		pos = pos2
		// m
		if !_accept(parser, _mAccepts, &pos, &perr) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// n
		if !_accept(parser, _nAccepts, &pos, &perr) {
			goto fail15
		}
		goto ok0
	fail15:
		pos = pos2
		// p
		if !_accept(parser, _pAccepts, &pos, &perr) {
			goto fail16
		}
		goto ok0
	fail16:
		pos = pos2
		// r
		if !_accept(parser, _rAccepts, &pos, &perr) {
			goto fail17
		}
		goto ok0
	fail17:
		pos = pos2
		// s h
		// s
		if !_accept(parser, _sAccepts, &pos, &perr) {
			goto fail18
		}
		// h
		if !_accept(parser, _hAccepts, &pos, &perr) {
			goto fail18
		}
		goto ok0
	fail18:
		pos = pos2
		// s
		if !_accept(parser, _sAccepts, &pos, &perr) {
			goto fail20
		}
		goto ok0
	fail20:
		pos = pos2
		// t
		if !_accept(parser, _tAccepts, &pos, &perr) {
			goto fail21
		}
		goto ok0
	fail21:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _initial, start, pos, perr)
fail:
	return _memoize(parser, _initial, start, -1, perr)
}

func _initialNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_initial]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _initial}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "initial"}
	// b/c h/c/d/f/g/h/j/k/l/m/n/p/r/s h/s/t
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// b
		if !_node(parser, _bNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// c h
		// c
		if !_node(parser, _cNode, node, &pos) {
			goto fail4
		}
		// h
		if !_node(parser, _hNode, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// c
		if !_node(parser, _cNode, node, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// d
		if !_node(parser, _dNode, node, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// f
		if !_node(parser, _fNode, node, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// g
		if !_node(parser, _gNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// h
		if !_node(parser, _hNode, node, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// j
		if !_node(parser, _jNode, node, &pos) {
			goto fail11
		}
		goto ok0
	fail11:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// k
		if !_node(parser, _kNode, node, &pos) {
			goto fail12
		}
		goto ok0
	fail12:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// l
		if !_node(parser, _lNode, node, &pos) {
			goto fail13
		}
		goto ok0
	fail13:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// m
		if !_node(parser, _mNode, node, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// n
		if !_node(parser, _nNode, node, &pos) {
			goto fail15
		}
		goto ok0
	fail15:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// p
		if !_node(parser, _pNode, node, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// r
		if !_node(parser, _rNode, node, &pos) {
			goto fail17
		}
		goto ok0
	fail17:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// s h
		// s
		if !_node(parser, _sNode, node, &pos) {
			goto fail18
		}
		// h
		if !_node(parser, _hNode, node, &pos) {
			goto fail18
		}
		goto ok0
	fail18:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// s
		if !_node(parser, _sNode, node, &pos) {
			goto fail20
		}
		goto ok0
	fail20:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// t
		if !_node(parser, _tNode, node, &pos) {
			goto fail21
		}
		goto ok0
	fail21:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _initialFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _initial, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "initial",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _initial}
	// b/c h/c/d/f/g/h/j/k/l/m/n/p/r/s h/s/t
	{
		pos2 := pos
		// b
		if !_fail(parser, _bFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// c h
		// c
		if !_fail(parser, _cFail, errPos, failure, &pos) {
			goto fail4
		}
		// h
		if !_fail(parser, _hFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// c
		if !_fail(parser, _cFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// d
		if !_fail(parser, _dFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// f
		if !_fail(parser, _fFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// g
		if !_fail(parser, _gFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// h
		if !_fail(parser, _hFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		// j
		if !_fail(parser, _jFail, errPos, failure, &pos) {
			goto fail11
		}
		goto ok0
	fail11:
		pos = pos2
		// k
		if !_fail(parser, _kFail, errPos, failure, &pos) {
			goto fail12
		}
		goto ok0
	fail12:
		pos = pos2
		// l
		if !_fail(parser, _lFail, errPos, failure, &pos) {
			goto fail13
		}
		goto ok0
	fail13:
		pos = pos2
		// m
		if !_fail(parser, _mFail, errPos, failure, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// n
		if !_fail(parser, _nFail, errPos, failure, &pos) {
			goto fail15
		}
		goto ok0
	fail15:
		pos = pos2
		// p
		if !_fail(parser, _pFail, errPos, failure, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		pos = pos2
		// r
		if !_fail(parser, _rFail, errPos, failure, &pos) {
			goto fail17
		}
		goto ok0
	fail17:
		pos = pos2
		// s h
		// s
		if !_fail(parser, _sFail, errPos, failure, &pos) {
			goto fail18
		}
		// h
		if !_fail(parser, _hFail, errPos, failure, &pos) {
			goto fail18
		}
		goto ok0
	fail18:
		pos = pos2
		// s
		if !_fail(parser, _sFail, errPos, failure, &pos) {
			goto fail20
		}
		goto ok0
	fail20:
		pos = pos2
		// t
		if !_fail(parser, _tFail, errPos, failure, &pos) {
			goto fail21
		}
		goto ok0
	fail21:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _initialAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_initial]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _initial}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// b/c h/c/d/f/g/h/j/k/l/m/n/p/r/s h/s/t
	{
		pos2 := pos
		// b
		if p, n := _bAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// c h
		{
			var node5 string
			// c
			if p, n := _cAction(parser, pos); n == nil {
				goto fail4
			} else {
				node5 = *n
				pos = p
			}
			node += node5
			// h
			if p, n := _hAction(parser, pos); n == nil {
				goto fail4
			} else {
				node5 = *n
				pos = p
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		// c
		if p, n := _cAction(parser, pos); n == nil {
			goto fail6
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail6:
		pos = pos2
		// d
		if p, n := _dAction(parser, pos); n == nil {
			goto fail7
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail7:
		pos = pos2
		// f
		if p, n := _fAction(parser, pos); n == nil {
			goto fail8
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail8:
		pos = pos2
		// g
		if p, n := _gAction(parser, pos); n == nil {
			goto fail9
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail9:
		pos = pos2
		// h
		if p, n := _hAction(parser, pos); n == nil {
			goto fail10
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail10:
		pos = pos2
		// j
		if p, n := _jAction(parser, pos); n == nil {
			goto fail11
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail11:
		pos = pos2
		// k
		if p, n := _kAction(parser, pos); n == nil {
			goto fail12
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail12:
		pos = pos2
		// l
		if p, n := _lAction(parser, pos); n == nil {
			goto fail13
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail13:
		pos = pos2
		// m
		if p, n := _mAction(parser, pos); n == nil {
			goto fail14
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail14:
		pos = pos2
		// n
		if p, n := _nAction(parser, pos); n == nil {
			goto fail15
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail15:
		pos = pos2
		// p
		if p, n := _pAction(parser, pos); n == nil {
			goto fail16
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail16:
		pos = pos2
		// r
		if p, n := _rAction(parser, pos); n == nil {
			goto fail17
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail17:
		pos = pos2
		// s h
		{
			var node19 string
			// s
			if p, n := _sAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
			// h
			if p, n := _hAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
		}
		goto ok0
	fail18:
		pos = pos2
		// s
		if p, n := _sAction(parser, pos); n == nil {
			goto fail20
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail20:
		pos = pos2
		// t
		if p, n := _tAction(parser, pos); n == nil {
			goto fail21
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail21:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _desinence__a__u__i__o__eAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _desinence__a__u__i__o__e, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// a o/a i/a q/a/u a o/u a i/u e q/u e/u o q/u o/u i/u a q/u a/u q/u/i a o/i a i/i e q/i e/i o q/i o/i u/i a q/i a/i q/i/o e q/o e/o i/o a q/o a/o q/o/e o q/e o/e i/e a q/e a/e q/e
	{
		pos2 := pos
		// a o
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail3
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// a i
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail5
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// a q
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail7
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// u a o
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail10
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail10
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		// u a i
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail12
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail12
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail12
		}
		goto ok0
	fail12:
		pos = pos2
		// u e q
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail14
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail14
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// u e
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail16
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail16
		}
		goto ok0
	fail16:
		pos = pos2
		// u o q
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail18
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail18
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail18
		}
		goto ok0
	fail18:
		pos = pos2
		// u o
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail20
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail20
		}
		goto ok0
	fail20:
		pos = pos2
		// u i
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail22
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail22
		}
		goto ok0
	fail22:
		pos = pos2
		// u a q
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail24
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail24
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail24
		}
		goto ok0
	fail24:
		pos = pos2
		// u a
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail26
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail26
		}
		goto ok0
	fail26:
		pos = pos2
		// u q
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail28
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail28
		}
		goto ok0
	fail28:
		pos = pos2
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail30
		}
		goto ok0
	fail30:
		pos = pos2
		// i a o
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail31
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail31
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail31
		}
		goto ok0
	fail31:
		pos = pos2
		// i a i
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail33
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail33
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail33
		}
		goto ok0
	fail33:
		pos = pos2
		// i e q
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail35
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail35
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail35
		}
		goto ok0
	fail35:
		pos = pos2
		// i e
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail37
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail37
		}
		goto ok0
	fail37:
		pos = pos2
		// i o q
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail39
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail39
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail39
		}
		goto ok0
	fail39:
		pos = pos2
		// i o
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail41
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail41
		}
		goto ok0
	fail41:
		pos = pos2
		// i u
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail43
		}
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail43
		}
		goto ok0
	fail43:
		pos = pos2
		// i a q
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail45
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail45
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail45
		}
		goto ok0
	fail45:
		pos = pos2
		// i a
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail47
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail47
		}
		goto ok0
	fail47:
		pos = pos2
		// i q
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail49
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail49
		}
		goto ok0
	fail49:
		pos = pos2
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail51
		}
		goto ok0
	fail51:
		pos = pos2
		// o e q
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail52
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail52
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail52
		}
		goto ok0
	fail52:
		pos = pos2
		// o e
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail54
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail54
		}
		goto ok0
	fail54:
		pos = pos2
		// o i
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail56
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail56
		}
		goto ok0
	fail56:
		pos = pos2
		// o a q
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail58
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail58
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail58
		}
		goto ok0
	fail58:
		pos = pos2
		// o a
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail60
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail60
		}
		goto ok0
	fail60:
		pos = pos2
		// o q
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail62
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail62
		}
		goto ok0
	fail62:
		pos = pos2
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail64
		}
		goto ok0
	fail64:
		pos = pos2
		// e o q
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail65
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail65
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail65
		}
		goto ok0
	fail65:
		pos = pos2
		// e o
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail67
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail67
		}
		goto ok0
	fail67:
		pos = pos2
		// e i
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail69
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail69
		}
		goto ok0
	fail69:
		pos = pos2
		// e a q
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail71
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail71
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail71
		}
		goto ok0
	fail71:
		pos = pos2
		// e a
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail73
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail73
		}
		goto ok0
	fail73:
		pos = pos2
		// e q
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail75
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail75
		}
		goto ok0
	fail75:
		pos = pos2
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail77
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _desinence__a__u__i__o__e, start, pos, perr)
fail:
	return _memoize(parser, _desinence__a__u__i__o__e, start, -1, perr)
}

func _desinence__a__u__i__o__eNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_desinence__a__u__i__o__e]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _desinence__a__u__i__o__e}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "desinence<a, u, i, o, e>"}
	// a o/a i/a q/a/u a o/u a i/u e q/u e/u o q/u o/u i/u a q/u a/u q/u/i a o/i a i/i e q/i e/i o q/i o/i u/i a q/i a/i q/i/o e q/o e/o i/o a q/o a/o q/o/e o q/e o/e i/e a q/e a/e q/e
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// a o
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail3
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// a i
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail5
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// a q
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail7
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// u a o
		// u
		if !_node(parser, _uNode, node, &pos) {
			goto fail10
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail10
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// u a i
		// u
		if !_node(parser, _uNode, node, &pos) {
			goto fail12
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail12
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail12
		}
		goto ok0
	fail12:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// u e q
		// u
		if !_node(parser, _uNode, node, &pos) {
			goto fail14
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail14
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// u e
		// u
		if !_node(parser, _uNode, node, &pos) {
			goto fail16
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// u o q
		// u
		if !_node(parser, _uNode, node, &pos) {
			goto fail18
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail18
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail18
		}
		goto ok0
	fail18:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// u o
		// u
		if !_node(parser, _uNode, node, &pos) {
			goto fail20
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail20
		}
		goto ok0
	fail20:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// u i
		// u
		if !_node(parser, _uNode, node, &pos) {
			goto fail22
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail22
		}
		goto ok0
	fail22:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// u a q
		// u
		if !_node(parser, _uNode, node, &pos) {
			goto fail24
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail24
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail24
		}
		goto ok0
	fail24:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// u a
		// u
		if !_node(parser, _uNode, node, &pos) {
			goto fail26
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail26
		}
		goto ok0
	fail26:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// u q
		// u
		if !_node(parser, _uNode, node, &pos) {
			goto fail28
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail28
		}
		goto ok0
	fail28:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// u
		if !_node(parser, _uNode, node, &pos) {
			goto fail30
		}
		goto ok0
	fail30:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// i a o
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail31
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail31
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail31
		}
		goto ok0
	fail31:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// i a i
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail33
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail33
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail33
		}
		goto ok0
	fail33:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// i e q
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail35
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail35
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail35
		}
		goto ok0
	fail35:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// i e
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail37
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail37
		}
		goto ok0
	fail37:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// i o q
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail39
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail39
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail39
		}
		goto ok0
	fail39:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// i o
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail41
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail41
		}
		goto ok0
	fail41:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// i u
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail43
		}
		// u
		if !_node(parser, _uNode, node, &pos) {
			goto fail43
		}
		goto ok0
	fail43:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// i a q
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail45
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail45
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail45
		}
		goto ok0
	fail45:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// i a
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail47
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail47
		}
		goto ok0
	fail47:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// i q
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail49
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail49
		}
		goto ok0
	fail49:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail51
		}
		goto ok0
	fail51:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// o e q
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail52
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail52
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail52
		}
		goto ok0
	fail52:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// o e
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail54
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail54
		}
		goto ok0
	fail54:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// o i
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail56
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail56
		}
		goto ok0
	fail56:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// o a q
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail58
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail58
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail58
		}
		goto ok0
	fail58:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// o a
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail60
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail60
		}
		goto ok0
	fail60:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// o q
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail62
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail62
		}
		goto ok0
	fail62:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail64
		}
		goto ok0
	fail64:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// e o q
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail65
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail65
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail65
		}
		goto ok0
	fail65:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// e o
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail67
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail67
		}
		goto ok0
	fail67:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// e i
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail69
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail69
		}
		goto ok0
	fail69:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// e a q
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail71
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail71
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail71
		}
		goto ok0
	fail71:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// e a
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail73
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail73
		}
		goto ok0
	fail73:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// e q
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail75
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail75
		}
		goto ok0
	fail75:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail77
		}
		goto ok0
	fail77:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _desinence__a__u__i__o__eFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _desinence__a__u__i__o__e, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "desinence__a__u__i__o__e",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _desinence__a__u__i__o__e}
	// a o/a i/a q/a/u a o/u a i/u e q/u e/u o q/u o/u i/u a q/u a/u q/u/i a o/i a i/i e q/i e/i o q/i o/i u/i a q/i a/i q/i/o e q/o e/o i/o a q/o a/o q/o/e o q/e o/e i/e a q/e a/e q/e
	{
		pos2 := pos
		// a o
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail3
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// a i
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail5
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// a q
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail7
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// u a o
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail10
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail10
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		// u a i
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail12
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail12
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail12
		}
		goto ok0
	fail12:
		pos = pos2
		// u e q
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail14
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail14
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// u e
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail16
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		pos = pos2
		// u o q
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail18
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail18
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail18
		}
		goto ok0
	fail18:
		pos = pos2
		// u o
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail20
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail20
		}
		goto ok0
	fail20:
		pos = pos2
		// u i
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail22
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail22
		}
		goto ok0
	fail22:
		pos = pos2
		// u a q
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail24
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail24
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail24
		}
		goto ok0
	fail24:
		pos = pos2
		// u a
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail26
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail26
		}
		goto ok0
	fail26:
		pos = pos2
		// u q
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail28
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail28
		}
		goto ok0
	fail28:
		pos = pos2
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail30
		}
		goto ok0
	fail30:
		pos = pos2
		// i a o
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail31
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail31
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail31
		}
		goto ok0
	fail31:
		pos = pos2
		// i a i
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail33
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail33
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail33
		}
		goto ok0
	fail33:
		pos = pos2
		// i e q
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail35
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail35
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail35
		}
		goto ok0
	fail35:
		pos = pos2
		// i e
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail37
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail37
		}
		goto ok0
	fail37:
		pos = pos2
		// i o q
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail39
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail39
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail39
		}
		goto ok0
	fail39:
		pos = pos2
		// i o
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail41
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail41
		}
		goto ok0
	fail41:
		pos = pos2
		// i u
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail43
		}
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail43
		}
		goto ok0
	fail43:
		pos = pos2
		// i a q
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail45
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail45
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail45
		}
		goto ok0
	fail45:
		pos = pos2
		// i a
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail47
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail47
		}
		goto ok0
	fail47:
		pos = pos2
		// i q
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail49
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail49
		}
		goto ok0
	fail49:
		pos = pos2
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail51
		}
		goto ok0
	fail51:
		pos = pos2
		// o e q
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail52
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail52
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail52
		}
		goto ok0
	fail52:
		pos = pos2
		// o e
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail54
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail54
		}
		goto ok0
	fail54:
		pos = pos2
		// o i
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail56
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail56
		}
		goto ok0
	fail56:
		pos = pos2
		// o a q
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail58
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail58
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail58
		}
		goto ok0
	fail58:
		pos = pos2
		// o a
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail60
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail60
		}
		goto ok0
	fail60:
		pos = pos2
		// o q
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail62
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail62
		}
		goto ok0
	fail62:
		pos = pos2
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail64
		}
		goto ok0
	fail64:
		pos = pos2
		// e o q
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail65
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail65
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail65
		}
		goto ok0
	fail65:
		pos = pos2
		// e o
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail67
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail67
		}
		goto ok0
	fail67:
		pos = pos2
		// e i
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail69
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail69
		}
		goto ok0
	fail69:
		pos = pos2
		// e a q
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail71
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail71
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail71
		}
		goto ok0
	fail71:
		pos = pos2
		// e a
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail73
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail73
		}
		goto ok0
	fail73:
		pos = pos2
		// e q
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail75
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail75
		}
		goto ok0
	fail75:
		pos = pos2
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail77
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _desinence__a__u__i__o__eAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_desinence__a__u__i__o__e]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _desinence__a__u__i__o__e}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// a o/a i/a q/a/u a o/u a i/u e q/u e/u o q/u o/u i/u a q/u a/u q/u/i a o/i a i/i e q/i e/i o q/i o/i u/i a q/i a/i q/i/o e q/o e/o i/o a q/o a/o q/o/e o q/e o/e i/e a q/e a/e q/e
	{
		pos2 := pos
		// a o
		{
			var node4 string
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
		}
		goto ok0
	fail3:
		pos = pos2
		// a i
		{
			var node6 string
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail5
			} else {
				node6 = *n
				pos = p
			}
			node += node6
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail5
			} else {
				node6 = *n
				pos = p
			}
			node += node6
		}
		goto ok0
	fail5:
		pos = pos2
		// a q
		{
			var node8 string
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail7
			} else {
				node8 = *n
				pos = p
			}
			node += node8
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail7
			} else {
				node8 = *n
				pos = p
			}
			node += node8
		}
		goto ok0
	fail7:
		pos = pos2
		// a
		if p, n := _aAction(parser, pos); n == nil {
			goto fail9
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail9:
		pos = pos2
		// u a o
		{
			var node11 string
			// u
			if p, n := _uAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
		}
		goto ok0
	fail10:
		pos = pos2
		// u a i
		{
			var node13 string
			// u
			if p, n := _uAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
		}
		goto ok0
	fail12:
		pos = pos2
		// u e q
		{
			var node15 string
			// u
			if p, n := _uAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
		}
		goto ok0
	fail14:
		pos = pos2
		// u e
		{
			var node17 string
			// u
			if p, n := _uAction(parser, pos); n == nil {
				goto fail16
			} else {
				node17 = *n
				pos = p
			}
			node += node17
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail16
			} else {
				node17 = *n
				pos = p
			}
			node += node17
		}
		goto ok0
	fail16:
		pos = pos2
		// u o q
		{
			var node19 string
			// u
			if p, n := _uAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
		}
		goto ok0
	fail18:
		pos = pos2
		// u o
		{
			var node21 string
			// u
			if p, n := _uAction(parser, pos); n == nil {
				goto fail20
			} else {
				node21 = *n
				pos = p
			}
			node += node21
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail20
			} else {
				node21 = *n
				pos = p
			}
			node += node21
		}
		goto ok0
	fail20:
		pos = pos2
		// u i
		{
			var node23 string
			// u
			if p, n := _uAction(parser, pos); n == nil {
				goto fail22
			} else {
				node23 = *n
				pos = p
			}
			node += node23
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail22
			} else {
				node23 = *n
				pos = p
			}
			node += node23
		}
		goto ok0
	fail22:
		pos = pos2
		// u a q
		{
			var node25 string
			// u
			if p, n := _uAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
		}
		goto ok0
	fail24:
		pos = pos2
		// u a
		{
			var node27 string
			// u
			if p, n := _uAction(parser, pos); n == nil {
				goto fail26
			} else {
				node27 = *n
				pos = p
			}
			node += node27
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail26
			} else {
				node27 = *n
				pos = p
			}
			node += node27
		}
		goto ok0
	fail26:
		pos = pos2
		// u q
		{
			var node29 string
			// u
			if p, n := _uAction(parser, pos); n == nil {
				goto fail28
			} else {
				node29 = *n
				pos = p
			}
			node += node29
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail28
			} else {
				node29 = *n
				pos = p
			}
			node += node29
		}
		goto ok0
	fail28:
		pos = pos2
		// u
		if p, n := _uAction(parser, pos); n == nil {
			goto fail30
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail30:
		pos = pos2
		// i a o
		{
			var node32 string
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
		}
		goto ok0
	fail31:
		pos = pos2
		// i a i
		{
			var node34 string
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
		}
		goto ok0
	fail33:
		pos = pos2
		// i e q
		{
			var node36 string
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
		}
		goto ok0
	fail35:
		pos = pos2
		// i e
		{
			var node38 string
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail37
			} else {
				node38 = *n
				pos = p
			}
			node += node38
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail37
			} else {
				node38 = *n
				pos = p
			}
			node += node38
		}
		goto ok0
	fail37:
		pos = pos2
		// i o q
		{
			var node40 string
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
		}
		goto ok0
	fail39:
		pos = pos2
		// i o
		{
			var node42 string
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail41
			} else {
				node42 = *n
				pos = p
			}
			node += node42
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail41
			} else {
				node42 = *n
				pos = p
			}
			node += node42
		}
		goto ok0
	fail41:
		pos = pos2
		// i u
		{
			var node44 string
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail43
			} else {
				node44 = *n
				pos = p
			}
			node += node44
			// u
			if p, n := _uAction(parser, pos); n == nil {
				goto fail43
			} else {
				node44 = *n
				pos = p
			}
			node += node44
		}
		goto ok0
	fail43:
		pos = pos2
		// i a q
		{
			var node46 string
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
		}
		goto ok0
	fail45:
		pos = pos2
		// i a
		{
			var node48 string
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail47
			} else {
				node48 = *n
				pos = p
			}
			node += node48
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail47
			} else {
				node48 = *n
				pos = p
			}
			node += node48
		}
		goto ok0
	fail47:
		pos = pos2
		// i q
		{
			var node50 string
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail49
			} else {
				node50 = *n
				pos = p
			}
			node += node50
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail49
			} else {
				node50 = *n
				pos = p
			}
			node += node50
		}
		goto ok0
	fail49:
		pos = pos2
		// i
		if p, n := _iAction(parser, pos); n == nil {
			goto fail51
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail51:
		pos = pos2
		// o e q
		{
			var node53 string
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
		}
		goto ok0
	fail52:
		pos = pos2
		// o e
		{
			var node55 string
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail54
			} else {
				node55 = *n
				pos = p
			}
			node += node55
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail54
			} else {
				node55 = *n
				pos = p
			}
			node += node55
		}
		goto ok0
	fail54:
		pos = pos2
		// o i
		{
			var node57 string
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail56
			} else {
				node57 = *n
				pos = p
			}
			node += node57
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail56
			} else {
				node57 = *n
				pos = p
			}
			node += node57
		}
		goto ok0
	fail56:
		pos = pos2
		// o a q
		{
			var node59 string
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
		}
		goto ok0
	fail58:
		pos = pos2
		// o a
		{
			var node61 string
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail60
			} else {
				node61 = *n
				pos = p
			}
			node += node61
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail60
			} else {
				node61 = *n
				pos = p
			}
			node += node61
		}
		goto ok0
	fail60:
		pos = pos2
		// o q
		{
			var node63 string
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail62
			} else {
				node63 = *n
				pos = p
			}
			node += node63
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail62
			} else {
				node63 = *n
				pos = p
			}
			node += node63
		}
		goto ok0
	fail62:
		pos = pos2
		// o
		if p, n := _oAction(parser, pos); n == nil {
			goto fail64
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail64:
		pos = pos2
		// e o q
		{
			var node66 string
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
		}
		goto ok0
	fail65:
		pos = pos2
		// e o
		{
			var node68 string
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail67
			} else {
				node68 = *n
				pos = p
			}
			node += node68
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail67
			} else {
				node68 = *n
				pos = p
			}
			node += node68
		}
		goto ok0
	fail67:
		pos = pos2
		// e i
		{
			var node70 string
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail69
			} else {
				node70 = *n
				pos = p
			}
			node += node70
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail69
			} else {
				node70 = *n
				pos = p
			}
			node += node70
		}
		goto ok0
	fail69:
		pos = pos2
		// e a q
		{
			var node72 string
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
		}
		goto ok0
	fail71:
		pos = pos2
		// e a
		{
			var node74 string
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail73
			} else {
				node74 = *n
				pos = p
			}
			node += node74
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail73
			} else {
				node74 = *n
				pos = p
			}
			node += node74
		}
		goto ok0
	fail73:
		pos = pos2
		// e q
		{
			var node76 string
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail75
			} else {
				node76 = *n
				pos = p
			}
			node += node76
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail75
			} else {
				node76 = *n
				pos = p
			}
			node += node76
		}
		goto ok0
	fail75:
		pos = pos2
		// e
		if p, n := _eAction(parser, pos); n == nil {
			goto fail77
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _desinence__ā__ū__ī__ō__ēAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _desinence__ā__ū__ī__ō__ē, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// ā o/ā i/ā q/ā/ū a o/ū a i/ū e q/ū e/ū o q/ū o/ū i/ū a q/ū a/ū q/ū/ī a o/ī a i/ī e q/ī e/ī o q/ī o/ī u/ī a q/ī a/ī q/ī/ō e q/ō e/ō i/ō a q/ō a/ō q/ō/ē o q/ē o/ē i/ē a q/ē a/ē q/ē
	{
		pos2 := pos
		// ā o
		// ā
		if !_accept(parser, _āAccepts, &pos, &perr) {
			goto fail3
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// ā i
		// ā
		if !_accept(parser, _āAccepts, &pos, &perr) {
			goto fail5
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// ā q
		// ā
		if !_accept(parser, _āAccepts, &pos, &perr) {
			goto fail7
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// ā
		if !_accept(parser, _āAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// ū a o
		// ū
		if !_accept(parser, _ūAccepts, &pos, &perr) {
			goto fail10
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail10
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		// ū a i
		// ū
		if !_accept(parser, _ūAccepts, &pos, &perr) {
			goto fail12
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail12
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail12
		}
		goto ok0
	fail12:
		pos = pos2
		// ū e q
		// ū
		if !_accept(parser, _ūAccepts, &pos, &perr) {
			goto fail14
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail14
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// ū e
		// ū
		if !_accept(parser, _ūAccepts, &pos, &perr) {
			goto fail16
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail16
		}
		goto ok0
	fail16:
		pos = pos2
		// ū o q
		// ū
		if !_accept(parser, _ūAccepts, &pos, &perr) {
			goto fail18
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail18
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail18
		}
		goto ok0
	fail18:
		pos = pos2
		// ū o
		// ū
		if !_accept(parser, _ūAccepts, &pos, &perr) {
			goto fail20
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail20
		}
		goto ok0
	fail20:
		pos = pos2
		// ū i
		// ū
		if !_accept(parser, _ūAccepts, &pos, &perr) {
			goto fail22
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail22
		}
		goto ok0
	fail22:
		pos = pos2
		// ū a q
		// ū
		if !_accept(parser, _ūAccepts, &pos, &perr) {
			goto fail24
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail24
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail24
		}
		goto ok0
	fail24:
		pos = pos2
		// ū a
		// ū
		if !_accept(parser, _ūAccepts, &pos, &perr) {
			goto fail26
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail26
		}
		goto ok0
	fail26:
		pos = pos2
		// ū q
		// ū
		if !_accept(parser, _ūAccepts, &pos, &perr) {
			goto fail28
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail28
		}
		goto ok0
	fail28:
		pos = pos2
		// ū
		if !_accept(parser, _ūAccepts, &pos, &perr) {
			goto fail30
		}
		goto ok0
	fail30:
		pos = pos2
		// ī a o
		// ī
		if !_accept(parser, _īAccepts, &pos, &perr) {
			goto fail31
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail31
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail31
		}
		goto ok0
	fail31:
		pos = pos2
		// ī a i
		// ī
		if !_accept(parser, _īAccepts, &pos, &perr) {
			goto fail33
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail33
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail33
		}
		goto ok0
	fail33:
		pos = pos2
		// ī e q
		// ī
		if !_accept(parser, _īAccepts, &pos, &perr) {
			goto fail35
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail35
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail35
		}
		goto ok0
	fail35:
		pos = pos2
		// ī e
		// ī
		if !_accept(parser, _īAccepts, &pos, &perr) {
			goto fail37
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail37
		}
		goto ok0
	fail37:
		pos = pos2
		// ī o q
		// ī
		if !_accept(parser, _īAccepts, &pos, &perr) {
			goto fail39
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail39
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail39
		}
		goto ok0
	fail39:
		pos = pos2
		// ī o
		// ī
		if !_accept(parser, _īAccepts, &pos, &perr) {
			goto fail41
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail41
		}
		goto ok0
	fail41:
		pos = pos2
		// ī u
		// ī
		if !_accept(parser, _īAccepts, &pos, &perr) {
			goto fail43
		}
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail43
		}
		goto ok0
	fail43:
		pos = pos2
		// ī a q
		// ī
		if !_accept(parser, _īAccepts, &pos, &perr) {
			goto fail45
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail45
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail45
		}
		goto ok0
	fail45:
		pos = pos2
		// ī a
		// ī
		if !_accept(parser, _īAccepts, &pos, &perr) {
			goto fail47
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail47
		}
		goto ok0
	fail47:
		pos = pos2
		// ī q
		// ī
		if !_accept(parser, _īAccepts, &pos, &perr) {
			goto fail49
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail49
		}
		goto ok0
	fail49:
		pos = pos2
		// ī
		if !_accept(parser, _īAccepts, &pos, &perr) {
			goto fail51
		}
		goto ok0
	fail51:
		pos = pos2
		// ō e q
		// ō
		if !_accept(parser, _ōAccepts, &pos, &perr) {
			goto fail52
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail52
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail52
		}
		goto ok0
	fail52:
		pos = pos2
		// ō e
		// ō
		if !_accept(parser, _ōAccepts, &pos, &perr) {
			goto fail54
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail54
		}
		goto ok0
	fail54:
		pos = pos2
		// ō i
		// ō
		if !_accept(parser, _ōAccepts, &pos, &perr) {
			goto fail56
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail56
		}
		goto ok0
	fail56:
		pos = pos2
		// ō a q
		// ō
		if !_accept(parser, _ōAccepts, &pos, &perr) {
			goto fail58
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail58
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail58
		}
		goto ok0
	fail58:
		pos = pos2
		// ō a
		// ō
		if !_accept(parser, _ōAccepts, &pos, &perr) {
			goto fail60
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail60
		}
		goto ok0
	fail60:
		pos = pos2
		// ō q
		// ō
		if !_accept(parser, _ōAccepts, &pos, &perr) {
			goto fail62
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail62
		}
		goto ok0
	fail62:
		pos = pos2
		// ō
		if !_accept(parser, _ōAccepts, &pos, &perr) {
			goto fail64
		}
		goto ok0
	fail64:
		pos = pos2
		// ē o q
		// ē
		if !_accept(parser, _ēAccepts, &pos, &perr) {
			goto fail65
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail65
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail65
		}
		goto ok0
	fail65:
		pos = pos2
		// ē o
		// ē
		if !_accept(parser, _ēAccepts, &pos, &perr) {
			goto fail67
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail67
		}
		goto ok0
	fail67:
		pos = pos2
		// ē i
		// ē
		if !_accept(parser, _ēAccepts, &pos, &perr) {
			goto fail69
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail69
		}
		goto ok0
	fail69:
		pos = pos2
		// ē a q
		// ē
		if !_accept(parser, _ēAccepts, &pos, &perr) {
			goto fail71
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail71
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail71
		}
		goto ok0
	fail71:
		pos = pos2
		// ē a
		// ē
		if !_accept(parser, _ēAccepts, &pos, &perr) {
			goto fail73
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail73
		}
		goto ok0
	fail73:
		pos = pos2
		// ē q
		// ē
		if !_accept(parser, _ēAccepts, &pos, &perr) {
			goto fail75
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail75
		}
		goto ok0
	fail75:
		pos = pos2
		// ē
		if !_accept(parser, _ēAccepts, &pos, &perr) {
			goto fail77
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _desinence__ā__ū__ī__ō__ē, start, pos, perr)
fail:
	return _memoize(parser, _desinence__ā__ū__ī__ō__ē, start, -1, perr)
}

func _desinence__ā__ū__ī__ō__ēNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_desinence__ā__ū__ī__ō__ē]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _desinence__ā__ū__ī__ō__ē}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "desinence<ā, ū, ī, ō, ē>"}
	// ā o/ā i/ā q/ā/ū a o/ū a i/ū e q/ū e/ū o q/ū o/ū i/ū a q/ū a/ū q/ū/ī a o/ī a i/ī e q/ī e/ī o q/ī o/ī u/ī a q/ī a/ī q/ī/ō e q/ō e/ō i/ō a q/ō a/ō q/ō/ē o q/ē o/ē i/ē a q/ē a/ē q/ē
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// ā o
		// ā
		if !_node(parser, _āNode, node, &pos) {
			goto fail3
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ā i
		// ā
		if !_node(parser, _āNode, node, &pos) {
			goto fail5
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ā q
		// ā
		if !_node(parser, _āNode, node, &pos) {
			goto fail7
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ā
		if !_node(parser, _āNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ū a o
		// ū
		if !_node(parser, _ūNode, node, &pos) {
			goto fail10
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail10
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ū a i
		// ū
		if !_node(parser, _ūNode, node, &pos) {
			goto fail12
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail12
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail12
		}
		goto ok0
	fail12:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ū e q
		// ū
		if !_node(parser, _ūNode, node, &pos) {
			goto fail14
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail14
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ū e
		// ū
		if !_node(parser, _ūNode, node, &pos) {
			goto fail16
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ū o q
		// ū
		if !_node(parser, _ūNode, node, &pos) {
			goto fail18
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail18
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail18
		}
		goto ok0
	fail18:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ū o
		// ū
		if !_node(parser, _ūNode, node, &pos) {
			goto fail20
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail20
		}
		goto ok0
	fail20:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ū i
		// ū
		if !_node(parser, _ūNode, node, &pos) {
			goto fail22
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail22
		}
		goto ok0
	fail22:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ū a q
		// ū
		if !_node(parser, _ūNode, node, &pos) {
			goto fail24
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail24
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail24
		}
		goto ok0
	fail24:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ū a
		// ū
		if !_node(parser, _ūNode, node, &pos) {
			goto fail26
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail26
		}
		goto ok0
	fail26:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ū q
		// ū
		if !_node(parser, _ūNode, node, &pos) {
			goto fail28
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail28
		}
		goto ok0
	fail28:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ū
		if !_node(parser, _ūNode, node, &pos) {
			goto fail30
		}
		goto ok0
	fail30:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ī a o
		// ī
		if !_node(parser, _īNode, node, &pos) {
			goto fail31
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail31
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail31
		}
		goto ok0
	fail31:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ī a i
		// ī
		if !_node(parser, _īNode, node, &pos) {
			goto fail33
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail33
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail33
		}
		goto ok0
	fail33:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ī e q
		// ī
		if !_node(parser, _īNode, node, &pos) {
			goto fail35
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail35
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail35
		}
		goto ok0
	fail35:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ī e
		// ī
		if !_node(parser, _īNode, node, &pos) {
			goto fail37
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail37
		}
		goto ok0
	fail37:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ī o q
		// ī
		if !_node(parser, _īNode, node, &pos) {
			goto fail39
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail39
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail39
		}
		goto ok0
	fail39:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ī o
		// ī
		if !_node(parser, _īNode, node, &pos) {
			goto fail41
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail41
		}
		goto ok0
	fail41:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ī u
		// ī
		if !_node(parser, _īNode, node, &pos) {
			goto fail43
		}
		// u
		if !_node(parser, _uNode, node, &pos) {
			goto fail43
		}
		goto ok0
	fail43:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ī a q
		// ī
		if !_node(parser, _īNode, node, &pos) {
			goto fail45
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail45
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail45
		}
		goto ok0
	fail45:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ī a
		// ī
		if !_node(parser, _īNode, node, &pos) {
			goto fail47
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail47
		}
		goto ok0
	fail47:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ī q
		// ī
		if !_node(parser, _īNode, node, &pos) {
			goto fail49
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail49
		}
		goto ok0
	fail49:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ī
		if !_node(parser, _īNode, node, &pos) {
			goto fail51
		}
		goto ok0
	fail51:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ō e q
		// ō
		if !_node(parser, _ōNode, node, &pos) {
			goto fail52
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail52
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail52
		}
		goto ok0
	fail52:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ō e
		// ō
		if !_node(parser, _ōNode, node, &pos) {
			goto fail54
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail54
		}
		goto ok0
	fail54:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ō i
		// ō
		if !_node(parser, _ōNode, node, &pos) {
			goto fail56
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail56
		}
		goto ok0
	fail56:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ō a q
		// ō
		if !_node(parser, _ōNode, node, &pos) {
			goto fail58
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail58
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail58
		}
		goto ok0
	fail58:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ō a
		// ō
		if !_node(parser, _ōNode, node, &pos) {
			goto fail60
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail60
		}
		goto ok0
	fail60:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ō q
		// ō
		if !_node(parser, _ōNode, node, &pos) {
			goto fail62
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail62
		}
		goto ok0
	fail62:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ō
		if !_node(parser, _ōNode, node, &pos) {
			goto fail64
		}
		goto ok0
	fail64:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ē o q
		// ē
		if !_node(parser, _ēNode, node, &pos) {
			goto fail65
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail65
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail65
		}
		goto ok0
	fail65:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ē o
		// ē
		if !_node(parser, _ēNode, node, &pos) {
			goto fail67
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail67
		}
		goto ok0
	fail67:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ē i
		// ē
		if !_node(parser, _ēNode, node, &pos) {
			goto fail69
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail69
		}
		goto ok0
	fail69:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ē a q
		// ē
		if !_node(parser, _ēNode, node, &pos) {
			goto fail71
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail71
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail71
		}
		goto ok0
	fail71:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ē a
		// ē
		if !_node(parser, _ēNode, node, &pos) {
			goto fail73
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail73
		}
		goto ok0
	fail73:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ē q
		// ē
		if !_node(parser, _ēNode, node, &pos) {
			goto fail75
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail75
		}
		goto ok0
	fail75:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ē
		if !_node(parser, _ēNode, node, &pos) {
			goto fail77
		}
		goto ok0
	fail77:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _desinence__ā__ū__ī__ō__ēFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _desinence__ā__ū__ī__ō__ē, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "desinence__ā__ū__ī__ō__ē",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _desinence__ā__ū__ī__ō__ē}
	// ā o/ā i/ā q/ā/ū a o/ū a i/ū e q/ū e/ū o q/ū o/ū i/ū a q/ū a/ū q/ū/ī a o/ī a i/ī e q/ī e/ī o q/ī o/ī u/ī a q/ī a/ī q/ī/ō e q/ō e/ō i/ō a q/ō a/ō q/ō/ē o q/ē o/ē i/ē a q/ē a/ē q/ē
	{
		pos2 := pos
		// ā o
		// ā
		if !_fail(parser, _āFail, errPos, failure, &pos) {
			goto fail3
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// ā i
		// ā
		if !_fail(parser, _āFail, errPos, failure, &pos) {
			goto fail5
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// ā q
		// ā
		if !_fail(parser, _āFail, errPos, failure, &pos) {
			goto fail7
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// ā
		if !_fail(parser, _āFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// ū a o
		// ū
		if !_fail(parser, _ūFail, errPos, failure, &pos) {
			goto fail10
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail10
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		// ū a i
		// ū
		if !_fail(parser, _ūFail, errPos, failure, &pos) {
			goto fail12
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail12
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail12
		}
		goto ok0
	fail12:
		pos = pos2
		// ū e q
		// ū
		if !_fail(parser, _ūFail, errPos, failure, &pos) {
			goto fail14
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail14
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// ū e
		// ū
		if !_fail(parser, _ūFail, errPos, failure, &pos) {
			goto fail16
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		pos = pos2
		// ū o q
		// ū
		if !_fail(parser, _ūFail, errPos, failure, &pos) {
			goto fail18
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail18
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail18
		}
		goto ok0
	fail18:
		pos = pos2
		// ū o
		// ū
		if !_fail(parser, _ūFail, errPos, failure, &pos) {
			goto fail20
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail20
		}
		goto ok0
	fail20:
		pos = pos2
		// ū i
		// ū
		if !_fail(parser, _ūFail, errPos, failure, &pos) {
			goto fail22
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail22
		}
		goto ok0
	fail22:
		pos = pos2
		// ū a q
		// ū
		if !_fail(parser, _ūFail, errPos, failure, &pos) {
			goto fail24
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail24
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail24
		}
		goto ok0
	fail24:
		pos = pos2
		// ū a
		// ū
		if !_fail(parser, _ūFail, errPos, failure, &pos) {
			goto fail26
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail26
		}
		goto ok0
	fail26:
		pos = pos2
		// ū q
		// ū
		if !_fail(parser, _ūFail, errPos, failure, &pos) {
			goto fail28
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail28
		}
		goto ok0
	fail28:
		pos = pos2
		// ū
		if !_fail(parser, _ūFail, errPos, failure, &pos) {
			goto fail30
		}
		goto ok0
	fail30:
		pos = pos2
		// ī a o
		// ī
		if !_fail(parser, _īFail, errPos, failure, &pos) {
			goto fail31
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail31
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail31
		}
		goto ok0
	fail31:
		pos = pos2
		// ī a i
		// ī
		if !_fail(parser, _īFail, errPos, failure, &pos) {
			goto fail33
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail33
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail33
		}
		goto ok0
	fail33:
		pos = pos2
		// ī e q
		// ī
		if !_fail(parser, _īFail, errPos, failure, &pos) {
			goto fail35
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail35
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail35
		}
		goto ok0
	fail35:
		pos = pos2
		// ī e
		// ī
		if !_fail(parser, _īFail, errPos, failure, &pos) {
			goto fail37
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail37
		}
		goto ok0
	fail37:
		pos = pos2
		// ī o q
		// ī
		if !_fail(parser, _īFail, errPos, failure, &pos) {
			goto fail39
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail39
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail39
		}
		goto ok0
	fail39:
		pos = pos2
		// ī o
		// ī
		if !_fail(parser, _īFail, errPos, failure, &pos) {
			goto fail41
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail41
		}
		goto ok0
	fail41:
		pos = pos2
		// ī u
		// ī
		if !_fail(parser, _īFail, errPos, failure, &pos) {
			goto fail43
		}
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail43
		}
		goto ok0
	fail43:
		pos = pos2
		// ī a q
		// ī
		if !_fail(parser, _īFail, errPos, failure, &pos) {
			goto fail45
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail45
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail45
		}
		goto ok0
	fail45:
		pos = pos2
		// ī a
		// ī
		if !_fail(parser, _īFail, errPos, failure, &pos) {
			goto fail47
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail47
		}
		goto ok0
	fail47:
		pos = pos2
		// ī q
		// ī
		if !_fail(parser, _īFail, errPos, failure, &pos) {
			goto fail49
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail49
		}
		goto ok0
	fail49:
		pos = pos2
		// ī
		if !_fail(parser, _īFail, errPos, failure, &pos) {
			goto fail51
		}
		goto ok0
	fail51:
		pos = pos2
		// ō e q
		// ō
		if !_fail(parser, _ōFail, errPos, failure, &pos) {
			goto fail52
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail52
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail52
		}
		goto ok0
	fail52:
		pos = pos2
		// ō e
		// ō
		if !_fail(parser, _ōFail, errPos, failure, &pos) {
			goto fail54
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail54
		}
		goto ok0
	fail54:
		pos = pos2
		// ō i
		// ō
		if !_fail(parser, _ōFail, errPos, failure, &pos) {
			goto fail56
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail56
		}
		goto ok0
	fail56:
		pos = pos2
		// ō a q
		// ō
		if !_fail(parser, _ōFail, errPos, failure, &pos) {
			goto fail58
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail58
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail58
		}
		goto ok0
	fail58:
		pos = pos2
		// ō a
		// ō
		if !_fail(parser, _ōFail, errPos, failure, &pos) {
			goto fail60
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail60
		}
		goto ok0
	fail60:
		pos = pos2
		// ō q
		// ō
		if !_fail(parser, _ōFail, errPos, failure, &pos) {
			goto fail62
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail62
		}
		goto ok0
	fail62:
		pos = pos2
		// ō
		if !_fail(parser, _ōFail, errPos, failure, &pos) {
			goto fail64
		}
		goto ok0
	fail64:
		pos = pos2
		// ē o q
		// ē
		if !_fail(parser, _ēFail, errPos, failure, &pos) {
			goto fail65
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail65
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail65
		}
		goto ok0
	fail65:
		pos = pos2
		// ē o
		// ē
		if !_fail(parser, _ēFail, errPos, failure, &pos) {
			goto fail67
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail67
		}
		goto ok0
	fail67:
		pos = pos2
		// ē i
		// ē
		if !_fail(parser, _ēFail, errPos, failure, &pos) {
			goto fail69
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail69
		}
		goto ok0
	fail69:
		pos = pos2
		// ē a q
		// ē
		if !_fail(parser, _ēFail, errPos, failure, &pos) {
			goto fail71
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail71
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail71
		}
		goto ok0
	fail71:
		pos = pos2
		// ē a
		// ē
		if !_fail(parser, _ēFail, errPos, failure, &pos) {
			goto fail73
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail73
		}
		goto ok0
	fail73:
		pos = pos2
		// ē q
		// ē
		if !_fail(parser, _ēFail, errPos, failure, &pos) {
			goto fail75
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail75
		}
		goto ok0
	fail75:
		pos = pos2
		// ē
		if !_fail(parser, _ēFail, errPos, failure, &pos) {
			goto fail77
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _desinence__ā__ū__ī__ō__ēAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_desinence__ā__ū__ī__ō__ē]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _desinence__ā__ū__ī__ō__ē}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// ā o/ā i/ā q/ā/ū a o/ū a i/ū e q/ū e/ū o q/ū o/ū i/ū a q/ū a/ū q/ū/ī a o/ī a i/ī e q/ī e/ī o q/ī o/ī u/ī a q/ī a/ī q/ī/ō e q/ō e/ō i/ō a q/ō a/ō q/ō/ē o q/ē o/ē i/ē a q/ē a/ē q/ē
	{
		pos2 := pos
		// ā o
		{
			var node4 string
			// ā
			if p, n := _āAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
		}
		goto ok0
	fail3:
		pos = pos2
		// ā i
		{
			var node6 string
			// ā
			if p, n := _āAction(parser, pos); n == nil {
				goto fail5
			} else {
				node6 = *n
				pos = p
			}
			node += node6
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail5
			} else {
				node6 = *n
				pos = p
			}
			node += node6
		}
		goto ok0
	fail5:
		pos = pos2
		// ā q
		{
			var node8 string
			// ā
			if p, n := _āAction(parser, pos); n == nil {
				goto fail7
			} else {
				node8 = *n
				pos = p
			}
			node += node8
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail7
			} else {
				node8 = *n
				pos = p
			}
			node += node8
		}
		goto ok0
	fail7:
		pos = pos2
		// ā
		if p, n := _āAction(parser, pos); n == nil {
			goto fail9
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail9:
		pos = pos2
		// ū a o
		{
			var node11 string
			// ū
			if p, n := _ūAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
		}
		goto ok0
	fail10:
		pos = pos2
		// ū a i
		{
			var node13 string
			// ū
			if p, n := _ūAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
		}
		goto ok0
	fail12:
		pos = pos2
		// ū e q
		{
			var node15 string
			// ū
			if p, n := _ūAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
		}
		goto ok0
	fail14:
		pos = pos2
		// ū e
		{
			var node17 string
			// ū
			if p, n := _ūAction(parser, pos); n == nil {
				goto fail16
			} else {
				node17 = *n
				pos = p
			}
			node += node17
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail16
			} else {
				node17 = *n
				pos = p
			}
			node += node17
		}
		goto ok0
	fail16:
		pos = pos2
		// ū o q
		{
			var node19 string
			// ū
			if p, n := _ūAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
		}
		goto ok0
	fail18:
		pos = pos2
		// ū o
		{
			var node21 string
			// ū
			if p, n := _ūAction(parser, pos); n == nil {
				goto fail20
			} else {
				node21 = *n
				pos = p
			}
			node += node21
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail20
			} else {
				node21 = *n
				pos = p
			}
			node += node21
		}
		goto ok0
	fail20:
		pos = pos2
		// ū i
		{
			var node23 string
			// ū
			if p, n := _ūAction(parser, pos); n == nil {
				goto fail22
			} else {
				node23 = *n
				pos = p
			}
			node += node23
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail22
			} else {
				node23 = *n
				pos = p
			}
			node += node23
		}
		goto ok0
	fail22:
		pos = pos2
		// ū a q
		{
			var node25 string
			// ū
			if p, n := _ūAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
		}
		goto ok0
	fail24:
		pos = pos2
		// ū a
		{
			var node27 string
			// ū
			if p, n := _ūAction(parser, pos); n == nil {
				goto fail26
			} else {
				node27 = *n
				pos = p
			}
			node += node27
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail26
			} else {
				node27 = *n
				pos = p
			}
			node += node27
		}
		goto ok0
	fail26:
		pos = pos2
		// ū q
		{
			var node29 string
			// ū
			if p, n := _ūAction(parser, pos); n == nil {
				goto fail28
			} else {
				node29 = *n
				pos = p
			}
			node += node29
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail28
			} else {
				node29 = *n
				pos = p
			}
			node += node29
		}
		goto ok0
	fail28:
		pos = pos2
		// ū
		if p, n := _ūAction(parser, pos); n == nil {
			goto fail30
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail30:
		pos = pos2
		// ī a o
		{
			var node32 string
			// ī
			if p, n := _īAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
		}
		goto ok0
	fail31:
		pos = pos2
		// ī a i
		{
			var node34 string
			// ī
			if p, n := _īAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
		}
		goto ok0
	fail33:
		pos = pos2
		// ī e q
		{
			var node36 string
			// ī
			if p, n := _īAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
		}
		goto ok0
	fail35:
		pos = pos2
		// ī e
		{
			var node38 string
			// ī
			if p, n := _īAction(parser, pos); n == nil {
				goto fail37
			} else {
				node38 = *n
				pos = p
			}
			node += node38
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail37
			} else {
				node38 = *n
				pos = p
			}
			node += node38
		}
		goto ok0
	fail37:
		pos = pos2
		// ī o q
		{
			var node40 string
			// ī
			if p, n := _īAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
		}
		goto ok0
	fail39:
		pos = pos2
		// ī o
		{
			var node42 string
			// ī
			if p, n := _īAction(parser, pos); n == nil {
				goto fail41
			} else {
				node42 = *n
				pos = p
			}
			node += node42
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail41
			} else {
				node42 = *n
				pos = p
			}
			node += node42
		}
		goto ok0
	fail41:
		pos = pos2
		// ī u
		{
			var node44 string
			// ī
			if p, n := _īAction(parser, pos); n == nil {
				goto fail43
			} else {
				node44 = *n
				pos = p
			}
			node += node44
			// u
			if p, n := _uAction(parser, pos); n == nil {
				goto fail43
			} else {
				node44 = *n
				pos = p
			}
			node += node44
		}
		goto ok0
	fail43:
		pos = pos2
		// ī a q
		{
			var node46 string
			// ī
			if p, n := _īAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
		}
		goto ok0
	fail45:
		pos = pos2
		// ī a
		{
			var node48 string
			// ī
			if p, n := _īAction(parser, pos); n == nil {
				goto fail47
			} else {
				node48 = *n
				pos = p
			}
			node += node48
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail47
			} else {
				node48 = *n
				pos = p
			}
			node += node48
		}
		goto ok0
	fail47:
		pos = pos2
		// ī q
		{
			var node50 string
			// ī
			if p, n := _īAction(parser, pos); n == nil {
				goto fail49
			} else {
				node50 = *n
				pos = p
			}
			node += node50
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail49
			} else {
				node50 = *n
				pos = p
			}
			node += node50
		}
		goto ok0
	fail49:
		pos = pos2
		// ī
		if p, n := _īAction(parser, pos); n == nil {
			goto fail51
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail51:
		pos = pos2
		// ō e q
		{
			var node53 string
			// ō
			if p, n := _ōAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
		}
		goto ok0
	fail52:
		pos = pos2
		// ō e
		{
			var node55 string
			// ō
			if p, n := _ōAction(parser, pos); n == nil {
				goto fail54
			} else {
				node55 = *n
				pos = p
			}
			node += node55
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail54
			} else {
				node55 = *n
				pos = p
			}
			node += node55
		}
		goto ok0
	fail54:
		pos = pos2
		// ō i
		{
			var node57 string
			// ō
			if p, n := _ōAction(parser, pos); n == nil {
				goto fail56
			} else {
				node57 = *n
				pos = p
			}
			node += node57
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail56
			} else {
				node57 = *n
				pos = p
			}
			node += node57
		}
		goto ok0
	fail56:
		pos = pos2
		// ō a q
		{
			var node59 string
			// ō
			if p, n := _ōAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
		}
		goto ok0
	fail58:
		pos = pos2
		// ō a
		{
			var node61 string
			// ō
			if p, n := _ōAction(parser, pos); n == nil {
				goto fail60
			} else {
				node61 = *n
				pos = p
			}
			node += node61
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail60
			} else {
				node61 = *n
				pos = p
			}
			node += node61
		}
		goto ok0
	fail60:
		pos = pos2
		// ō q
		{
			var node63 string
			// ō
			if p, n := _ōAction(parser, pos); n == nil {
				goto fail62
			} else {
				node63 = *n
				pos = p
			}
			node += node63
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail62
			} else {
				node63 = *n
				pos = p
			}
			node += node63
		}
		goto ok0
	fail62:
		pos = pos2
		// ō
		if p, n := _ōAction(parser, pos); n == nil {
			goto fail64
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail64:
		pos = pos2
		// ē o q
		{
			var node66 string
			// ē
			if p, n := _ēAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
		}
		goto ok0
	fail65:
		pos = pos2
		// ē o
		{
			var node68 string
			// ē
			if p, n := _ēAction(parser, pos); n == nil {
				goto fail67
			} else {
				node68 = *n
				pos = p
			}
			node += node68
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail67
			} else {
				node68 = *n
				pos = p
			}
			node += node68
		}
		goto ok0
	fail67:
		pos = pos2
		// ē i
		{
			var node70 string
			// ē
			if p, n := _ēAction(parser, pos); n == nil {
				goto fail69
			} else {
				node70 = *n
				pos = p
			}
			node += node70
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail69
			} else {
				node70 = *n
				pos = p
			}
			node += node70
		}
		goto ok0
	fail69:
		pos = pos2
		// ē a q
		{
			var node72 string
			// ē
			if p, n := _ēAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
		}
		goto ok0
	fail71:
		pos = pos2
		// ē a
		{
			var node74 string
			// ē
			if p, n := _ēAction(parser, pos); n == nil {
				goto fail73
			} else {
				node74 = *n
				pos = p
			}
			node += node74
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail73
			} else {
				node74 = *n
				pos = p
			}
			node += node74
		}
		goto ok0
	fail73:
		pos = pos2
		// ē q
		{
			var node76 string
			// ē
			if p, n := _ēAction(parser, pos); n == nil {
				goto fail75
			} else {
				node76 = *n
				pos = p
			}
			node += node76
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail75
			} else {
				node76 = *n
				pos = p
			}
			node += node76
		}
		goto ok0
	fail75:
		pos = pos2
		// ē
		if p, n := _ēAction(parser, pos); n == nil {
			goto fail77
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _desinence__á__ú__í__ó__éAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _desinence__á__ú__í__ó__é, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// á o/á i/á q/á/ú a o/ú a i/ú e q/ú e/ú o q/ú o/ú i/ú a q/ú a/ú q/ú/í a o/í a i/í e q/í e/í o q/í o/í u/í a q/í a/í q/í/ó e q/ó e/ó i/ó a q/ó a/ó q/ó/é o q/é o/é i/é a q/é a/é q/é
	{
		pos2 := pos
		// á o
		// á
		if !_accept(parser, _áAccepts, &pos, &perr) {
			goto fail3
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// á i
		// á
		if !_accept(parser, _áAccepts, &pos, &perr) {
			goto fail5
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// á q
		// á
		if !_accept(parser, _áAccepts, &pos, &perr) {
			goto fail7
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// á
		if !_accept(parser, _áAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// ú a o
		// ú
		if !_accept(parser, _úAccepts, &pos, &perr) {
			goto fail10
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail10
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		// ú a i
		// ú
		if !_accept(parser, _úAccepts, &pos, &perr) {
			goto fail12
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail12
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail12
		}
		goto ok0
	fail12:
		pos = pos2
		// ú e q
		// ú
		if !_accept(parser, _úAccepts, &pos, &perr) {
			goto fail14
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail14
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// ú e
		// ú
		if !_accept(parser, _úAccepts, &pos, &perr) {
			goto fail16
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail16
		}
		goto ok0
	fail16:
		pos = pos2
		// ú o q
		// ú
		if !_accept(parser, _úAccepts, &pos, &perr) {
			goto fail18
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail18
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail18
		}
		goto ok0
	fail18:
		pos = pos2
		// ú o
		// ú
		if !_accept(parser, _úAccepts, &pos, &perr) {
			goto fail20
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail20
		}
		goto ok0
	fail20:
		pos = pos2
		// ú i
		// ú
		if !_accept(parser, _úAccepts, &pos, &perr) {
			goto fail22
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail22
		}
		goto ok0
	fail22:
		pos = pos2
		// ú a q
		// ú
		if !_accept(parser, _úAccepts, &pos, &perr) {
			goto fail24
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail24
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail24
		}
		goto ok0
	fail24:
		pos = pos2
		// ú a
		// ú
		if !_accept(parser, _úAccepts, &pos, &perr) {
			goto fail26
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail26
		}
		goto ok0
	fail26:
		pos = pos2
		// ú q
		// ú
		if !_accept(parser, _úAccepts, &pos, &perr) {
			goto fail28
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail28
		}
		goto ok0
	fail28:
		pos = pos2
		// ú
		if !_accept(parser, _úAccepts, &pos, &perr) {
			goto fail30
		}
		goto ok0
	fail30:
		pos = pos2
		// í a o
		// í
		if !_accept(parser, _íAccepts, &pos, &perr) {
			goto fail31
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail31
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail31
		}
		goto ok0
	fail31:
		pos = pos2
		// í a i
		// í
		if !_accept(parser, _íAccepts, &pos, &perr) {
			goto fail33
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail33
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail33
		}
		goto ok0
	fail33:
		pos = pos2
		// í e q
		// í
		if !_accept(parser, _íAccepts, &pos, &perr) {
			goto fail35
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail35
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail35
		}
		goto ok0
	fail35:
		pos = pos2
		// í e
		// í
		if !_accept(parser, _íAccepts, &pos, &perr) {
			goto fail37
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail37
		}
		goto ok0
	fail37:
		pos = pos2
		// í o q
		// í
		if !_accept(parser, _íAccepts, &pos, &perr) {
			goto fail39
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail39
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail39
		}
		goto ok0
	fail39:
		pos = pos2
		// í o
		// í
		if !_accept(parser, _íAccepts, &pos, &perr) {
			goto fail41
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail41
		}
		goto ok0
	fail41:
		pos = pos2
		// í u
		// í
		if !_accept(parser, _íAccepts, &pos, &perr) {
			goto fail43
		}
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail43
		}
		goto ok0
	fail43:
		pos = pos2
		// í a q
		// í
		if !_accept(parser, _íAccepts, &pos, &perr) {
			goto fail45
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail45
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail45
		}
		goto ok0
	fail45:
		pos = pos2
		// í a
		// í
		if !_accept(parser, _íAccepts, &pos, &perr) {
			goto fail47
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail47
		}
		goto ok0
	fail47:
		pos = pos2
		// í q
		// í
		if !_accept(parser, _íAccepts, &pos, &perr) {
			goto fail49
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail49
		}
		goto ok0
	fail49:
		pos = pos2
		// í
		if !_accept(parser, _íAccepts, &pos, &perr) {
			goto fail51
		}
		goto ok0
	fail51:
		pos = pos2
		// ó e q
		// ó
		if !_accept(parser, _óAccepts, &pos, &perr) {
			goto fail52
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail52
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail52
		}
		goto ok0
	fail52:
		pos = pos2
		// ó e
		// ó
		if !_accept(parser, _óAccepts, &pos, &perr) {
			goto fail54
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail54
		}
		goto ok0
	fail54:
		pos = pos2
		// ó i
		// ó
		if !_accept(parser, _óAccepts, &pos, &perr) {
			goto fail56
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail56
		}
		goto ok0
	fail56:
		pos = pos2
		// ó a q
		// ó
		if !_accept(parser, _óAccepts, &pos, &perr) {
			goto fail58
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail58
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail58
		}
		goto ok0
	fail58:
		pos = pos2
		// ó a
		// ó
		if !_accept(parser, _óAccepts, &pos, &perr) {
			goto fail60
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail60
		}
		goto ok0
	fail60:
		pos = pos2
		// ó q
		// ó
		if !_accept(parser, _óAccepts, &pos, &perr) {
			goto fail62
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail62
		}
		goto ok0
	fail62:
		pos = pos2
		// ó
		if !_accept(parser, _óAccepts, &pos, &perr) {
			goto fail64
		}
		goto ok0
	fail64:
		pos = pos2
		// é o q
		// é
		if !_accept(parser, _éAccepts, &pos, &perr) {
			goto fail65
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail65
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail65
		}
		goto ok0
	fail65:
		pos = pos2
		// é o
		// é
		if !_accept(parser, _éAccepts, &pos, &perr) {
			goto fail67
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail67
		}
		goto ok0
	fail67:
		pos = pos2
		// é i
		// é
		if !_accept(parser, _éAccepts, &pos, &perr) {
			goto fail69
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail69
		}
		goto ok0
	fail69:
		pos = pos2
		// é a q
		// é
		if !_accept(parser, _éAccepts, &pos, &perr) {
			goto fail71
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail71
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail71
		}
		goto ok0
	fail71:
		pos = pos2
		// é a
		// é
		if !_accept(parser, _éAccepts, &pos, &perr) {
			goto fail73
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail73
		}
		goto ok0
	fail73:
		pos = pos2
		// é q
		// é
		if !_accept(parser, _éAccepts, &pos, &perr) {
			goto fail75
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail75
		}
		goto ok0
	fail75:
		pos = pos2
		// é
		if !_accept(parser, _éAccepts, &pos, &perr) {
			goto fail77
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _desinence__á__ú__í__ó__é, start, pos, perr)
fail:
	return _memoize(parser, _desinence__á__ú__í__ó__é, start, -1, perr)
}

func _desinence__á__ú__í__ó__éNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_desinence__á__ú__í__ó__é]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _desinence__á__ú__í__ó__é}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "desinence<á, ú, í, ó, é>"}
	// á o/á i/á q/á/ú a o/ú a i/ú e q/ú e/ú o q/ú o/ú i/ú a q/ú a/ú q/ú/í a o/í a i/í e q/í e/í o q/í o/í u/í a q/í a/í q/í/ó e q/ó e/ó i/ó a q/ó a/ó q/ó/é o q/é o/é i/é a q/é a/é q/é
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// á o
		// á
		if !_node(parser, _áNode, node, &pos) {
			goto fail3
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// á i
		// á
		if !_node(parser, _áNode, node, &pos) {
			goto fail5
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// á q
		// á
		if !_node(parser, _áNode, node, &pos) {
			goto fail7
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// á
		if !_node(parser, _áNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ú a o
		// ú
		if !_node(parser, _úNode, node, &pos) {
			goto fail10
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail10
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ú a i
		// ú
		if !_node(parser, _úNode, node, &pos) {
			goto fail12
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail12
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail12
		}
		goto ok0
	fail12:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ú e q
		// ú
		if !_node(parser, _úNode, node, &pos) {
			goto fail14
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail14
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ú e
		// ú
		if !_node(parser, _úNode, node, &pos) {
			goto fail16
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ú o q
		// ú
		if !_node(parser, _úNode, node, &pos) {
			goto fail18
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail18
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail18
		}
		goto ok0
	fail18:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ú o
		// ú
		if !_node(parser, _úNode, node, &pos) {
			goto fail20
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail20
		}
		goto ok0
	fail20:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ú i
		// ú
		if !_node(parser, _úNode, node, &pos) {
			goto fail22
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail22
		}
		goto ok0
	fail22:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ú a q
		// ú
		if !_node(parser, _úNode, node, &pos) {
			goto fail24
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail24
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail24
		}
		goto ok0
	fail24:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ú a
		// ú
		if !_node(parser, _úNode, node, &pos) {
			goto fail26
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail26
		}
		goto ok0
	fail26:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ú q
		// ú
		if !_node(parser, _úNode, node, &pos) {
			goto fail28
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail28
		}
		goto ok0
	fail28:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ú
		if !_node(parser, _úNode, node, &pos) {
			goto fail30
		}
		goto ok0
	fail30:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// í a o
		// í
		if !_node(parser, _íNode, node, &pos) {
			goto fail31
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail31
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail31
		}
		goto ok0
	fail31:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// í a i
		// í
		if !_node(parser, _íNode, node, &pos) {
			goto fail33
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail33
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail33
		}
		goto ok0
	fail33:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// í e q
		// í
		if !_node(parser, _íNode, node, &pos) {
			goto fail35
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail35
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail35
		}
		goto ok0
	fail35:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// í e
		// í
		if !_node(parser, _íNode, node, &pos) {
			goto fail37
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail37
		}
		goto ok0
	fail37:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// í o q
		// í
		if !_node(parser, _íNode, node, &pos) {
			goto fail39
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail39
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail39
		}
		goto ok0
	fail39:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// í o
		// í
		if !_node(parser, _íNode, node, &pos) {
			goto fail41
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail41
		}
		goto ok0
	fail41:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// í u
		// í
		if !_node(parser, _íNode, node, &pos) {
			goto fail43
		}
		// u
		if !_node(parser, _uNode, node, &pos) {
			goto fail43
		}
		goto ok0
	fail43:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// í a q
		// í
		if !_node(parser, _íNode, node, &pos) {
			goto fail45
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail45
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail45
		}
		goto ok0
	fail45:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// í a
		// í
		if !_node(parser, _íNode, node, &pos) {
			goto fail47
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail47
		}
		goto ok0
	fail47:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// í q
		// í
		if !_node(parser, _íNode, node, &pos) {
			goto fail49
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail49
		}
		goto ok0
	fail49:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// í
		if !_node(parser, _íNode, node, &pos) {
			goto fail51
		}
		goto ok0
	fail51:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ó e q
		// ó
		if !_node(parser, _óNode, node, &pos) {
			goto fail52
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail52
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail52
		}
		goto ok0
	fail52:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ó e
		// ó
		if !_node(parser, _óNode, node, &pos) {
			goto fail54
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail54
		}
		goto ok0
	fail54:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ó i
		// ó
		if !_node(parser, _óNode, node, &pos) {
			goto fail56
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail56
		}
		goto ok0
	fail56:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ó a q
		// ó
		if !_node(parser, _óNode, node, &pos) {
			goto fail58
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail58
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail58
		}
		goto ok0
	fail58:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ó a
		// ó
		if !_node(parser, _óNode, node, &pos) {
			goto fail60
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail60
		}
		goto ok0
	fail60:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ó q
		// ó
		if !_node(parser, _óNode, node, &pos) {
			goto fail62
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail62
		}
		goto ok0
	fail62:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ó
		if !_node(parser, _óNode, node, &pos) {
			goto fail64
		}
		goto ok0
	fail64:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// é o q
		// é
		if !_node(parser, _éNode, node, &pos) {
			goto fail65
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail65
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail65
		}
		goto ok0
	fail65:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// é o
		// é
		if !_node(parser, _éNode, node, &pos) {
			goto fail67
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail67
		}
		goto ok0
	fail67:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// é i
		// é
		if !_node(parser, _éNode, node, &pos) {
			goto fail69
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail69
		}
		goto ok0
	fail69:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// é a q
		// é
		if !_node(parser, _éNode, node, &pos) {
			goto fail71
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail71
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail71
		}
		goto ok0
	fail71:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// é a
		// é
		if !_node(parser, _éNode, node, &pos) {
			goto fail73
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail73
		}
		goto ok0
	fail73:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// é q
		// é
		if !_node(parser, _éNode, node, &pos) {
			goto fail75
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail75
		}
		goto ok0
	fail75:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// é
		if !_node(parser, _éNode, node, &pos) {
			goto fail77
		}
		goto ok0
	fail77:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _desinence__á__ú__í__ó__éFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _desinence__á__ú__í__ó__é, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "desinence__á__ú__í__ó__é",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _desinence__á__ú__í__ó__é}
	// á o/á i/á q/á/ú a o/ú a i/ú e q/ú e/ú o q/ú o/ú i/ú a q/ú a/ú q/ú/í a o/í a i/í e q/í e/í o q/í o/í u/í a q/í a/í q/í/ó e q/ó e/ó i/ó a q/ó a/ó q/ó/é o q/é o/é i/é a q/é a/é q/é
	{
		pos2 := pos
		// á o
		// á
		if !_fail(parser, _áFail, errPos, failure, &pos) {
			goto fail3
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// á i
		// á
		if !_fail(parser, _áFail, errPos, failure, &pos) {
			goto fail5
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// á q
		// á
		if !_fail(parser, _áFail, errPos, failure, &pos) {
			goto fail7
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// á
		if !_fail(parser, _áFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// ú a o
		// ú
		if !_fail(parser, _úFail, errPos, failure, &pos) {
			goto fail10
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail10
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		// ú a i
		// ú
		if !_fail(parser, _úFail, errPos, failure, &pos) {
			goto fail12
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail12
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail12
		}
		goto ok0
	fail12:
		pos = pos2
		// ú e q
		// ú
		if !_fail(parser, _úFail, errPos, failure, &pos) {
			goto fail14
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail14
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// ú e
		// ú
		if !_fail(parser, _úFail, errPos, failure, &pos) {
			goto fail16
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		pos = pos2
		// ú o q
		// ú
		if !_fail(parser, _úFail, errPos, failure, &pos) {
			goto fail18
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail18
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail18
		}
		goto ok0
	fail18:
		pos = pos2
		// ú o
		// ú
		if !_fail(parser, _úFail, errPos, failure, &pos) {
			goto fail20
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail20
		}
		goto ok0
	fail20:
		pos = pos2
		// ú i
		// ú
		if !_fail(parser, _úFail, errPos, failure, &pos) {
			goto fail22
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail22
		}
		goto ok0
	fail22:
		pos = pos2
		// ú a q
		// ú
		if !_fail(parser, _úFail, errPos, failure, &pos) {
			goto fail24
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail24
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail24
		}
		goto ok0
	fail24:
		pos = pos2
		// ú a
		// ú
		if !_fail(parser, _úFail, errPos, failure, &pos) {
			goto fail26
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail26
		}
		goto ok0
	fail26:
		pos = pos2
		// ú q
		// ú
		if !_fail(parser, _úFail, errPos, failure, &pos) {
			goto fail28
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail28
		}
		goto ok0
	fail28:
		pos = pos2
		// ú
		if !_fail(parser, _úFail, errPos, failure, &pos) {
			goto fail30
		}
		goto ok0
	fail30:
		pos = pos2
		// í a o
		// í
		if !_fail(parser, _íFail, errPos, failure, &pos) {
			goto fail31
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail31
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail31
		}
		goto ok0
	fail31:
		pos = pos2
		// í a i
		// í
		if !_fail(parser, _íFail, errPos, failure, &pos) {
			goto fail33
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail33
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail33
		}
		goto ok0
	fail33:
		pos = pos2
		// í e q
		// í
		if !_fail(parser, _íFail, errPos, failure, &pos) {
			goto fail35
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail35
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail35
		}
		goto ok0
	fail35:
		pos = pos2
		// í e
		// í
		if !_fail(parser, _íFail, errPos, failure, &pos) {
			goto fail37
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail37
		}
		goto ok0
	fail37:
		pos = pos2
		// í o q
		// í
		if !_fail(parser, _íFail, errPos, failure, &pos) {
			goto fail39
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail39
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail39
		}
		goto ok0
	fail39:
		pos = pos2
		// í o
		// í
		if !_fail(parser, _íFail, errPos, failure, &pos) {
			goto fail41
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail41
		}
		goto ok0
	fail41:
		pos = pos2
		// í u
		// í
		if !_fail(parser, _íFail, errPos, failure, &pos) {
			goto fail43
		}
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail43
		}
		goto ok0
	fail43:
		pos = pos2
		// í a q
		// í
		if !_fail(parser, _íFail, errPos, failure, &pos) {
			goto fail45
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail45
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail45
		}
		goto ok0
	fail45:
		pos = pos2
		// í a
		// í
		if !_fail(parser, _íFail, errPos, failure, &pos) {
			goto fail47
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail47
		}
		goto ok0
	fail47:
		pos = pos2
		// í q
		// í
		if !_fail(parser, _íFail, errPos, failure, &pos) {
			goto fail49
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail49
		}
		goto ok0
	fail49:
		pos = pos2
		// í
		if !_fail(parser, _íFail, errPos, failure, &pos) {
			goto fail51
		}
		goto ok0
	fail51:
		pos = pos2
		// ó e q
		// ó
		if !_fail(parser, _óFail, errPos, failure, &pos) {
			goto fail52
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail52
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail52
		}
		goto ok0
	fail52:
		pos = pos2
		// ó e
		// ó
		if !_fail(parser, _óFail, errPos, failure, &pos) {
			goto fail54
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail54
		}
		goto ok0
	fail54:
		pos = pos2
		// ó i
		// ó
		if !_fail(parser, _óFail, errPos, failure, &pos) {
			goto fail56
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail56
		}
		goto ok0
	fail56:
		pos = pos2
		// ó a q
		// ó
		if !_fail(parser, _óFail, errPos, failure, &pos) {
			goto fail58
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail58
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail58
		}
		goto ok0
	fail58:
		pos = pos2
		// ó a
		// ó
		if !_fail(parser, _óFail, errPos, failure, &pos) {
			goto fail60
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail60
		}
		goto ok0
	fail60:
		pos = pos2
		// ó q
		// ó
		if !_fail(parser, _óFail, errPos, failure, &pos) {
			goto fail62
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail62
		}
		goto ok0
	fail62:
		pos = pos2
		// ó
		if !_fail(parser, _óFail, errPos, failure, &pos) {
			goto fail64
		}
		goto ok0
	fail64:
		pos = pos2
		// é o q
		// é
		if !_fail(parser, _éFail, errPos, failure, &pos) {
			goto fail65
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail65
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail65
		}
		goto ok0
	fail65:
		pos = pos2
		// é o
		// é
		if !_fail(parser, _éFail, errPos, failure, &pos) {
			goto fail67
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail67
		}
		goto ok0
	fail67:
		pos = pos2
		// é i
		// é
		if !_fail(parser, _éFail, errPos, failure, &pos) {
			goto fail69
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail69
		}
		goto ok0
	fail69:
		pos = pos2
		// é a q
		// é
		if !_fail(parser, _éFail, errPos, failure, &pos) {
			goto fail71
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail71
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail71
		}
		goto ok0
	fail71:
		pos = pos2
		// é a
		// é
		if !_fail(parser, _éFail, errPos, failure, &pos) {
			goto fail73
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail73
		}
		goto ok0
	fail73:
		pos = pos2
		// é q
		// é
		if !_fail(parser, _éFail, errPos, failure, &pos) {
			goto fail75
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail75
		}
		goto ok0
	fail75:
		pos = pos2
		// é
		if !_fail(parser, _éFail, errPos, failure, &pos) {
			goto fail77
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _desinence__á__ú__í__ó__éAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_desinence__á__ú__í__ó__é]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _desinence__á__ú__í__ó__é}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// á o/á i/á q/á/ú a o/ú a i/ú e q/ú e/ú o q/ú o/ú i/ú a q/ú a/ú q/ú/í a o/í a i/í e q/í e/í o q/í o/í u/í a q/í a/í q/í/ó e q/ó e/ó i/ó a q/ó a/ó q/ó/é o q/é o/é i/é a q/é a/é q/é
	{
		pos2 := pos
		// á o
		{
			var node4 string
			// á
			if p, n := _áAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
		}
		goto ok0
	fail3:
		pos = pos2
		// á i
		{
			var node6 string
			// á
			if p, n := _áAction(parser, pos); n == nil {
				goto fail5
			} else {
				node6 = *n
				pos = p
			}
			node += node6
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail5
			} else {
				node6 = *n
				pos = p
			}
			node += node6
		}
		goto ok0
	fail5:
		pos = pos2
		// á q
		{
			var node8 string
			// á
			if p, n := _áAction(parser, pos); n == nil {
				goto fail7
			} else {
				node8 = *n
				pos = p
			}
			node += node8
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail7
			} else {
				node8 = *n
				pos = p
			}
			node += node8
		}
		goto ok0
	fail7:
		pos = pos2
		// á
		if p, n := _áAction(parser, pos); n == nil {
			goto fail9
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail9:
		pos = pos2
		// ú a o
		{
			var node11 string
			// ú
			if p, n := _úAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
		}
		goto ok0
	fail10:
		pos = pos2
		// ú a i
		{
			var node13 string
			// ú
			if p, n := _úAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
		}
		goto ok0
	fail12:
		pos = pos2
		// ú e q
		{
			var node15 string
			// ú
			if p, n := _úAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
		}
		goto ok0
	fail14:
		pos = pos2
		// ú e
		{
			var node17 string
			// ú
			if p, n := _úAction(parser, pos); n == nil {
				goto fail16
			} else {
				node17 = *n
				pos = p
			}
			node += node17
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail16
			} else {
				node17 = *n
				pos = p
			}
			node += node17
		}
		goto ok0
	fail16:
		pos = pos2
		// ú o q
		{
			var node19 string
			// ú
			if p, n := _úAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
		}
		goto ok0
	fail18:
		pos = pos2
		// ú o
		{
			var node21 string
			// ú
			if p, n := _úAction(parser, pos); n == nil {
				goto fail20
			} else {
				node21 = *n
				pos = p
			}
			node += node21
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail20
			} else {
				node21 = *n
				pos = p
			}
			node += node21
		}
		goto ok0
	fail20:
		pos = pos2
		// ú i
		{
			var node23 string
			// ú
			if p, n := _úAction(parser, pos); n == nil {
				goto fail22
			} else {
				node23 = *n
				pos = p
			}
			node += node23
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail22
			} else {
				node23 = *n
				pos = p
			}
			node += node23
		}
		goto ok0
	fail22:
		pos = pos2
		// ú a q
		{
			var node25 string
			// ú
			if p, n := _úAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
		}
		goto ok0
	fail24:
		pos = pos2
		// ú a
		{
			var node27 string
			// ú
			if p, n := _úAction(parser, pos); n == nil {
				goto fail26
			} else {
				node27 = *n
				pos = p
			}
			node += node27
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail26
			} else {
				node27 = *n
				pos = p
			}
			node += node27
		}
		goto ok0
	fail26:
		pos = pos2
		// ú q
		{
			var node29 string
			// ú
			if p, n := _úAction(parser, pos); n == nil {
				goto fail28
			} else {
				node29 = *n
				pos = p
			}
			node += node29
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail28
			} else {
				node29 = *n
				pos = p
			}
			node += node29
		}
		goto ok0
	fail28:
		pos = pos2
		// ú
		if p, n := _úAction(parser, pos); n == nil {
			goto fail30
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail30:
		pos = pos2
		// í a o
		{
			var node32 string
			// í
			if p, n := _íAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
		}
		goto ok0
	fail31:
		pos = pos2
		// í a i
		{
			var node34 string
			// í
			if p, n := _íAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
		}
		goto ok0
	fail33:
		pos = pos2
		// í e q
		{
			var node36 string
			// í
			if p, n := _íAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
		}
		goto ok0
	fail35:
		pos = pos2
		// í e
		{
			var node38 string
			// í
			if p, n := _íAction(parser, pos); n == nil {
				goto fail37
			} else {
				node38 = *n
				pos = p
			}
			node += node38
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail37
			} else {
				node38 = *n
				pos = p
			}
			node += node38
		}
		goto ok0
	fail37:
		pos = pos2
		// í o q
		{
			var node40 string
			// í
			if p, n := _íAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
		}
		goto ok0
	fail39:
		pos = pos2
		// í o
		{
			var node42 string
			// í
			if p, n := _íAction(parser, pos); n == nil {
				goto fail41
			} else {
				node42 = *n
				pos = p
			}
			node += node42
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail41
			} else {
				node42 = *n
				pos = p
			}
			node += node42
		}
		goto ok0
	fail41:
		pos = pos2
		// í u
		{
			var node44 string
			// í
			if p, n := _íAction(parser, pos); n == nil {
				goto fail43
			} else {
				node44 = *n
				pos = p
			}
			node += node44
			// u
			if p, n := _uAction(parser, pos); n == nil {
				goto fail43
			} else {
				node44 = *n
				pos = p
			}
			node += node44
		}
		goto ok0
	fail43:
		pos = pos2
		// í a q
		{
			var node46 string
			// í
			if p, n := _íAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
		}
		goto ok0
	fail45:
		pos = pos2
		// í a
		{
			var node48 string
			// í
			if p, n := _íAction(parser, pos); n == nil {
				goto fail47
			} else {
				node48 = *n
				pos = p
			}
			node += node48
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail47
			} else {
				node48 = *n
				pos = p
			}
			node += node48
		}
		goto ok0
	fail47:
		pos = pos2
		// í q
		{
			var node50 string
			// í
			if p, n := _íAction(parser, pos); n == nil {
				goto fail49
			} else {
				node50 = *n
				pos = p
			}
			node += node50
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail49
			} else {
				node50 = *n
				pos = p
			}
			node += node50
		}
		goto ok0
	fail49:
		pos = pos2
		// í
		if p, n := _íAction(parser, pos); n == nil {
			goto fail51
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail51:
		pos = pos2
		// ó e q
		{
			var node53 string
			// ó
			if p, n := _óAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
		}
		goto ok0
	fail52:
		pos = pos2
		// ó e
		{
			var node55 string
			// ó
			if p, n := _óAction(parser, pos); n == nil {
				goto fail54
			} else {
				node55 = *n
				pos = p
			}
			node += node55
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail54
			} else {
				node55 = *n
				pos = p
			}
			node += node55
		}
		goto ok0
	fail54:
		pos = pos2
		// ó i
		{
			var node57 string
			// ó
			if p, n := _óAction(parser, pos); n == nil {
				goto fail56
			} else {
				node57 = *n
				pos = p
			}
			node += node57
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail56
			} else {
				node57 = *n
				pos = p
			}
			node += node57
		}
		goto ok0
	fail56:
		pos = pos2
		// ó a q
		{
			var node59 string
			// ó
			if p, n := _óAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
		}
		goto ok0
	fail58:
		pos = pos2
		// ó a
		{
			var node61 string
			// ó
			if p, n := _óAction(parser, pos); n == nil {
				goto fail60
			} else {
				node61 = *n
				pos = p
			}
			node += node61
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail60
			} else {
				node61 = *n
				pos = p
			}
			node += node61
		}
		goto ok0
	fail60:
		pos = pos2
		// ó q
		{
			var node63 string
			// ó
			if p, n := _óAction(parser, pos); n == nil {
				goto fail62
			} else {
				node63 = *n
				pos = p
			}
			node += node63
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail62
			} else {
				node63 = *n
				pos = p
			}
			node += node63
		}
		goto ok0
	fail62:
		pos = pos2
		// ó
		if p, n := _óAction(parser, pos); n == nil {
			goto fail64
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail64:
		pos = pos2
		// é o q
		{
			var node66 string
			// é
			if p, n := _éAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
		}
		goto ok0
	fail65:
		pos = pos2
		// é o
		{
			var node68 string
			// é
			if p, n := _éAction(parser, pos); n == nil {
				goto fail67
			} else {
				node68 = *n
				pos = p
			}
			node += node68
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail67
			} else {
				node68 = *n
				pos = p
			}
			node += node68
		}
		goto ok0
	fail67:
		pos = pos2
		// é i
		{
			var node70 string
			// é
			if p, n := _éAction(parser, pos); n == nil {
				goto fail69
			} else {
				node70 = *n
				pos = p
			}
			node += node70
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail69
			} else {
				node70 = *n
				pos = p
			}
			node += node70
		}
		goto ok0
	fail69:
		pos = pos2
		// é a q
		{
			var node72 string
			// é
			if p, n := _éAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
		}
		goto ok0
	fail71:
		pos = pos2
		// é a
		{
			var node74 string
			// é
			if p, n := _éAction(parser, pos); n == nil {
				goto fail73
			} else {
				node74 = *n
				pos = p
			}
			node += node74
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail73
			} else {
				node74 = *n
				pos = p
			}
			node += node74
		}
		goto ok0
	fail73:
		pos = pos2
		// é q
		{
			var node76 string
			// é
			if p, n := _éAction(parser, pos); n == nil {
				goto fail75
			} else {
				node76 = *n
				pos = p
			}
			node += node76
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail75
			} else {
				node76 = *n
				pos = p
			}
			node += node76
		}
		goto ok0
	fail75:
		pos = pos2
		// é
		if p, n := _éAction(parser, pos); n == nil {
			goto fail77
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _desinence__ǎ__ǔ__ǐ__ǒ__ěAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _desinence__ǎ__ǔ__ǐ__ǒ__ě, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// ǎ o/ǎ i/ǎ q/ǎ/ǔ a o/ǔ a i/ǔ e q/ǔ e/ǔ o q/ǔ o/ǔ i/ǔ a q/ǔ a/ǔ q/ǔ/ǐ a o/ǐ a i/ǐ e q/ǐ e/ǐ o q/ǐ o/ǐ u/ǐ a q/ǐ a/ǐ q/ǐ/ǒ e q/ǒ e/ǒ i/ǒ a q/ǒ a/ǒ q/ǒ/ě o q/ě o/ě i/ě a q/ě a/ě q/ě
	{
		pos2 := pos
		// ǎ o
		// ǎ
		if !_accept(parser, _ǎAccepts, &pos, &perr) {
			goto fail3
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// ǎ i
		// ǎ
		if !_accept(parser, _ǎAccepts, &pos, &perr) {
			goto fail5
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// ǎ q
		// ǎ
		if !_accept(parser, _ǎAccepts, &pos, &perr) {
			goto fail7
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// ǎ
		if !_accept(parser, _ǎAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// ǔ a o
		// ǔ
		if !_accept(parser, _ǔAccepts, &pos, &perr) {
			goto fail10
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail10
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		// ǔ a i
		// ǔ
		if !_accept(parser, _ǔAccepts, &pos, &perr) {
			goto fail12
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail12
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail12
		}
		goto ok0
	fail12:
		pos = pos2
		// ǔ e q
		// ǔ
		if !_accept(parser, _ǔAccepts, &pos, &perr) {
			goto fail14
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail14
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// ǔ e
		// ǔ
		if !_accept(parser, _ǔAccepts, &pos, &perr) {
			goto fail16
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail16
		}
		goto ok0
	fail16:
		pos = pos2
		// ǔ o q
		// ǔ
		if !_accept(parser, _ǔAccepts, &pos, &perr) {
			goto fail18
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail18
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail18
		}
		goto ok0
	fail18:
		pos = pos2
		// ǔ o
		// ǔ
		if !_accept(parser, _ǔAccepts, &pos, &perr) {
			goto fail20
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail20
		}
		goto ok0
	fail20:
		pos = pos2
		// ǔ i
		// ǔ
		if !_accept(parser, _ǔAccepts, &pos, &perr) {
			goto fail22
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail22
		}
		goto ok0
	fail22:
		pos = pos2
		// ǔ a q
		// ǔ
		if !_accept(parser, _ǔAccepts, &pos, &perr) {
			goto fail24
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail24
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail24
		}
		goto ok0
	fail24:
		pos = pos2
		// ǔ a
		// ǔ
		if !_accept(parser, _ǔAccepts, &pos, &perr) {
			goto fail26
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail26
		}
		goto ok0
	fail26:
		pos = pos2
		// ǔ q
		// ǔ
		if !_accept(parser, _ǔAccepts, &pos, &perr) {
			goto fail28
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail28
		}
		goto ok0
	fail28:
		pos = pos2
		// ǔ
		if !_accept(parser, _ǔAccepts, &pos, &perr) {
			goto fail30
		}
		goto ok0
	fail30:
		pos = pos2
		// ǐ a o
		// ǐ
		if !_accept(parser, _ǐAccepts, &pos, &perr) {
			goto fail31
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail31
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail31
		}
		goto ok0
	fail31:
		pos = pos2
		// ǐ a i
		// ǐ
		if !_accept(parser, _ǐAccepts, &pos, &perr) {
			goto fail33
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail33
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail33
		}
		goto ok0
	fail33:
		pos = pos2
		// ǐ e q
		// ǐ
		if !_accept(parser, _ǐAccepts, &pos, &perr) {
			goto fail35
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail35
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail35
		}
		goto ok0
	fail35:
		pos = pos2
		// ǐ e
		// ǐ
		if !_accept(parser, _ǐAccepts, &pos, &perr) {
			goto fail37
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail37
		}
		goto ok0
	fail37:
		pos = pos2
		// ǐ o q
		// ǐ
		if !_accept(parser, _ǐAccepts, &pos, &perr) {
			goto fail39
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail39
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail39
		}
		goto ok0
	fail39:
		pos = pos2
		// ǐ o
		// ǐ
		if !_accept(parser, _ǐAccepts, &pos, &perr) {
			goto fail41
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail41
		}
		goto ok0
	fail41:
		pos = pos2
		// ǐ u
		// ǐ
		if !_accept(parser, _ǐAccepts, &pos, &perr) {
			goto fail43
		}
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail43
		}
		goto ok0
	fail43:
		pos = pos2
		// ǐ a q
		// ǐ
		if !_accept(parser, _ǐAccepts, &pos, &perr) {
			goto fail45
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail45
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail45
		}
		goto ok0
	fail45:
		pos = pos2
		// ǐ a
		// ǐ
		if !_accept(parser, _ǐAccepts, &pos, &perr) {
			goto fail47
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail47
		}
		goto ok0
	fail47:
		pos = pos2
		// ǐ q
		// ǐ
		if !_accept(parser, _ǐAccepts, &pos, &perr) {
			goto fail49
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail49
		}
		goto ok0
	fail49:
		pos = pos2
		// ǐ
		if !_accept(parser, _ǐAccepts, &pos, &perr) {
			goto fail51
		}
		goto ok0
	fail51:
		pos = pos2
		// ǒ e q
		// ǒ
		if !_accept(parser, _ǒAccepts, &pos, &perr) {
			goto fail52
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail52
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail52
		}
		goto ok0
	fail52:
		pos = pos2
		// ǒ e
		// ǒ
		if !_accept(parser, _ǒAccepts, &pos, &perr) {
			goto fail54
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail54
		}
		goto ok0
	fail54:
		pos = pos2
		// ǒ i
		// ǒ
		if !_accept(parser, _ǒAccepts, &pos, &perr) {
			goto fail56
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail56
		}
		goto ok0
	fail56:
		pos = pos2
		// ǒ a q
		// ǒ
		if !_accept(parser, _ǒAccepts, &pos, &perr) {
			goto fail58
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail58
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail58
		}
		goto ok0
	fail58:
		pos = pos2
		// ǒ a
		// ǒ
		if !_accept(parser, _ǒAccepts, &pos, &perr) {
			goto fail60
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail60
		}
		goto ok0
	fail60:
		pos = pos2
		// ǒ q
		// ǒ
		if !_accept(parser, _ǒAccepts, &pos, &perr) {
			goto fail62
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail62
		}
		goto ok0
	fail62:
		pos = pos2
		// ǒ
		if !_accept(parser, _ǒAccepts, &pos, &perr) {
			goto fail64
		}
		goto ok0
	fail64:
		pos = pos2
		// ě o q
		// ě
		if !_accept(parser, _ěAccepts, &pos, &perr) {
			goto fail65
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail65
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail65
		}
		goto ok0
	fail65:
		pos = pos2
		// ě o
		// ě
		if !_accept(parser, _ěAccepts, &pos, &perr) {
			goto fail67
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail67
		}
		goto ok0
	fail67:
		pos = pos2
		// ě i
		// ě
		if !_accept(parser, _ěAccepts, &pos, &perr) {
			goto fail69
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail69
		}
		goto ok0
	fail69:
		pos = pos2
		// ě a q
		// ě
		if !_accept(parser, _ěAccepts, &pos, &perr) {
			goto fail71
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail71
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail71
		}
		goto ok0
	fail71:
		pos = pos2
		// ě a
		// ě
		if !_accept(parser, _ěAccepts, &pos, &perr) {
			goto fail73
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail73
		}
		goto ok0
	fail73:
		pos = pos2
		// ě q
		// ě
		if !_accept(parser, _ěAccepts, &pos, &perr) {
			goto fail75
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail75
		}
		goto ok0
	fail75:
		pos = pos2
		// ě
		if !_accept(parser, _ěAccepts, &pos, &perr) {
			goto fail77
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _desinence__ǎ__ǔ__ǐ__ǒ__ě, start, pos, perr)
fail:
	return _memoize(parser, _desinence__ǎ__ǔ__ǐ__ǒ__ě, start, -1, perr)
}

func _desinence__ǎ__ǔ__ǐ__ǒ__ěNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_desinence__ǎ__ǔ__ǐ__ǒ__ě]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _desinence__ǎ__ǔ__ǐ__ǒ__ě}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "desinence<ǎ, ǔ, ǐ, ǒ, ě>"}
	// ǎ o/ǎ i/ǎ q/ǎ/ǔ a o/ǔ a i/ǔ e q/ǔ e/ǔ o q/ǔ o/ǔ i/ǔ a q/ǔ a/ǔ q/ǔ/ǐ a o/ǐ a i/ǐ e q/ǐ e/ǐ o q/ǐ o/ǐ u/ǐ a q/ǐ a/ǐ q/ǐ/ǒ e q/ǒ e/ǒ i/ǒ a q/ǒ a/ǒ q/ǒ/ě o q/ě o/ě i/ě a q/ě a/ě q/ě
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// ǎ o
		// ǎ
		if !_node(parser, _ǎNode, node, &pos) {
			goto fail3
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǎ i
		// ǎ
		if !_node(parser, _ǎNode, node, &pos) {
			goto fail5
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǎ q
		// ǎ
		if !_node(parser, _ǎNode, node, &pos) {
			goto fail7
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǎ
		if !_node(parser, _ǎNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǔ a o
		// ǔ
		if !_node(parser, _ǔNode, node, &pos) {
			goto fail10
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail10
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǔ a i
		// ǔ
		if !_node(parser, _ǔNode, node, &pos) {
			goto fail12
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail12
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail12
		}
		goto ok0
	fail12:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǔ e q
		// ǔ
		if !_node(parser, _ǔNode, node, &pos) {
			goto fail14
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail14
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǔ e
		// ǔ
		if !_node(parser, _ǔNode, node, &pos) {
			goto fail16
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǔ o q
		// ǔ
		if !_node(parser, _ǔNode, node, &pos) {
			goto fail18
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail18
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail18
		}
		goto ok0
	fail18:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǔ o
		// ǔ
		if !_node(parser, _ǔNode, node, &pos) {
			goto fail20
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail20
		}
		goto ok0
	fail20:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǔ i
		// ǔ
		if !_node(parser, _ǔNode, node, &pos) {
			goto fail22
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail22
		}
		goto ok0
	fail22:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǔ a q
		// ǔ
		if !_node(parser, _ǔNode, node, &pos) {
			goto fail24
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail24
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail24
		}
		goto ok0
	fail24:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǔ a
		// ǔ
		if !_node(parser, _ǔNode, node, &pos) {
			goto fail26
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail26
		}
		goto ok0
	fail26:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǔ q
		// ǔ
		if !_node(parser, _ǔNode, node, &pos) {
			goto fail28
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail28
		}
		goto ok0
	fail28:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǔ
		if !_node(parser, _ǔNode, node, &pos) {
			goto fail30
		}
		goto ok0
	fail30:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǐ a o
		// ǐ
		if !_node(parser, _ǐNode, node, &pos) {
			goto fail31
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail31
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail31
		}
		goto ok0
	fail31:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǐ a i
		// ǐ
		if !_node(parser, _ǐNode, node, &pos) {
			goto fail33
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail33
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail33
		}
		goto ok0
	fail33:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǐ e q
		// ǐ
		if !_node(parser, _ǐNode, node, &pos) {
			goto fail35
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail35
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail35
		}
		goto ok0
	fail35:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǐ e
		// ǐ
		if !_node(parser, _ǐNode, node, &pos) {
			goto fail37
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail37
		}
		goto ok0
	fail37:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǐ o q
		// ǐ
		if !_node(parser, _ǐNode, node, &pos) {
			goto fail39
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail39
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail39
		}
		goto ok0
	fail39:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǐ o
		// ǐ
		if !_node(parser, _ǐNode, node, &pos) {
			goto fail41
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail41
		}
		goto ok0
	fail41:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǐ u
		// ǐ
		if !_node(parser, _ǐNode, node, &pos) {
			goto fail43
		}
		// u
		if !_node(parser, _uNode, node, &pos) {
			goto fail43
		}
		goto ok0
	fail43:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǐ a q
		// ǐ
		if !_node(parser, _ǐNode, node, &pos) {
			goto fail45
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail45
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail45
		}
		goto ok0
	fail45:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǐ a
		// ǐ
		if !_node(parser, _ǐNode, node, &pos) {
			goto fail47
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail47
		}
		goto ok0
	fail47:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǐ q
		// ǐ
		if !_node(parser, _ǐNode, node, &pos) {
			goto fail49
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail49
		}
		goto ok0
	fail49:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǐ
		if !_node(parser, _ǐNode, node, &pos) {
			goto fail51
		}
		goto ok0
	fail51:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǒ e q
		// ǒ
		if !_node(parser, _ǒNode, node, &pos) {
			goto fail52
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail52
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail52
		}
		goto ok0
	fail52:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǒ e
		// ǒ
		if !_node(parser, _ǒNode, node, &pos) {
			goto fail54
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail54
		}
		goto ok0
	fail54:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǒ i
		// ǒ
		if !_node(parser, _ǒNode, node, &pos) {
			goto fail56
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail56
		}
		goto ok0
	fail56:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǒ a q
		// ǒ
		if !_node(parser, _ǒNode, node, &pos) {
			goto fail58
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail58
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail58
		}
		goto ok0
	fail58:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǒ a
		// ǒ
		if !_node(parser, _ǒNode, node, &pos) {
			goto fail60
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail60
		}
		goto ok0
	fail60:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǒ q
		// ǒ
		if !_node(parser, _ǒNode, node, &pos) {
			goto fail62
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail62
		}
		goto ok0
	fail62:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǒ
		if !_node(parser, _ǒNode, node, &pos) {
			goto fail64
		}
		goto ok0
	fail64:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ě o q
		// ě
		if !_node(parser, _ěNode, node, &pos) {
			goto fail65
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail65
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail65
		}
		goto ok0
	fail65:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ě o
		// ě
		if !_node(parser, _ěNode, node, &pos) {
			goto fail67
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail67
		}
		goto ok0
	fail67:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ě i
		// ě
		if !_node(parser, _ěNode, node, &pos) {
			goto fail69
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail69
		}
		goto ok0
	fail69:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ě a q
		// ě
		if !_node(parser, _ěNode, node, &pos) {
			goto fail71
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail71
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail71
		}
		goto ok0
	fail71:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ě a
		// ě
		if !_node(parser, _ěNode, node, &pos) {
			goto fail73
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail73
		}
		goto ok0
	fail73:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ě q
		// ě
		if !_node(parser, _ěNode, node, &pos) {
			goto fail75
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail75
		}
		goto ok0
	fail75:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ě
		if !_node(parser, _ěNode, node, &pos) {
			goto fail77
		}
		goto ok0
	fail77:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _desinence__ǎ__ǔ__ǐ__ǒ__ěFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _desinence__ǎ__ǔ__ǐ__ǒ__ě, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "desinence__ǎ__ǔ__ǐ__ǒ__ě",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _desinence__ǎ__ǔ__ǐ__ǒ__ě}
	// ǎ o/ǎ i/ǎ q/ǎ/ǔ a o/ǔ a i/ǔ e q/ǔ e/ǔ o q/ǔ o/ǔ i/ǔ a q/ǔ a/ǔ q/ǔ/ǐ a o/ǐ a i/ǐ e q/ǐ e/ǐ o q/ǐ o/ǐ u/ǐ a q/ǐ a/ǐ q/ǐ/ǒ e q/ǒ e/ǒ i/ǒ a q/ǒ a/ǒ q/ǒ/ě o q/ě o/ě i/ě a q/ě a/ě q/ě
	{
		pos2 := pos
		// ǎ o
		// ǎ
		if !_fail(parser, _ǎFail, errPos, failure, &pos) {
			goto fail3
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// ǎ i
		// ǎ
		if !_fail(parser, _ǎFail, errPos, failure, &pos) {
			goto fail5
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// ǎ q
		// ǎ
		if !_fail(parser, _ǎFail, errPos, failure, &pos) {
			goto fail7
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// ǎ
		if !_fail(parser, _ǎFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// ǔ a o
		// ǔ
		if !_fail(parser, _ǔFail, errPos, failure, &pos) {
			goto fail10
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail10
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		// ǔ a i
		// ǔ
		if !_fail(parser, _ǔFail, errPos, failure, &pos) {
			goto fail12
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail12
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail12
		}
		goto ok0
	fail12:
		pos = pos2
		// ǔ e q
		// ǔ
		if !_fail(parser, _ǔFail, errPos, failure, &pos) {
			goto fail14
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail14
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// ǔ e
		// ǔ
		if !_fail(parser, _ǔFail, errPos, failure, &pos) {
			goto fail16
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		pos = pos2
		// ǔ o q
		// ǔ
		if !_fail(parser, _ǔFail, errPos, failure, &pos) {
			goto fail18
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail18
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail18
		}
		goto ok0
	fail18:
		pos = pos2
		// ǔ o
		// ǔ
		if !_fail(parser, _ǔFail, errPos, failure, &pos) {
			goto fail20
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail20
		}
		goto ok0
	fail20:
		pos = pos2
		// ǔ i
		// ǔ
		if !_fail(parser, _ǔFail, errPos, failure, &pos) {
			goto fail22
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail22
		}
		goto ok0
	fail22:
		pos = pos2
		// ǔ a q
		// ǔ
		if !_fail(parser, _ǔFail, errPos, failure, &pos) {
			goto fail24
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail24
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail24
		}
		goto ok0
	fail24:
		pos = pos2
		// ǔ a
		// ǔ
		if !_fail(parser, _ǔFail, errPos, failure, &pos) {
			goto fail26
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail26
		}
		goto ok0
	fail26:
		pos = pos2
		// ǔ q
		// ǔ
		if !_fail(parser, _ǔFail, errPos, failure, &pos) {
			goto fail28
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail28
		}
		goto ok0
	fail28:
		pos = pos2
		// ǔ
		if !_fail(parser, _ǔFail, errPos, failure, &pos) {
			goto fail30
		}
		goto ok0
	fail30:
		pos = pos2
		// ǐ a o
		// ǐ
		if !_fail(parser, _ǐFail, errPos, failure, &pos) {
			goto fail31
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail31
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail31
		}
		goto ok0
	fail31:
		pos = pos2
		// ǐ a i
		// ǐ
		if !_fail(parser, _ǐFail, errPos, failure, &pos) {
			goto fail33
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail33
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail33
		}
		goto ok0
	fail33:
		pos = pos2
		// ǐ e q
		// ǐ
		if !_fail(parser, _ǐFail, errPos, failure, &pos) {
			goto fail35
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail35
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail35
		}
		goto ok0
	fail35:
		pos = pos2
		// ǐ e
		// ǐ
		if !_fail(parser, _ǐFail, errPos, failure, &pos) {
			goto fail37
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail37
		}
		goto ok0
	fail37:
		pos = pos2
		// ǐ o q
		// ǐ
		if !_fail(parser, _ǐFail, errPos, failure, &pos) {
			goto fail39
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail39
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail39
		}
		goto ok0
	fail39:
		pos = pos2
		// ǐ o
		// ǐ
		if !_fail(parser, _ǐFail, errPos, failure, &pos) {
			goto fail41
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail41
		}
		goto ok0
	fail41:
		pos = pos2
		// ǐ u
		// ǐ
		if !_fail(parser, _ǐFail, errPos, failure, &pos) {
			goto fail43
		}
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail43
		}
		goto ok0
	fail43:
		pos = pos2
		// ǐ a q
		// ǐ
		if !_fail(parser, _ǐFail, errPos, failure, &pos) {
			goto fail45
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail45
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail45
		}
		goto ok0
	fail45:
		pos = pos2
		// ǐ a
		// ǐ
		if !_fail(parser, _ǐFail, errPos, failure, &pos) {
			goto fail47
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail47
		}
		goto ok0
	fail47:
		pos = pos2
		// ǐ q
		// ǐ
		if !_fail(parser, _ǐFail, errPos, failure, &pos) {
			goto fail49
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail49
		}
		goto ok0
	fail49:
		pos = pos2
		// ǐ
		if !_fail(parser, _ǐFail, errPos, failure, &pos) {
			goto fail51
		}
		goto ok0
	fail51:
		pos = pos2
		// ǒ e q
		// ǒ
		if !_fail(parser, _ǒFail, errPos, failure, &pos) {
			goto fail52
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail52
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail52
		}
		goto ok0
	fail52:
		pos = pos2
		// ǒ e
		// ǒ
		if !_fail(parser, _ǒFail, errPos, failure, &pos) {
			goto fail54
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail54
		}
		goto ok0
	fail54:
		pos = pos2
		// ǒ i
		// ǒ
		if !_fail(parser, _ǒFail, errPos, failure, &pos) {
			goto fail56
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail56
		}
		goto ok0
	fail56:
		pos = pos2
		// ǒ a q
		// ǒ
		if !_fail(parser, _ǒFail, errPos, failure, &pos) {
			goto fail58
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail58
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail58
		}
		goto ok0
	fail58:
		pos = pos2
		// ǒ a
		// ǒ
		if !_fail(parser, _ǒFail, errPos, failure, &pos) {
			goto fail60
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail60
		}
		goto ok0
	fail60:
		pos = pos2
		// ǒ q
		// ǒ
		if !_fail(parser, _ǒFail, errPos, failure, &pos) {
			goto fail62
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail62
		}
		goto ok0
	fail62:
		pos = pos2
		// ǒ
		if !_fail(parser, _ǒFail, errPos, failure, &pos) {
			goto fail64
		}
		goto ok0
	fail64:
		pos = pos2
		// ě o q
		// ě
		if !_fail(parser, _ěFail, errPos, failure, &pos) {
			goto fail65
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail65
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail65
		}
		goto ok0
	fail65:
		pos = pos2
		// ě o
		// ě
		if !_fail(parser, _ěFail, errPos, failure, &pos) {
			goto fail67
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail67
		}
		goto ok0
	fail67:
		pos = pos2
		// ě i
		// ě
		if !_fail(parser, _ěFail, errPos, failure, &pos) {
			goto fail69
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail69
		}
		goto ok0
	fail69:
		pos = pos2
		// ě a q
		// ě
		if !_fail(parser, _ěFail, errPos, failure, &pos) {
			goto fail71
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail71
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail71
		}
		goto ok0
	fail71:
		pos = pos2
		// ě a
		// ě
		if !_fail(parser, _ěFail, errPos, failure, &pos) {
			goto fail73
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail73
		}
		goto ok0
	fail73:
		pos = pos2
		// ě q
		// ě
		if !_fail(parser, _ěFail, errPos, failure, &pos) {
			goto fail75
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail75
		}
		goto ok0
	fail75:
		pos = pos2
		// ě
		if !_fail(parser, _ěFail, errPos, failure, &pos) {
			goto fail77
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _desinence__ǎ__ǔ__ǐ__ǒ__ěAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_desinence__ǎ__ǔ__ǐ__ǒ__ě]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _desinence__ǎ__ǔ__ǐ__ǒ__ě}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// ǎ o/ǎ i/ǎ q/ǎ/ǔ a o/ǔ a i/ǔ e q/ǔ e/ǔ o q/ǔ o/ǔ i/ǔ a q/ǔ a/ǔ q/ǔ/ǐ a o/ǐ a i/ǐ e q/ǐ e/ǐ o q/ǐ o/ǐ u/ǐ a q/ǐ a/ǐ q/ǐ/ǒ e q/ǒ e/ǒ i/ǒ a q/ǒ a/ǒ q/ǒ/ě o q/ě o/ě i/ě a q/ě a/ě q/ě
	{
		pos2 := pos
		// ǎ o
		{
			var node4 string
			// ǎ
			if p, n := _ǎAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
		}
		goto ok0
	fail3:
		pos = pos2
		// ǎ i
		{
			var node6 string
			// ǎ
			if p, n := _ǎAction(parser, pos); n == nil {
				goto fail5
			} else {
				node6 = *n
				pos = p
			}
			node += node6
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail5
			} else {
				node6 = *n
				pos = p
			}
			node += node6
		}
		goto ok0
	fail5:
		pos = pos2
		// ǎ q
		{
			var node8 string
			// ǎ
			if p, n := _ǎAction(parser, pos); n == nil {
				goto fail7
			} else {
				node8 = *n
				pos = p
			}
			node += node8
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail7
			} else {
				node8 = *n
				pos = p
			}
			node += node8
		}
		goto ok0
	fail7:
		pos = pos2
		// ǎ
		if p, n := _ǎAction(parser, pos); n == nil {
			goto fail9
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail9:
		pos = pos2
		// ǔ a o
		{
			var node11 string
			// ǔ
			if p, n := _ǔAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
		}
		goto ok0
	fail10:
		pos = pos2
		// ǔ a i
		{
			var node13 string
			// ǔ
			if p, n := _ǔAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
		}
		goto ok0
	fail12:
		pos = pos2
		// ǔ e q
		{
			var node15 string
			// ǔ
			if p, n := _ǔAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
		}
		goto ok0
	fail14:
		pos = pos2
		// ǔ e
		{
			var node17 string
			// ǔ
			if p, n := _ǔAction(parser, pos); n == nil {
				goto fail16
			} else {
				node17 = *n
				pos = p
			}
			node += node17
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail16
			} else {
				node17 = *n
				pos = p
			}
			node += node17
		}
		goto ok0
	fail16:
		pos = pos2
		// ǔ o q
		{
			var node19 string
			// ǔ
			if p, n := _ǔAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
		}
		goto ok0
	fail18:
		pos = pos2
		// ǔ o
		{
			var node21 string
			// ǔ
			if p, n := _ǔAction(parser, pos); n == nil {
				goto fail20
			} else {
				node21 = *n
				pos = p
			}
			node += node21
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail20
			} else {
				node21 = *n
				pos = p
			}
			node += node21
		}
		goto ok0
	fail20:
		pos = pos2
		// ǔ i
		{
			var node23 string
			// ǔ
			if p, n := _ǔAction(parser, pos); n == nil {
				goto fail22
			} else {
				node23 = *n
				pos = p
			}
			node += node23
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail22
			} else {
				node23 = *n
				pos = p
			}
			node += node23
		}
		goto ok0
	fail22:
		pos = pos2
		// ǔ a q
		{
			var node25 string
			// ǔ
			if p, n := _ǔAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
		}
		goto ok0
	fail24:
		pos = pos2
		// ǔ a
		{
			var node27 string
			// ǔ
			if p, n := _ǔAction(parser, pos); n == nil {
				goto fail26
			} else {
				node27 = *n
				pos = p
			}
			node += node27
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail26
			} else {
				node27 = *n
				pos = p
			}
			node += node27
		}
		goto ok0
	fail26:
		pos = pos2
		// ǔ q
		{
			var node29 string
			// ǔ
			if p, n := _ǔAction(parser, pos); n == nil {
				goto fail28
			} else {
				node29 = *n
				pos = p
			}
			node += node29
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail28
			} else {
				node29 = *n
				pos = p
			}
			node += node29
		}
		goto ok0
	fail28:
		pos = pos2
		// ǔ
		if p, n := _ǔAction(parser, pos); n == nil {
			goto fail30
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail30:
		pos = pos2
		// ǐ a o
		{
			var node32 string
			// ǐ
			if p, n := _ǐAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
		}
		goto ok0
	fail31:
		pos = pos2
		// ǐ a i
		{
			var node34 string
			// ǐ
			if p, n := _ǐAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
		}
		goto ok0
	fail33:
		pos = pos2
		// ǐ e q
		{
			var node36 string
			// ǐ
			if p, n := _ǐAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
		}
		goto ok0
	fail35:
		pos = pos2
		// ǐ e
		{
			var node38 string
			// ǐ
			if p, n := _ǐAction(parser, pos); n == nil {
				goto fail37
			} else {
				node38 = *n
				pos = p
			}
			node += node38
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail37
			} else {
				node38 = *n
				pos = p
			}
			node += node38
		}
		goto ok0
	fail37:
		pos = pos2
		// ǐ o q
		{
			var node40 string
			// ǐ
			if p, n := _ǐAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
		}
		goto ok0
	fail39:
		pos = pos2
		// ǐ o
		{
			var node42 string
			// ǐ
			if p, n := _ǐAction(parser, pos); n == nil {
				goto fail41
			} else {
				node42 = *n
				pos = p
			}
			node += node42
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail41
			} else {
				node42 = *n
				pos = p
			}
			node += node42
		}
		goto ok0
	fail41:
		pos = pos2
		// ǐ u
		{
			var node44 string
			// ǐ
			if p, n := _ǐAction(parser, pos); n == nil {
				goto fail43
			} else {
				node44 = *n
				pos = p
			}
			node += node44
			// u
			if p, n := _uAction(parser, pos); n == nil {
				goto fail43
			} else {
				node44 = *n
				pos = p
			}
			node += node44
		}
		goto ok0
	fail43:
		pos = pos2
		// ǐ a q
		{
			var node46 string
			// ǐ
			if p, n := _ǐAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
		}
		goto ok0
	fail45:
		pos = pos2
		// ǐ a
		{
			var node48 string
			// ǐ
			if p, n := _ǐAction(parser, pos); n == nil {
				goto fail47
			} else {
				node48 = *n
				pos = p
			}
			node += node48
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail47
			} else {
				node48 = *n
				pos = p
			}
			node += node48
		}
		goto ok0
	fail47:
		pos = pos2
		// ǐ q
		{
			var node50 string
			// ǐ
			if p, n := _ǐAction(parser, pos); n == nil {
				goto fail49
			} else {
				node50 = *n
				pos = p
			}
			node += node50
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail49
			} else {
				node50 = *n
				pos = p
			}
			node += node50
		}
		goto ok0
	fail49:
		pos = pos2
		// ǐ
		if p, n := _ǐAction(parser, pos); n == nil {
			goto fail51
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail51:
		pos = pos2
		// ǒ e q
		{
			var node53 string
			// ǒ
			if p, n := _ǒAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
		}
		goto ok0
	fail52:
		pos = pos2
		// ǒ e
		{
			var node55 string
			// ǒ
			if p, n := _ǒAction(parser, pos); n == nil {
				goto fail54
			} else {
				node55 = *n
				pos = p
			}
			node += node55
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail54
			} else {
				node55 = *n
				pos = p
			}
			node += node55
		}
		goto ok0
	fail54:
		pos = pos2
		// ǒ i
		{
			var node57 string
			// ǒ
			if p, n := _ǒAction(parser, pos); n == nil {
				goto fail56
			} else {
				node57 = *n
				pos = p
			}
			node += node57
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail56
			} else {
				node57 = *n
				pos = p
			}
			node += node57
		}
		goto ok0
	fail56:
		pos = pos2
		// ǒ a q
		{
			var node59 string
			// ǒ
			if p, n := _ǒAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
		}
		goto ok0
	fail58:
		pos = pos2
		// ǒ a
		{
			var node61 string
			// ǒ
			if p, n := _ǒAction(parser, pos); n == nil {
				goto fail60
			} else {
				node61 = *n
				pos = p
			}
			node += node61
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail60
			} else {
				node61 = *n
				pos = p
			}
			node += node61
		}
		goto ok0
	fail60:
		pos = pos2
		// ǒ q
		{
			var node63 string
			// ǒ
			if p, n := _ǒAction(parser, pos); n == nil {
				goto fail62
			} else {
				node63 = *n
				pos = p
			}
			node += node63
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail62
			} else {
				node63 = *n
				pos = p
			}
			node += node63
		}
		goto ok0
	fail62:
		pos = pos2
		// ǒ
		if p, n := _ǒAction(parser, pos); n == nil {
			goto fail64
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail64:
		pos = pos2
		// ě o q
		{
			var node66 string
			// ě
			if p, n := _ěAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
		}
		goto ok0
	fail65:
		pos = pos2
		// ě o
		{
			var node68 string
			// ě
			if p, n := _ěAction(parser, pos); n == nil {
				goto fail67
			} else {
				node68 = *n
				pos = p
			}
			node += node68
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail67
			} else {
				node68 = *n
				pos = p
			}
			node += node68
		}
		goto ok0
	fail67:
		pos = pos2
		// ě i
		{
			var node70 string
			// ě
			if p, n := _ěAction(parser, pos); n == nil {
				goto fail69
			} else {
				node70 = *n
				pos = p
			}
			node += node70
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail69
			} else {
				node70 = *n
				pos = p
			}
			node += node70
		}
		goto ok0
	fail69:
		pos = pos2
		// ě a q
		{
			var node72 string
			// ě
			if p, n := _ěAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
		}
		goto ok0
	fail71:
		pos = pos2
		// ě a
		{
			var node74 string
			// ě
			if p, n := _ěAction(parser, pos); n == nil {
				goto fail73
			} else {
				node74 = *n
				pos = p
			}
			node += node74
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail73
			} else {
				node74 = *n
				pos = p
			}
			node += node74
		}
		goto ok0
	fail73:
		pos = pos2
		// ě q
		{
			var node76 string
			// ě
			if p, n := _ěAction(parser, pos); n == nil {
				goto fail75
			} else {
				node76 = *n
				pos = p
			}
			node += node76
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail75
			} else {
				node76 = *n
				pos = p
			}
			node += node76
		}
		goto ok0
	fail75:
		pos = pos2
		// ě
		if p, n := _ěAction(parser, pos); n == nil {
			goto fail77
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _desinence__ả__ủ__ỉ__ỏ__ẻAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _desinence__ả__ủ__ỉ__ỏ__ẻ, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// ả o/ả i/ả q/ả/ủ a o/ủ a i/ủ e q/ủ e/ủ o q/ủ o/ủ i/ủ a q/ủ a/ủ q/ủ/ỉ a o/ỉ a i/ỉ e q/ỉ e/ỉ o q/ỉ o/ỉ u/ỉ a q/ỉ a/ỉ q/ỉ/ỏ e q/ỏ e/ỏ i/ỏ a q/ỏ a/ỏ q/ỏ/ẻ o q/ẻ o/ẻ i/ẻ a q/ẻ a/ẻ q/ẻ
	{
		pos2 := pos
		// ả o
		// ả
		if !_accept(parser, _ảAccepts, &pos, &perr) {
			goto fail3
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// ả i
		// ả
		if !_accept(parser, _ảAccepts, &pos, &perr) {
			goto fail5
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// ả q
		// ả
		if !_accept(parser, _ảAccepts, &pos, &perr) {
			goto fail7
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// ả
		if !_accept(parser, _ảAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// ủ a o
		// ủ
		if !_accept(parser, _ủAccepts, &pos, &perr) {
			goto fail10
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail10
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		// ủ a i
		// ủ
		if !_accept(parser, _ủAccepts, &pos, &perr) {
			goto fail12
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail12
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail12
		}
		goto ok0
	fail12:
		pos = pos2
		// ủ e q
		// ủ
		if !_accept(parser, _ủAccepts, &pos, &perr) {
			goto fail14
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail14
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// ủ e
		// ủ
		if !_accept(parser, _ủAccepts, &pos, &perr) {
			goto fail16
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail16
		}
		goto ok0
	fail16:
		pos = pos2
		// ủ o q
		// ủ
		if !_accept(parser, _ủAccepts, &pos, &perr) {
			goto fail18
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail18
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail18
		}
		goto ok0
	fail18:
		pos = pos2
		// ủ o
		// ủ
		if !_accept(parser, _ủAccepts, &pos, &perr) {
			goto fail20
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail20
		}
		goto ok0
	fail20:
		pos = pos2
		// ủ i
		// ủ
		if !_accept(parser, _ủAccepts, &pos, &perr) {
			goto fail22
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail22
		}
		goto ok0
	fail22:
		pos = pos2
		// ủ a q
		// ủ
		if !_accept(parser, _ủAccepts, &pos, &perr) {
			goto fail24
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail24
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail24
		}
		goto ok0
	fail24:
		pos = pos2
		// ủ a
		// ủ
		if !_accept(parser, _ủAccepts, &pos, &perr) {
			goto fail26
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail26
		}
		goto ok0
	fail26:
		pos = pos2
		// ủ q
		// ủ
		if !_accept(parser, _ủAccepts, &pos, &perr) {
			goto fail28
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail28
		}
		goto ok0
	fail28:
		pos = pos2
		// ủ
		if !_accept(parser, _ủAccepts, &pos, &perr) {
			goto fail30
		}
		goto ok0
	fail30:
		pos = pos2
		// ỉ a o
		// ỉ
		if !_accept(parser, _ỉAccepts, &pos, &perr) {
			goto fail31
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail31
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail31
		}
		goto ok0
	fail31:
		pos = pos2
		// ỉ a i
		// ỉ
		if !_accept(parser, _ỉAccepts, &pos, &perr) {
			goto fail33
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail33
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail33
		}
		goto ok0
	fail33:
		pos = pos2
		// ỉ e q
		// ỉ
		if !_accept(parser, _ỉAccepts, &pos, &perr) {
			goto fail35
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail35
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail35
		}
		goto ok0
	fail35:
		pos = pos2
		// ỉ e
		// ỉ
		if !_accept(parser, _ỉAccepts, &pos, &perr) {
			goto fail37
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail37
		}
		goto ok0
	fail37:
		pos = pos2
		// ỉ o q
		// ỉ
		if !_accept(parser, _ỉAccepts, &pos, &perr) {
			goto fail39
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail39
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail39
		}
		goto ok0
	fail39:
		pos = pos2
		// ỉ o
		// ỉ
		if !_accept(parser, _ỉAccepts, &pos, &perr) {
			goto fail41
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail41
		}
		goto ok0
	fail41:
		pos = pos2
		// ỉ u
		// ỉ
		if !_accept(parser, _ỉAccepts, &pos, &perr) {
			goto fail43
		}
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail43
		}
		goto ok0
	fail43:
		pos = pos2
		// ỉ a q
		// ỉ
		if !_accept(parser, _ỉAccepts, &pos, &perr) {
			goto fail45
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail45
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail45
		}
		goto ok0
	fail45:
		pos = pos2
		// ỉ a
		// ỉ
		if !_accept(parser, _ỉAccepts, &pos, &perr) {
			goto fail47
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail47
		}
		goto ok0
	fail47:
		pos = pos2
		// ỉ q
		// ỉ
		if !_accept(parser, _ỉAccepts, &pos, &perr) {
			goto fail49
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail49
		}
		goto ok0
	fail49:
		pos = pos2
		// ỉ
		if !_accept(parser, _ỉAccepts, &pos, &perr) {
			goto fail51
		}
		goto ok0
	fail51:
		pos = pos2
		// ỏ e q
		// ỏ
		if !_accept(parser, _ỏAccepts, &pos, &perr) {
			goto fail52
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail52
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail52
		}
		goto ok0
	fail52:
		pos = pos2
		// ỏ e
		// ỏ
		if !_accept(parser, _ỏAccepts, &pos, &perr) {
			goto fail54
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail54
		}
		goto ok0
	fail54:
		pos = pos2
		// ỏ i
		// ỏ
		if !_accept(parser, _ỏAccepts, &pos, &perr) {
			goto fail56
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail56
		}
		goto ok0
	fail56:
		pos = pos2
		// ỏ a q
		// ỏ
		if !_accept(parser, _ỏAccepts, &pos, &perr) {
			goto fail58
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail58
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail58
		}
		goto ok0
	fail58:
		pos = pos2
		// ỏ a
		// ỏ
		if !_accept(parser, _ỏAccepts, &pos, &perr) {
			goto fail60
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail60
		}
		goto ok0
	fail60:
		pos = pos2
		// ỏ q
		// ỏ
		if !_accept(parser, _ỏAccepts, &pos, &perr) {
			goto fail62
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail62
		}
		goto ok0
	fail62:
		pos = pos2
		// ỏ
		if !_accept(parser, _ỏAccepts, &pos, &perr) {
			goto fail64
		}
		goto ok0
	fail64:
		pos = pos2
		// ẻ o q
		// ẻ
		if !_accept(parser, _ẻAccepts, &pos, &perr) {
			goto fail65
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail65
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail65
		}
		goto ok0
	fail65:
		pos = pos2
		// ẻ o
		// ẻ
		if !_accept(parser, _ẻAccepts, &pos, &perr) {
			goto fail67
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail67
		}
		goto ok0
	fail67:
		pos = pos2
		// ẻ i
		// ẻ
		if !_accept(parser, _ẻAccepts, &pos, &perr) {
			goto fail69
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail69
		}
		goto ok0
	fail69:
		pos = pos2
		// ẻ a q
		// ẻ
		if !_accept(parser, _ẻAccepts, &pos, &perr) {
			goto fail71
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail71
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail71
		}
		goto ok0
	fail71:
		pos = pos2
		// ẻ a
		// ẻ
		if !_accept(parser, _ẻAccepts, &pos, &perr) {
			goto fail73
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail73
		}
		goto ok0
	fail73:
		pos = pos2
		// ẻ q
		// ẻ
		if !_accept(parser, _ẻAccepts, &pos, &perr) {
			goto fail75
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail75
		}
		goto ok0
	fail75:
		pos = pos2
		// ẻ
		if !_accept(parser, _ẻAccepts, &pos, &perr) {
			goto fail77
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _desinence__ả__ủ__ỉ__ỏ__ẻ, start, pos, perr)
fail:
	return _memoize(parser, _desinence__ả__ủ__ỉ__ỏ__ẻ, start, -1, perr)
}

func _desinence__ả__ủ__ỉ__ỏ__ẻNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_desinence__ả__ủ__ỉ__ỏ__ẻ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _desinence__ả__ủ__ỉ__ỏ__ẻ}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "desinence<ả, ủ, ỉ, ỏ, ẻ>"}
	// ả o/ả i/ả q/ả/ủ a o/ủ a i/ủ e q/ủ e/ủ o q/ủ o/ủ i/ủ a q/ủ a/ủ q/ủ/ỉ a o/ỉ a i/ỉ e q/ỉ e/ỉ o q/ỉ o/ỉ u/ỉ a q/ỉ a/ỉ q/ỉ/ỏ e q/ỏ e/ỏ i/ỏ a q/ỏ a/ỏ q/ỏ/ẻ o q/ẻ o/ẻ i/ẻ a q/ẻ a/ẻ q/ẻ
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// ả o
		// ả
		if !_node(parser, _ảNode, node, &pos) {
			goto fail3
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ả i
		// ả
		if !_node(parser, _ảNode, node, &pos) {
			goto fail5
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ả q
		// ả
		if !_node(parser, _ảNode, node, &pos) {
			goto fail7
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ả
		if !_node(parser, _ảNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ủ a o
		// ủ
		if !_node(parser, _ủNode, node, &pos) {
			goto fail10
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail10
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ủ a i
		// ủ
		if !_node(parser, _ủNode, node, &pos) {
			goto fail12
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail12
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail12
		}
		goto ok0
	fail12:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ủ e q
		// ủ
		if !_node(parser, _ủNode, node, &pos) {
			goto fail14
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail14
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ủ e
		// ủ
		if !_node(parser, _ủNode, node, &pos) {
			goto fail16
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ủ o q
		// ủ
		if !_node(parser, _ủNode, node, &pos) {
			goto fail18
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail18
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail18
		}
		goto ok0
	fail18:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ủ o
		// ủ
		if !_node(parser, _ủNode, node, &pos) {
			goto fail20
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail20
		}
		goto ok0
	fail20:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ủ i
		// ủ
		if !_node(parser, _ủNode, node, &pos) {
			goto fail22
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail22
		}
		goto ok0
	fail22:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ủ a q
		// ủ
		if !_node(parser, _ủNode, node, &pos) {
			goto fail24
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail24
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail24
		}
		goto ok0
	fail24:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ủ a
		// ủ
		if !_node(parser, _ủNode, node, &pos) {
			goto fail26
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail26
		}
		goto ok0
	fail26:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ủ q
		// ủ
		if !_node(parser, _ủNode, node, &pos) {
			goto fail28
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail28
		}
		goto ok0
	fail28:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ủ
		if !_node(parser, _ủNode, node, &pos) {
			goto fail30
		}
		goto ok0
	fail30:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ỉ a o
		// ỉ
		if !_node(parser, _ỉNode, node, &pos) {
			goto fail31
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail31
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail31
		}
		goto ok0
	fail31:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ỉ a i
		// ỉ
		if !_node(parser, _ỉNode, node, &pos) {
			goto fail33
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail33
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail33
		}
		goto ok0
	fail33:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ỉ e q
		// ỉ
		if !_node(parser, _ỉNode, node, &pos) {
			goto fail35
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail35
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail35
		}
		goto ok0
	fail35:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ỉ e
		// ỉ
		if !_node(parser, _ỉNode, node, &pos) {
			goto fail37
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail37
		}
		goto ok0
	fail37:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ỉ o q
		// ỉ
		if !_node(parser, _ỉNode, node, &pos) {
			goto fail39
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail39
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail39
		}
		goto ok0
	fail39:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ỉ o
		// ỉ
		if !_node(parser, _ỉNode, node, &pos) {
			goto fail41
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail41
		}
		goto ok0
	fail41:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ỉ u
		// ỉ
		if !_node(parser, _ỉNode, node, &pos) {
			goto fail43
		}
		// u
		if !_node(parser, _uNode, node, &pos) {
			goto fail43
		}
		goto ok0
	fail43:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ỉ a q
		// ỉ
		if !_node(parser, _ỉNode, node, &pos) {
			goto fail45
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail45
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail45
		}
		goto ok0
	fail45:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ỉ a
		// ỉ
		if !_node(parser, _ỉNode, node, &pos) {
			goto fail47
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail47
		}
		goto ok0
	fail47:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ỉ q
		// ỉ
		if !_node(parser, _ỉNode, node, &pos) {
			goto fail49
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail49
		}
		goto ok0
	fail49:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ỉ
		if !_node(parser, _ỉNode, node, &pos) {
			goto fail51
		}
		goto ok0
	fail51:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ỏ e q
		// ỏ
		if !_node(parser, _ỏNode, node, &pos) {
			goto fail52
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail52
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail52
		}
		goto ok0
	fail52:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ỏ e
		// ỏ
		if !_node(parser, _ỏNode, node, &pos) {
			goto fail54
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail54
		}
		goto ok0
	fail54:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ỏ i
		// ỏ
		if !_node(parser, _ỏNode, node, &pos) {
			goto fail56
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail56
		}
		goto ok0
	fail56:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ỏ a q
		// ỏ
		if !_node(parser, _ỏNode, node, &pos) {
			goto fail58
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail58
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail58
		}
		goto ok0
	fail58:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ỏ a
		// ỏ
		if !_node(parser, _ỏNode, node, &pos) {
			goto fail60
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail60
		}
		goto ok0
	fail60:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ỏ q
		// ỏ
		if !_node(parser, _ỏNode, node, &pos) {
			goto fail62
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail62
		}
		goto ok0
	fail62:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ỏ
		if !_node(parser, _ỏNode, node, &pos) {
			goto fail64
		}
		goto ok0
	fail64:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ẻ o q
		// ẻ
		if !_node(parser, _ẻNode, node, &pos) {
			goto fail65
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail65
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail65
		}
		goto ok0
	fail65:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ẻ o
		// ẻ
		if !_node(parser, _ẻNode, node, &pos) {
			goto fail67
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail67
		}
		goto ok0
	fail67:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ẻ i
		// ẻ
		if !_node(parser, _ẻNode, node, &pos) {
			goto fail69
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail69
		}
		goto ok0
	fail69:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ẻ a q
		// ẻ
		if !_node(parser, _ẻNode, node, &pos) {
			goto fail71
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail71
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail71
		}
		goto ok0
	fail71:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ẻ a
		// ẻ
		if !_node(parser, _ẻNode, node, &pos) {
			goto fail73
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail73
		}
		goto ok0
	fail73:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ẻ q
		// ẻ
		if !_node(parser, _ẻNode, node, &pos) {
			goto fail75
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail75
		}
		goto ok0
	fail75:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ẻ
		if !_node(parser, _ẻNode, node, &pos) {
			goto fail77
		}
		goto ok0
	fail77:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _desinence__ả__ủ__ỉ__ỏ__ẻFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _desinence__ả__ủ__ỉ__ỏ__ẻ, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "desinence__ả__ủ__ỉ__ỏ__ẻ",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _desinence__ả__ủ__ỉ__ỏ__ẻ}
	// ả o/ả i/ả q/ả/ủ a o/ủ a i/ủ e q/ủ e/ủ o q/ủ o/ủ i/ủ a q/ủ a/ủ q/ủ/ỉ a o/ỉ a i/ỉ e q/ỉ e/ỉ o q/ỉ o/ỉ u/ỉ a q/ỉ a/ỉ q/ỉ/ỏ e q/ỏ e/ỏ i/ỏ a q/ỏ a/ỏ q/ỏ/ẻ o q/ẻ o/ẻ i/ẻ a q/ẻ a/ẻ q/ẻ
	{
		pos2 := pos
		// ả o
		// ả
		if !_fail(parser, _ảFail, errPos, failure, &pos) {
			goto fail3
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// ả i
		// ả
		if !_fail(parser, _ảFail, errPos, failure, &pos) {
			goto fail5
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// ả q
		// ả
		if !_fail(parser, _ảFail, errPos, failure, &pos) {
			goto fail7
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// ả
		if !_fail(parser, _ảFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// ủ a o
		// ủ
		if !_fail(parser, _ủFail, errPos, failure, &pos) {
			goto fail10
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail10
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		// ủ a i
		// ủ
		if !_fail(parser, _ủFail, errPos, failure, &pos) {
			goto fail12
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail12
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail12
		}
		goto ok0
	fail12:
		pos = pos2
		// ủ e q
		// ủ
		if !_fail(parser, _ủFail, errPos, failure, &pos) {
			goto fail14
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail14
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// ủ e
		// ủ
		if !_fail(parser, _ủFail, errPos, failure, &pos) {
			goto fail16
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		pos = pos2
		// ủ o q
		// ủ
		if !_fail(parser, _ủFail, errPos, failure, &pos) {
			goto fail18
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail18
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail18
		}
		goto ok0
	fail18:
		pos = pos2
		// ủ o
		// ủ
		if !_fail(parser, _ủFail, errPos, failure, &pos) {
			goto fail20
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail20
		}
		goto ok0
	fail20:
		pos = pos2
		// ủ i
		// ủ
		if !_fail(parser, _ủFail, errPos, failure, &pos) {
			goto fail22
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail22
		}
		goto ok0
	fail22:
		pos = pos2
		// ủ a q
		// ủ
		if !_fail(parser, _ủFail, errPos, failure, &pos) {
			goto fail24
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail24
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail24
		}
		goto ok0
	fail24:
		pos = pos2
		// ủ a
		// ủ
		if !_fail(parser, _ủFail, errPos, failure, &pos) {
			goto fail26
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail26
		}
		goto ok0
	fail26:
		pos = pos2
		// ủ q
		// ủ
		if !_fail(parser, _ủFail, errPos, failure, &pos) {
			goto fail28
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail28
		}
		goto ok0
	fail28:
		pos = pos2
		// ủ
		if !_fail(parser, _ủFail, errPos, failure, &pos) {
			goto fail30
		}
		goto ok0
	fail30:
		pos = pos2
		// ỉ a o
		// ỉ
		if !_fail(parser, _ỉFail, errPos, failure, &pos) {
			goto fail31
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail31
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail31
		}
		goto ok0
	fail31:
		pos = pos2
		// ỉ a i
		// ỉ
		if !_fail(parser, _ỉFail, errPos, failure, &pos) {
			goto fail33
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail33
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail33
		}
		goto ok0
	fail33:
		pos = pos2
		// ỉ e q
		// ỉ
		if !_fail(parser, _ỉFail, errPos, failure, &pos) {
			goto fail35
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail35
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail35
		}
		goto ok0
	fail35:
		pos = pos2
		// ỉ e
		// ỉ
		if !_fail(parser, _ỉFail, errPos, failure, &pos) {
			goto fail37
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail37
		}
		goto ok0
	fail37:
		pos = pos2
		// ỉ o q
		// ỉ
		if !_fail(parser, _ỉFail, errPos, failure, &pos) {
			goto fail39
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail39
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail39
		}
		goto ok0
	fail39:
		pos = pos2
		// ỉ o
		// ỉ
		if !_fail(parser, _ỉFail, errPos, failure, &pos) {
			goto fail41
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail41
		}
		goto ok0
	fail41:
		pos = pos2
		// ỉ u
		// ỉ
		if !_fail(parser, _ỉFail, errPos, failure, &pos) {
			goto fail43
		}
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail43
		}
		goto ok0
	fail43:
		pos = pos2
		// ỉ a q
		// ỉ
		if !_fail(parser, _ỉFail, errPos, failure, &pos) {
			goto fail45
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail45
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail45
		}
		goto ok0
	fail45:
		pos = pos2
		// ỉ a
		// ỉ
		if !_fail(parser, _ỉFail, errPos, failure, &pos) {
			goto fail47
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail47
		}
		goto ok0
	fail47:
		pos = pos2
		// ỉ q
		// ỉ
		if !_fail(parser, _ỉFail, errPos, failure, &pos) {
			goto fail49
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail49
		}
		goto ok0
	fail49:
		pos = pos2
		// ỉ
		if !_fail(parser, _ỉFail, errPos, failure, &pos) {
			goto fail51
		}
		goto ok0
	fail51:
		pos = pos2
		// ỏ e q
		// ỏ
		if !_fail(parser, _ỏFail, errPos, failure, &pos) {
			goto fail52
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail52
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail52
		}
		goto ok0
	fail52:
		pos = pos2
		// ỏ e
		// ỏ
		if !_fail(parser, _ỏFail, errPos, failure, &pos) {
			goto fail54
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail54
		}
		goto ok0
	fail54:
		pos = pos2
		// ỏ i
		// ỏ
		if !_fail(parser, _ỏFail, errPos, failure, &pos) {
			goto fail56
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail56
		}
		goto ok0
	fail56:
		pos = pos2
		// ỏ a q
		// ỏ
		if !_fail(parser, _ỏFail, errPos, failure, &pos) {
			goto fail58
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail58
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail58
		}
		goto ok0
	fail58:
		pos = pos2
		// ỏ a
		// ỏ
		if !_fail(parser, _ỏFail, errPos, failure, &pos) {
			goto fail60
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail60
		}
		goto ok0
	fail60:
		pos = pos2
		// ỏ q
		// ỏ
		if !_fail(parser, _ỏFail, errPos, failure, &pos) {
			goto fail62
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail62
		}
		goto ok0
	fail62:
		pos = pos2
		// ỏ
		if !_fail(parser, _ỏFail, errPos, failure, &pos) {
			goto fail64
		}
		goto ok0
	fail64:
		pos = pos2
		// ẻ o q
		// ẻ
		if !_fail(parser, _ẻFail, errPos, failure, &pos) {
			goto fail65
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail65
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail65
		}
		goto ok0
	fail65:
		pos = pos2
		// ẻ o
		// ẻ
		if !_fail(parser, _ẻFail, errPos, failure, &pos) {
			goto fail67
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail67
		}
		goto ok0
	fail67:
		pos = pos2
		// ẻ i
		// ẻ
		if !_fail(parser, _ẻFail, errPos, failure, &pos) {
			goto fail69
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail69
		}
		goto ok0
	fail69:
		pos = pos2
		// ẻ a q
		// ẻ
		if !_fail(parser, _ẻFail, errPos, failure, &pos) {
			goto fail71
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail71
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail71
		}
		goto ok0
	fail71:
		pos = pos2
		// ẻ a
		// ẻ
		if !_fail(parser, _ẻFail, errPos, failure, &pos) {
			goto fail73
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail73
		}
		goto ok0
	fail73:
		pos = pos2
		// ẻ q
		// ẻ
		if !_fail(parser, _ẻFail, errPos, failure, &pos) {
			goto fail75
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail75
		}
		goto ok0
	fail75:
		pos = pos2
		// ẻ
		if !_fail(parser, _ẻFail, errPos, failure, &pos) {
			goto fail77
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _desinence__ả__ủ__ỉ__ỏ__ẻAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_desinence__ả__ủ__ỉ__ỏ__ẻ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _desinence__ả__ủ__ỉ__ỏ__ẻ}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// ả o/ả i/ả q/ả/ủ a o/ủ a i/ủ e q/ủ e/ủ o q/ủ o/ủ i/ủ a q/ủ a/ủ q/ủ/ỉ a o/ỉ a i/ỉ e q/ỉ e/ỉ o q/ỉ o/ỉ u/ỉ a q/ỉ a/ỉ q/ỉ/ỏ e q/ỏ e/ỏ i/ỏ a q/ỏ a/ỏ q/ỏ/ẻ o q/ẻ o/ẻ i/ẻ a q/ẻ a/ẻ q/ẻ
	{
		pos2 := pos
		// ả o
		{
			var node4 string
			// ả
			if p, n := _ảAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
		}
		goto ok0
	fail3:
		pos = pos2
		// ả i
		{
			var node6 string
			// ả
			if p, n := _ảAction(parser, pos); n == nil {
				goto fail5
			} else {
				node6 = *n
				pos = p
			}
			node += node6
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail5
			} else {
				node6 = *n
				pos = p
			}
			node += node6
		}
		goto ok0
	fail5:
		pos = pos2
		// ả q
		{
			var node8 string
			// ả
			if p, n := _ảAction(parser, pos); n == nil {
				goto fail7
			} else {
				node8 = *n
				pos = p
			}
			node += node8
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail7
			} else {
				node8 = *n
				pos = p
			}
			node += node8
		}
		goto ok0
	fail7:
		pos = pos2
		// ả
		if p, n := _ảAction(parser, pos); n == nil {
			goto fail9
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail9:
		pos = pos2
		// ủ a o
		{
			var node11 string
			// ủ
			if p, n := _ủAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
		}
		goto ok0
	fail10:
		pos = pos2
		// ủ a i
		{
			var node13 string
			// ủ
			if p, n := _ủAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
		}
		goto ok0
	fail12:
		pos = pos2
		// ủ e q
		{
			var node15 string
			// ủ
			if p, n := _ủAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
		}
		goto ok0
	fail14:
		pos = pos2
		// ủ e
		{
			var node17 string
			// ủ
			if p, n := _ủAction(parser, pos); n == nil {
				goto fail16
			} else {
				node17 = *n
				pos = p
			}
			node += node17
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail16
			} else {
				node17 = *n
				pos = p
			}
			node += node17
		}
		goto ok0
	fail16:
		pos = pos2
		// ủ o q
		{
			var node19 string
			// ủ
			if p, n := _ủAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
		}
		goto ok0
	fail18:
		pos = pos2
		// ủ o
		{
			var node21 string
			// ủ
			if p, n := _ủAction(parser, pos); n == nil {
				goto fail20
			} else {
				node21 = *n
				pos = p
			}
			node += node21
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail20
			} else {
				node21 = *n
				pos = p
			}
			node += node21
		}
		goto ok0
	fail20:
		pos = pos2
		// ủ i
		{
			var node23 string
			// ủ
			if p, n := _ủAction(parser, pos); n == nil {
				goto fail22
			} else {
				node23 = *n
				pos = p
			}
			node += node23
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail22
			} else {
				node23 = *n
				pos = p
			}
			node += node23
		}
		goto ok0
	fail22:
		pos = pos2
		// ủ a q
		{
			var node25 string
			// ủ
			if p, n := _ủAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
		}
		goto ok0
	fail24:
		pos = pos2
		// ủ a
		{
			var node27 string
			// ủ
			if p, n := _ủAction(parser, pos); n == nil {
				goto fail26
			} else {
				node27 = *n
				pos = p
			}
			node += node27
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail26
			} else {
				node27 = *n
				pos = p
			}
			node += node27
		}
		goto ok0
	fail26:
		pos = pos2
		// ủ q
		{
			var node29 string
			// ủ
			if p, n := _ủAction(parser, pos); n == nil {
				goto fail28
			} else {
				node29 = *n
				pos = p
			}
			node += node29
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail28
			} else {
				node29 = *n
				pos = p
			}
			node += node29
		}
		goto ok0
	fail28:
		pos = pos2
		// ủ
		if p, n := _ủAction(parser, pos); n == nil {
			goto fail30
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail30:
		pos = pos2
		// ỉ a o
		{
			var node32 string
			// ỉ
			if p, n := _ỉAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
		}
		goto ok0
	fail31:
		pos = pos2
		// ỉ a i
		{
			var node34 string
			// ỉ
			if p, n := _ỉAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
		}
		goto ok0
	fail33:
		pos = pos2
		// ỉ e q
		{
			var node36 string
			// ỉ
			if p, n := _ỉAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
		}
		goto ok0
	fail35:
		pos = pos2
		// ỉ e
		{
			var node38 string
			// ỉ
			if p, n := _ỉAction(parser, pos); n == nil {
				goto fail37
			} else {
				node38 = *n
				pos = p
			}
			node += node38
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail37
			} else {
				node38 = *n
				pos = p
			}
			node += node38
		}
		goto ok0
	fail37:
		pos = pos2
		// ỉ o q
		{
			var node40 string
			// ỉ
			if p, n := _ỉAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
		}
		goto ok0
	fail39:
		pos = pos2
		// ỉ o
		{
			var node42 string
			// ỉ
			if p, n := _ỉAction(parser, pos); n == nil {
				goto fail41
			} else {
				node42 = *n
				pos = p
			}
			node += node42
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail41
			} else {
				node42 = *n
				pos = p
			}
			node += node42
		}
		goto ok0
	fail41:
		pos = pos2
		// ỉ u
		{
			var node44 string
			// ỉ
			if p, n := _ỉAction(parser, pos); n == nil {
				goto fail43
			} else {
				node44 = *n
				pos = p
			}
			node += node44
			// u
			if p, n := _uAction(parser, pos); n == nil {
				goto fail43
			} else {
				node44 = *n
				pos = p
			}
			node += node44
		}
		goto ok0
	fail43:
		pos = pos2
		// ỉ a q
		{
			var node46 string
			// ỉ
			if p, n := _ỉAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
		}
		goto ok0
	fail45:
		pos = pos2
		// ỉ a
		{
			var node48 string
			// ỉ
			if p, n := _ỉAction(parser, pos); n == nil {
				goto fail47
			} else {
				node48 = *n
				pos = p
			}
			node += node48
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail47
			} else {
				node48 = *n
				pos = p
			}
			node += node48
		}
		goto ok0
	fail47:
		pos = pos2
		// ỉ q
		{
			var node50 string
			// ỉ
			if p, n := _ỉAction(parser, pos); n == nil {
				goto fail49
			} else {
				node50 = *n
				pos = p
			}
			node += node50
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail49
			} else {
				node50 = *n
				pos = p
			}
			node += node50
		}
		goto ok0
	fail49:
		pos = pos2
		// ỉ
		if p, n := _ỉAction(parser, pos); n == nil {
			goto fail51
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail51:
		pos = pos2
		// ỏ e q
		{
			var node53 string
			// ỏ
			if p, n := _ỏAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
		}
		goto ok0
	fail52:
		pos = pos2
		// ỏ e
		{
			var node55 string
			// ỏ
			if p, n := _ỏAction(parser, pos); n == nil {
				goto fail54
			} else {
				node55 = *n
				pos = p
			}
			node += node55
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail54
			} else {
				node55 = *n
				pos = p
			}
			node += node55
		}
		goto ok0
	fail54:
		pos = pos2
		// ỏ i
		{
			var node57 string
			// ỏ
			if p, n := _ỏAction(parser, pos); n == nil {
				goto fail56
			} else {
				node57 = *n
				pos = p
			}
			node += node57
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail56
			} else {
				node57 = *n
				pos = p
			}
			node += node57
		}
		goto ok0
	fail56:
		pos = pos2
		// ỏ a q
		{
			var node59 string
			// ỏ
			if p, n := _ỏAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
		}
		goto ok0
	fail58:
		pos = pos2
		// ỏ a
		{
			var node61 string
			// ỏ
			if p, n := _ỏAction(parser, pos); n == nil {
				goto fail60
			} else {
				node61 = *n
				pos = p
			}
			node += node61
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail60
			} else {
				node61 = *n
				pos = p
			}
			node += node61
		}
		goto ok0
	fail60:
		pos = pos2
		// ỏ q
		{
			var node63 string
			// ỏ
			if p, n := _ỏAction(parser, pos); n == nil {
				goto fail62
			} else {
				node63 = *n
				pos = p
			}
			node += node63
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail62
			} else {
				node63 = *n
				pos = p
			}
			node += node63
		}
		goto ok0
	fail62:
		pos = pos2
		// ỏ
		if p, n := _ỏAction(parser, pos); n == nil {
			goto fail64
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail64:
		pos = pos2
		// ẻ o q
		{
			var node66 string
			// ẻ
			if p, n := _ẻAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
		}
		goto ok0
	fail65:
		pos = pos2
		// ẻ o
		{
			var node68 string
			// ẻ
			if p, n := _ẻAction(parser, pos); n == nil {
				goto fail67
			} else {
				node68 = *n
				pos = p
			}
			node += node68
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail67
			} else {
				node68 = *n
				pos = p
			}
			node += node68
		}
		goto ok0
	fail67:
		pos = pos2
		// ẻ i
		{
			var node70 string
			// ẻ
			if p, n := _ẻAction(parser, pos); n == nil {
				goto fail69
			} else {
				node70 = *n
				pos = p
			}
			node += node70
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail69
			} else {
				node70 = *n
				pos = p
			}
			node += node70
		}
		goto ok0
	fail69:
		pos = pos2
		// ẻ a q
		{
			var node72 string
			// ẻ
			if p, n := _ẻAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
		}
		goto ok0
	fail71:
		pos = pos2
		// ẻ a
		{
			var node74 string
			// ẻ
			if p, n := _ẻAction(parser, pos); n == nil {
				goto fail73
			} else {
				node74 = *n
				pos = p
			}
			node += node74
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail73
			} else {
				node74 = *n
				pos = p
			}
			node += node74
		}
		goto ok0
	fail73:
		pos = pos2
		// ẻ q
		{
			var node76 string
			// ẻ
			if p, n := _ẻAction(parser, pos); n == nil {
				goto fail75
			} else {
				node76 = *n
				pos = p
			}
			node += node76
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail75
			} else {
				node76 = *n
				pos = p
			}
			node += node76
		}
		goto ok0
	fail75:
		pos = pos2
		// ẻ
		if p, n := _ẻAction(parser, pos); n == nil {
			goto fail77
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _desinence__â__û__î__ô__êAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _desinence__â__û__î__ô__ê, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// â o/â i/â q/â/û a o/û a i/û e q/û e/û o q/û o/û i/û a q/û a/û q/û/î a o/î a i/î e q/î e/î o q/î o/î u/î a q/î a/î q/î/ô e q/ô e/ô i/ô a q/ô a/ô q/ô/ê o q/ê o/ê i/ê a q/ê a/ê q/ê
	{
		pos2 := pos
		// â o
		// â
		if !_accept(parser, _âAccepts, &pos, &perr) {
			goto fail3
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// â i
		// â
		if !_accept(parser, _âAccepts, &pos, &perr) {
			goto fail5
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// â q
		// â
		if !_accept(parser, _âAccepts, &pos, &perr) {
			goto fail7
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// â
		if !_accept(parser, _âAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// û a o
		// û
		if !_accept(parser, _ûAccepts, &pos, &perr) {
			goto fail10
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail10
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		// û a i
		// û
		if !_accept(parser, _ûAccepts, &pos, &perr) {
			goto fail12
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail12
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail12
		}
		goto ok0
	fail12:
		pos = pos2
		// û e q
		// û
		if !_accept(parser, _ûAccepts, &pos, &perr) {
			goto fail14
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail14
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// û e
		// û
		if !_accept(parser, _ûAccepts, &pos, &perr) {
			goto fail16
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail16
		}
		goto ok0
	fail16:
		pos = pos2
		// û o q
		// û
		if !_accept(parser, _ûAccepts, &pos, &perr) {
			goto fail18
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail18
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail18
		}
		goto ok0
	fail18:
		pos = pos2
		// û o
		// û
		if !_accept(parser, _ûAccepts, &pos, &perr) {
			goto fail20
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail20
		}
		goto ok0
	fail20:
		pos = pos2
		// û i
		// û
		if !_accept(parser, _ûAccepts, &pos, &perr) {
			goto fail22
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail22
		}
		goto ok0
	fail22:
		pos = pos2
		// û a q
		// û
		if !_accept(parser, _ûAccepts, &pos, &perr) {
			goto fail24
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail24
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail24
		}
		goto ok0
	fail24:
		pos = pos2
		// û a
		// û
		if !_accept(parser, _ûAccepts, &pos, &perr) {
			goto fail26
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail26
		}
		goto ok0
	fail26:
		pos = pos2
		// û q
		// û
		if !_accept(parser, _ûAccepts, &pos, &perr) {
			goto fail28
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail28
		}
		goto ok0
	fail28:
		pos = pos2
		// û
		if !_accept(parser, _ûAccepts, &pos, &perr) {
			goto fail30
		}
		goto ok0
	fail30:
		pos = pos2
		// î a o
		// î
		if !_accept(parser, _îAccepts, &pos, &perr) {
			goto fail31
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail31
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail31
		}
		goto ok0
	fail31:
		pos = pos2
		// î a i
		// î
		if !_accept(parser, _îAccepts, &pos, &perr) {
			goto fail33
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail33
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail33
		}
		goto ok0
	fail33:
		pos = pos2
		// î e q
		// î
		if !_accept(parser, _îAccepts, &pos, &perr) {
			goto fail35
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail35
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail35
		}
		goto ok0
	fail35:
		pos = pos2
		// î e
		// î
		if !_accept(parser, _îAccepts, &pos, &perr) {
			goto fail37
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail37
		}
		goto ok0
	fail37:
		pos = pos2
		// î o q
		// î
		if !_accept(parser, _îAccepts, &pos, &perr) {
			goto fail39
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail39
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail39
		}
		goto ok0
	fail39:
		pos = pos2
		// î o
		// î
		if !_accept(parser, _îAccepts, &pos, &perr) {
			goto fail41
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail41
		}
		goto ok0
	fail41:
		pos = pos2
		// î u
		// î
		if !_accept(parser, _îAccepts, &pos, &perr) {
			goto fail43
		}
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail43
		}
		goto ok0
	fail43:
		pos = pos2
		// î a q
		// î
		if !_accept(parser, _îAccepts, &pos, &perr) {
			goto fail45
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail45
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail45
		}
		goto ok0
	fail45:
		pos = pos2
		// î a
		// î
		if !_accept(parser, _îAccepts, &pos, &perr) {
			goto fail47
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail47
		}
		goto ok0
	fail47:
		pos = pos2
		// î q
		// î
		if !_accept(parser, _îAccepts, &pos, &perr) {
			goto fail49
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail49
		}
		goto ok0
	fail49:
		pos = pos2
		// î
		if !_accept(parser, _îAccepts, &pos, &perr) {
			goto fail51
		}
		goto ok0
	fail51:
		pos = pos2
		// ô e q
		// ô
		if !_accept(parser, _ôAccepts, &pos, &perr) {
			goto fail52
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail52
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail52
		}
		goto ok0
	fail52:
		pos = pos2
		// ô e
		// ô
		if !_accept(parser, _ôAccepts, &pos, &perr) {
			goto fail54
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail54
		}
		goto ok0
	fail54:
		pos = pos2
		// ô i
		// ô
		if !_accept(parser, _ôAccepts, &pos, &perr) {
			goto fail56
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail56
		}
		goto ok0
	fail56:
		pos = pos2
		// ô a q
		// ô
		if !_accept(parser, _ôAccepts, &pos, &perr) {
			goto fail58
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail58
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail58
		}
		goto ok0
	fail58:
		pos = pos2
		// ô a
		// ô
		if !_accept(parser, _ôAccepts, &pos, &perr) {
			goto fail60
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail60
		}
		goto ok0
	fail60:
		pos = pos2
		// ô q
		// ô
		if !_accept(parser, _ôAccepts, &pos, &perr) {
			goto fail62
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail62
		}
		goto ok0
	fail62:
		pos = pos2
		// ô
		if !_accept(parser, _ôAccepts, &pos, &perr) {
			goto fail64
		}
		goto ok0
	fail64:
		pos = pos2
		// ê o q
		// ê
		if !_accept(parser, _êAccepts, &pos, &perr) {
			goto fail65
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail65
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail65
		}
		goto ok0
	fail65:
		pos = pos2
		// ê o
		// ê
		if !_accept(parser, _êAccepts, &pos, &perr) {
			goto fail67
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail67
		}
		goto ok0
	fail67:
		pos = pos2
		// ê i
		// ê
		if !_accept(parser, _êAccepts, &pos, &perr) {
			goto fail69
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail69
		}
		goto ok0
	fail69:
		pos = pos2
		// ê a q
		// ê
		if !_accept(parser, _êAccepts, &pos, &perr) {
			goto fail71
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail71
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail71
		}
		goto ok0
	fail71:
		pos = pos2
		// ê a
		// ê
		if !_accept(parser, _êAccepts, &pos, &perr) {
			goto fail73
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail73
		}
		goto ok0
	fail73:
		pos = pos2
		// ê q
		// ê
		if !_accept(parser, _êAccepts, &pos, &perr) {
			goto fail75
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail75
		}
		goto ok0
	fail75:
		pos = pos2
		// ê
		if !_accept(parser, _êAccepts, &pos, &perr) {
			goto fail77
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _desinence__â__û__î__ô__ê, start, pos, perr)
fail:
	return _memoize(parser, _desinence__â__û__î__ô__ê, start, -1, perr)
}

func _desinence__â__û__î__ô__êNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_desinence__â__û__î__ô__ê]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _desinence__â__û__î__ô__ê}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "desinence<â, û, î, ô, ê>"}
	// â o/â i/â q/â/û a o/û a i/û e q/û e/û o q/û o/û i/û a q/û a/û q/û/î a o/î a i/î e q/î e/î o q/î o/î u/î a q/î a/î q/î/ô e q/ô e/ô i/ô a q/ô a/ô q/ô/ê o q/ê o/ê i/ê a q/ê a/ê q/ê
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// â o
		// â
		if !_node(parser, _âNode, node, &pos) {
			goto fail3
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// â i
		// â
		if !_node(parser, _âNode, node, &pos) {
			goto fail5
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// â q
		// â
		if !_node(parser, _âNode, node, &pos) {
			goto fail7
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// â
		if !_node(parser, _âNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// û a o
		// û
		if !_node(parser, _ûNode, node, &pos) {
			goto fail10
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail10
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// û a i
		// û
		if !_node(parser, _ûNode, node, &pos) {
			goto fail12
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail12
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail12
		}
		goto ok0
	fail12:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// û e q
		// û
		if !_node(parser, _ûNode, node, &pos) {
			goto fail14
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail14
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// û e
		// û
		if !_node(parser, _ûNode, node, &pos) {
			goto fail16
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// û o q
		// û
		if !_node(parser, _ûNode, node, &pos) {
			goto fail18
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail18
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail18
		}
		goto ok0
	fail18:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// û o
		// û
		if !_node(parser, _ûNode, node, &pos) {
			goto fail20
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail20
		}
		goto ok0
	fail20:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// û i
		// û
		if !_node(parser, _ûNode, node, &pos) {
			goto fail22
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail22
		}
		goto ok0
	fail22:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// û a q
		// û
		if !_node(parser, _ûNode, node, &pos) {
			goto fail24
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail24
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail24
		}
		goto ok0
	fail24:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// û a
		// û
		if !_node(parser, _ûNode, node, &pos) {
			goto fail26
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail26
		}
		goto ok0
	fail26:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// û q
		// û
		if !_node(parser, _ûNode, node, &pos) {
			goto fail28
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail28
		}
		goto ok0
	fail28:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// û
		if !_node(parser, _ûNode, node, &pos) {
			goto fail30
		}
		goto ok0
	fail30:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// î a o
		// î
		if !_node(parser, _îNode, node, &pos) {
			goto fail31
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail31
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail31
		}
		goto ok0
	fail31:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// î a i
		// î
		if !_node(parser, _îNode, node, &pos) {
			goto fail33
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail33
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail33
		}
		goto ok0
	fail33:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// î e q
		// î
		if !_node(parser, _îNode, node, &pos) {
			goto fail35
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail35
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail35
		}
		goto ok0
	fail35:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// î e
		// î
		if !_node(parser, _îNode, node, &pos) {
			goto fail37
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail37
		}
		goto ok0
	fail37:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// î o q
		// î
		if !_node(parser, _îNode, node, &pos) {
			goto fail39
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail39
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail39
		}
		goto ok0
	fail39:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// î o
		// î
		if !_node(parser, _îNode, node, &pos) {
			goto fail41
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail41
		}
		goto ok0
	fail41:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// î u
		// î
		if !_node(parser, _îNode, node, &pos) {
			goto fail43
		}
		// u
		if !_node(parser, _uNode, node, &pos) {
			goto fail43
		}
		goto ok0
	fail43:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// î a q
		// î
		if !_node(parser, _îNode, node, &pos) {
			goto fail45
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail45
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail45
		}
		goto ok0
	fail45:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// î a
		// î
		if !_node(parser, _îNode, node, &pos) {
			goto fail47
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail47
		}
		goto ok0
	fail47:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// î q
		// î
		if !_node(parser, _îNode, node, &pos) {
			goto fail49
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail49
		}
		goto ok0
	fail49:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// î
		if !_node(parser, _îNode, node, &pos) {
			goto fail51
		}
		goto ok0
	fail51:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ô e q
		// ô
		if !_node(parser, _ôNode, node, &pos) {
			goto fail52
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail52
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail52
		}
		goto ok0
	fail52:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ô e
		// ô
		if !_node(parser, _ôNode, node, &pos) {
			goto fail54
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail54
		}
		goto ok0
	fail54:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ô i
		// ô
		if !_node(parser, _ôNode, node, &pos) {
			goto fail56
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail56
		}
		goto ok0
	fail56:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ô a q
		// ô
		if !_node(parser, _ôNode, node, &pos) {
			goto fail58
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail58
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail58
		}
		goto ok0
	fail58:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ô a
		// ô
		if !_node(parser, _ôNode, node, &pos) {
			goto fail60
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail60
		}
		goto ok0
	fail60:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ô q
		// ô
		if !_node(parser, _ôNode, node, &pos) {
			goto fail62
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail62
		}
		goto ok0
	fail62:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ô
		if !_node(parser, _ôNode, node, &pos) {
			goto fail64
		}
		goto ok0
	fail64:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ê o q
		// ê
		if !_node(parser, _êNode, node, &pos) {
			goto fail65
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail65
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail65
		}
		goto ok0
	fail65:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ê o
		// ê
		if !_node(parser, _êNode, node, &pos) {
			goto fail67
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail67
		}
		goto ok0
	fail67:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ê i
		// ê
		if !_node(parser, _êNode, node, &pos) {
			goto fail69
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail69
		}
		goto ok0
	fail69:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ê a q
		// ê
		if !_node(parser, _êNode, node, &pos) {
			goto fail71
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail71
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail71
		}
		goto ok0
	fail71:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ê a
		// ê
		if !_node(parser, _êNode, node, &pos) {
			goto fail73
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail73
		}
		goto ok0
	fail73:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ê q
		// ê
		if !_node(parser, _êNode, node, &pos) {
			goto fail75
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail75
		}
		goto ok0
	fail75:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ê
		if !_node(parser, _êNode, node, &pos) {
			goto fail77
		}
		goto ok0
	fail77:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _desinence__â__û__î__ô__êFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _desinence__â__û__î__ô__ê, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "desinence__â__û__î__ô__ê",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _desinence__â__û__î__ô__ê}
	// â o/â i/â q/â/û a o/û a i/û e q/û e/û o q/û o/û i/û a q/û a/û q/û/î a o/î a i/î e q/î e/î o q/î o/î u/î a q/î a/î q/î/ô e q/ô e/ô i/ô a q/ô a/ô q/ô/ê o q/ê o/ê i/ê a q/ê a/ê q/ê
	{
		pos2 := pos
		// â o
		// â
		if !_fail(parser, _âFail, errPos, failure, &pos) {
			goto fail3
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// â i
		// â
		if !_fail(parser, _âFail, errPos, failure, &pos) {
			goto fail5
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// â q
		// â
		if !_fail(parser, _âFail, errPos, failure, &pos) {
			goto fail7
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// â
		if !_fail(parser, _âFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// û a o
		// û
		if !_fail(parser, _ûFail, errPos, failure, &pos) {
			goto fail10
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail10
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		// û a i
		// û
		if !_fail(parser, _ûFail, errPos, failure, &pos) {
			goto fail12
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail12
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail12
		}
		goto ok0
	fail12:
		pos = pos2
		// û e q
		// û
		if !_fail(parser, _ûFail, errPos, failure, &pos) {
			goto fail14
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail14
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// û e
		// û
		if !_fail(parser, _ûFail, errPos, failure, &pos) {
			goto fail16
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		pos = pos2
		// û o q
		// û
		if !_fail(parser, _ûFail, errPos, failure, &pos) {
			goto fail18
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail18
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail18
		}
		goto ok0
	fail18:
		pos = pos2
		// û o
		// û
		if !_fail(parser, _ûFail, errPos, failure, &pos) {
			goto fail20
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail20
		}
		goto ok0
	fail20:
		pos = pos2
		// û i
		// û
		if !_fail(parser, _ûFail, errPos, failure, &pos) {
			goto fail22
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail22
		}
		goto ok0
	fail22:
		pos = pos2
		// û a q
		// û
		if !_fail(parser, _ûFail, errPos, failure, &pos) {
			goto fail24
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail24
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail24
		}
		goto ok0
	fail24:
		pos = pos2
		// û a
		// û
		if !_fail(parser, _ûFail, errPos, failure, &pos) {
			goto fail26
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail26
		}
		goto ok0
	fail26:
		pos = pos2
		// û q
		// û
		if !_fail(parser, _ûFail, errPos, failure, &pos) {
			goto fail28
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail28
		}
		goto ok0
	fail28:
		pos = pos2
		// û
		if !_fail(parser, _ûFail, errPos, failure, &pos) {
			goto fail30
		}
		goto ok0
	fail30:
		pos = pos2
		// î a o
		// î
		if !_fail(parser, _îFail, errPos, failure, &pos) {
			goto fail31
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail31
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail31
		}
		goto ok0
	fail31:
		pos = pos2
		// î a i
		// î
		if !_fail(parser, _îFail, errPos, failure, &pos) {
			goto fail33
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail33
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail33
		}
		goto ok0
	fail33:
		pos = pos2
		// î e q
		// î
		if !_fail(parser, _îFail, errPos, failure, &pos) {
			goto fail35
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail35
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail35
		}
		goto ok0
	fail35:
		pos = pos2
		// î e
		// î
		if !_fail(parser, _îFail, errPos, failure, &pos) {
			goto fail37
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail37
		}
		goto ok0
	fail37:
		pos = pos2
		// î o q
		// î
		if !_fail(parser, _îFail, errPos, failure, &pos) {
			goto fail39
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail39
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail39
		}
		goto ok0
	fail39:
		pos = pos2
		// î o
		// î
		if !_fail(parser, _îFail, errPos, failure, &pos) {
			goto fail41
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail41
		}
		goto ok0
	fail41:
		pos = pos2
		// î u
		// î
		if !_fail(parser, _îFail, errPos, failure, &pos) {
			goto fail43
		}
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail43
		}
		goto ok0
	fail43:
		pos = pos2
		// î a q
		// î
		if !_fail(parser, _îFail, errPos, failure, &pos) {
			goto fail45
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail45
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail45
		}
		goto ok0
	fail45:
		pos = pos2
		// î a
		// î
		if !_fail(parser, _îFail, errPos, failure, &pos) {
			goto fail47
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail47
		}
		goto ok0
	fail47:
		pos = pos2
		// î q
		// î
		if !_fail(parser, _îFail, errPos, failure, &pos) {
			goto fail49
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail49
		}
		goto ok0
	fail49:
		pos = pos2
		// î
		if !_fail(parser, _îFail, errPos, failure, &pos) {
			goto fail51
		}
		goto ok0
	fail51:
		pos = pos2
		// ô e q
		// ô
		if !_fail(parser, _ôFail, errPos, failure, &pos) {
			goto fail52
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail52
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail52
		}
		goto ok0
	fail52:
		pos = pos2
		// ô e
		// ô
		if !_fail(parser, _ôFail, errPos, failure, &pos) {
			goto fail54
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail54
		}
		goto ok0
	fail54:
		pos = pos2
		// ô i
		// ô
		if !_fail(parser, _ôFail, errPos, failure, &pos) {
			goto fail56
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail56
		}
		goto ok0
	fail56:
		pos = pos2
		// ô a q
		// ô
		if !_fail(parser, _ôFail, errPos, failure, &pos) {
			goto fail58
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail58
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail58
		}
		goto ok0
	fail58:
		pos = pos2
		// ô a
		// ô
		if !_fail(parser, _ôFail, errPos, failure, &pos) {
			goto fail60
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail60
		}
		goto ok0
	fail60:
		pos = pos2
		// ô q
		// ô
		if !_fail(parser, _ôFail, errPos, failure, &pos) {
			goto fail62
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail62
		}
		goto ok0
	fail62:
		pos = pos2
		// ô
		if !_fail(parser, _ôFail, errPos, failure, &pos) {
			goto fail64
		}
		goto ok0
	fail64:
		pos = pos2
		// ê o q
		// ê
		if !_fail(parser, _êFail, errPos, failure, &pos) {
			goto fail65
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail65
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail65
		}
		goto ok0
	fail65:
		pos = pos2
		// ê o
		// ê
		if !_fail(parser, _êFail, errPos, failure, &pos) {
			goto fail67
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail67
		}
		goto ok0
	fail67:
		pos = pos2
		// ê i
		// ê
		if !_fail(parser, _êFail, errPos, failure, &pos) {
			goto fail69
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail69
		}
		goto ok0
	fail69:
		pos = pos2
		// ê a q
		// ê
		if !_fail(parser, _êFail, errPos, failure, &pos) {
			goto fail71
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail71
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail71
		}
		goto ok0
	fail71:
		pos = pos2
		// ê a
		// ê
		if !_fail(parser, _êFail, errPos, failure, &pos) {
			goto fail73
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail73
		}
		goto ok0
	fail73:
		pos = pos2
		// ê q
		// ê
		if !_fail(parser, _êFail, errPos, failure, &pos) {
			goto fail75
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail75
		}
		goto ok0
	fail75:
		pos = pos2
		// ê
		if !_fail(parser, _êFail, errPos, failure, &pos) {
			goto fail77
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _desinence__â__û__î__ô__êAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_desinence__â__û__î__ô__ê]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _desinence__â__û__î__ô__ê}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// â o/â i/â q/â/û a o/û a i/û e q/û e/û o q/û o/û i/û a q/û a/û q/û/î a o/î a i/î e q/î e/î o q/î o/î u/î a q/î a/î q/î/ô e q/ô e/ô i/ô a q/ô a/ô q/ô/ê o q/ê o/ê i/ê a q/ê a/ê q/ê
	{
		pos2 := pos
		// â o
		{
			var node4 string
			// â
			if p, n := _âAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
		}
		goto ok0
	fail3:
		pos = pos2
		// â i
		{
			var node6 string
			// â
			if p, n := _âAction(parser, pos); n == nil {
				goto fail5
			} else {
				node6 = *n
				pos = p
			}
			node += node6
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail5
			} else {
				node6 = *n
				pos = p
			}
			node += node6
		}
		goto ok0
	fail5:
		pos = pos2
		// â q
		{
			var node8 string
			// â
			if p, n := _âAction(parser, pos); n == nil {
				goto fail7
			} else {
				node8 = *n
				pos = p
			}
			node += node8
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail7
			} else {
				node8 = *n
				pos = p
			}
			node += node8
		}
		goto ok0
	fail7:
		pos = pos2
		// â
		if p, n := _âAction(parser, pos); n == nil {
			goto fail9
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail9:
		pos = pos2
		// û a o
		{
			var node11 string
			// û
			if p, n := _ûAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
		}
		goto ok0
	fail10:
		pos = pos2
		// û a i
		{
			var node13 string
			// û
			if p, n := _ûAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
		}
		goto ok0
	fail12:
		pos = pos2
		// û e q
		{
			var node15 string
			// û
			if p, n := _ûAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
		}
		goto ok0
	fail14:
		pos = pos2
		// û e
		{
			var node17 string
			// û
			if p, n := _ûAction(parser, pos); n == nil {
				goto fail16
			} else {
				node17 = *n
				pos = p
			}
			node += node17
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail16
			} else {
				node17 = *n
				pos = p
			}
			node += node17
		}
		goto ok0
	fail16:
		pos = pos2
		// û o q
		{
			var node19 string
			// û
			if p, n := _ûAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
		}
		goto ok0
	fail18:
		pos = pos2
		// û o
		{
			var node21 string
			// û
			if p, n := _ûAction(parser, pos); n == nil {
				goto fail20
			} else {
				node21 = *n
				pos = p
			}
			node += node21
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail20
			} else {
				node21 = *n
				pos = p
			}
			node += node21
		}
		goto ok0
	fail20:
		pos = pos2
		// û i
		{
			var node23 string
			// û
			if p, n := _ûAction(parser, pos); n == nil {
				goto fail22
			} else {
				node23 = *n
				pos = p
			}
			node += node23
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail22
			} else {
				node23 = *n
				pos = p
			}
			node += node23
		}
		goto ok0
	fail22:
		pos = pos2
		// û a q
		{
			var node25 string
			// û
			if p, n := _ûAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
		}
		goto ok0
	fail24:
		pos = pos2
		// û a
		{
			var node27 string
			// û
			if p, n := _ûAction(parser, pos); n == nil {
				goto fail26
			} else {
				node27 = *n
				pos = p
			}
			node += node27
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail26
			} else {
				node27 = *n
				pos = p
			}
			node += node27
		}
		goto ok0
	fail26:
		pos = pos2
		// û q
		{
			var node29 string
			// û
			if p, n := _ûAction(parser, pos); n == nil {
				goto fail28
			} else {
				node29 = *n
				pos = p
			}
			node += node29
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail28
			} else {
				node29 = *n
				pos = p
			}
			node += node29
		}
		goto ok0
	fail28:
		pos = pos2
		// û
		if p, n := _ûAction(parser, pos); n == nil {
			goto fail30
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail30:
		pos = pos2
		// î a o
		{
			var node32 string
			// î
			if p, n := _îAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
		}
		goto ok0
	fail31:
		pos = pos2
		// î a i
		{
			var node34 string
			// î
			if p, n := _îAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
		}
		goto ok0
	fail33:
		pos = pos2
		// î e q
		{
			var node36 string
			// î
			if p, n := _îAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
		}
		goto ok0
	fail35:
		pos = pos2
		// î e
		{
			var node38 string
			// î
			if p, n := _îAction(parser, pos); n == nil {
				goto fail37
			} else {
				node38 = *n
				pos = p
			}
			node += node38
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail37
			} else {
				node38 = *n
				pos = p
			}
			node += node38
		}
		goto ok0
	fail37:
		pos = pos2
		// î o q
		{
			var node40 string
			// î
			if p, n := _îAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
		}
		goto ok0
	fail39:
		pos = pos2
		// î o
		{
			var node42 string
			// î
			if p, n := _îAction(parser, pos); n == nil {
				goto fail41
			} else {
				node42 = *n
				pos = p
			}
			node += node42
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail41
			} else {
				node42 = *n
				pos = p
			}
			node += node42
		}
		goto ok0
	fail41:
		pos = pos2
		// î u
		{
			var node44 string
			// î
			if p, n := _îAction(parser, pos); n == nil {
				goto fail43
			} else {
				node44 = *n
				pos = p
			}
			node += node44
			// u
			if p, n := _uAction(parser, pos); n == nil {
				goto fail43
			} else {
				node44 = *n
				pos = p
			}
			node += node44
		}
		goto ok0
	fail43:
		pos = pos2
		// î a q
		{
			var node46 string
			// î
			if p, n := _îAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
		}
		goto ok0
	fail45:
		pos = pos2
		// î a
		{
			var node48 string
			// î
			if p, n := _îAction(parser, pos); n == nil {
				goto fail47
			} else {
				node48 = *n
				pos = p
			}
			node += node48
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail47
			} else {
				node48 = *n
				pos = p
			}
			node += node48
		}
		goto ok0
	fail47:
		pos = pos2
		// î q
		{
			var node50 string
			// î
			if p, n := _îAction(parser, pos); n == nil {
				goto fail49
			} else {
				node50 = *n
				pos = p
			}
			node += node50
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail49
			} else {
				node50 = *n
				pos = p
			}
			node += node50
		}
		goto ok0
	fail49:
		pos = pos2
		// î
		if p, n := _îAction(parser, pos); n == nil {
			goto fail51
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail51:
		pos = pos2
		// ô e q
		{
			var node53 string
			// ô
			if p, n := _ôAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
		}
		goto ok0
	fail52:
		pos = pos2
		// ô e
		{
			var node55 string
			// ô
			if p, n := _ôAction(parser, pos); n == nil {
				goto fail54
			} else {
				node55 = *n
				pos = p
			}
			node += node55
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail54
			} else {
				node55 = *n
				pos = p
			}
			node += node55
		}
		goto ok0
	fail54:
		pos = pos2
		// ô i
		{
			var node57 string
			// ô
			if p, n := _ôAction(parser, pos); n == nil {
				goto fail56
			} else {
				node57 = *n
				pos = p
			}
			node += node57
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail56
			} else {
				node57 = *n
				pos = p
			}
			node += node57
		}
		goto ok0
	fail56:
		pos = pos2
		// ô a q
		{
			var node59 string
			// ô
			if p, n := _ôAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
		}
		goto ok0
	fail58:
		pos = pos2
		// ô a
		{
			var node61 string
			// ô
			if p, n := _ôAction(parser, pos); n == nil {
				goto fail60
			} else {
				node61 = *n
				pos = p
			}
			node += node61
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail60
			} else {
				node61 = *n
				pos = p
			}
			node += node61
		}
		goto ok0
	fail60:
		pos = pos2
		// ô q
		{
			var node63 string
			// ô
			if p, n := _ôAction(parser, pos); n == nil {
				goto fail62
			} else {
				node63 = *n
				pos = p
			}
			node += node63
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail62
			} else {
				node63 = *n
				pos = p
			}
			node += node63
		}
		goto ok0
	fail62:
		pos = pos2
		// ô
		if p, n := _ôAction(parser, pos); n == nil {
			goto fail64
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail64:
		pos = pos2
		// ê o q
		{
			var node66 string
			// ê
			if p, n := _êAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
		}
		goto ok0
	fail65:
		pos = pos2
		// ê o
		{
			var node68 string
			// ê
			if p, n := _êAction(parser, pos); n == nil {
				goto fail67
			} else {
				node68 = *n
				pos = p
			}
			node += node68
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail67
			} else {
				node68 = *n
				pos = p
			}
			node += node68
		}
		goto ok0
	fail67:
		pos = pos2
		// ê i
		{
			var node70 string
			// ê
			if p, n := _êAction(parser, pos); n == nil {
				goto fail69
			} else {
				node70 = *n
				pos = p
			}
			node += node70
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail69
			} else {
				node70 = *n
				pos = p
			}
			node += node70
		}
		goto ok0
	fail69:
		pos = pos2
		// ê a q
		{
			var node72 string
			// ê
			if p, n := _êAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
		}
		goto ok0
	fail71:
		pos = pos2
		// ê a
		{
			var node74 string
			// ê
			if p, n := _êAction(parser, pos); n == nil {
				goto fail73
			} else {
				node74 = *n
				pos = p
			}
			node += node74
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail73
			} else {
				node74 = *n
				pos = p
			}
			node += node74
		}
		goto ok0
	fail73:
		pos = pos2
		// ê q
		{
			var node76 string
			// ê
			if p, n := _êAction(parser, pos); n == nil {
				goto fail75
			} else {
				node76 = *n
				pos = p
			}
			node += node76
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail75
			} else {
				node76 = *n
				pos = p
			}
			node += node76
		}
		goto ok0
	fail75:
		pos = pos2
		// ê
		if p, n := _êAction(parser, pos); n == nil {
			goto fail77
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _desinence__à__ù__ì__ò__èAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _desinence__à__ù__ì__ò__è, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// à o/à i/à q/à/ù a o/ù a i/ù e q/ù e/ù o q/ù o/ù i/ù a q/ù a/ù q/ù/ì a o/ì a i/ì e q/ì e/ì o q/ì o/ì u/ì a q/ì a/ì q/ì/ò e q/ò e/ò i/ò a q/ò a/ò q/ò/è o q/è o/è i/è a q/è a/è q/è
	{
		pos2 := pos
		// à o
		// à
		if !_accept(parser, _àAccepts, &pos, &perr) {
			goto fail3
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// à i
		// à
		if !_accept(parser, _àAccepts, &pos, &perr) {
			goto fail5
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// à q
		// à
		if !_accept(parser, _àAccepts, &pos, &perr) {
			goto fail7
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// à
		if !_accept(parser, _àAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// ù a o
		// ù
		if !_accept(parser, _ùAccepts, &pos, &perr) {
			goto fail10
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail10
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		// ù a i
		// ù
		if !_accept(parser, _ùAccepts, &pos, &perr) {
			goto fail12
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail12
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail12
		}
		goto ok0
	fail12:
		pos = pos2
		// ù e q
		// ù
		if !_accept(parser, _ùAccepts, &pos, &perr) {
			goto fail14
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail14
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// ù e
		// ù
		if !_accept(parser, _ùAccepts, &pos, &perr) {
			goto fail16
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail16
		}
		goto ok0
	fail16:
		pos = pos2
		// ù o q
		// ù
		if !_accept(parser, _ùAccepts, &pos, &perr) {
			goto fail18
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail18
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail18
		}
		goto ok0
	fail18:
		pos = pos2
		// ù o
		// ù
		if !_accept(parser, _ùAccepts, &pos, &perr) {
			goto fail20
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail20
		}
		goto ok0
	fail20:
		pos = pos2
		// ù i
		// ù
		if !_accept(parser, _ùAccepts, &pos, &perr) {
			goto fail22
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail22
		}
		goto ok0
	fail22:
		pos = pos2
		// ù a q
		// ù
		if !_accept(parser, _ùAccepts, &pos, &perr) {
			goto fail24
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail24
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail24
		}
		goto ok0
	fail24:
		pos = pos2
		// ù a
		// ù
		if !_accept(parser, _ùAccepts, &pos, &perr) {
			goto fail26
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail26
		}
		goto ok0
	fail26:
		pos = pos2
		// ù q
		// ù
		if !_accept(parser, _ùAccepts, &pos, &perr) {
			goto fail28
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail28
		}
		goto ok0
	fail28:
		pos = pos2
		// ù
		if !_accept(parser, _ùAccepts, &pos, &perr) {
			goto fail30
		}
		goto ok0
	fail30:
		pos = pos2
		// ì a o
		// ì
		if !_accept(parser, _ìAccepts, &pos, &perr) {
			goto fail31
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail31
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail31
		}
		goto ok0
	fail31:
		pos = pos2
		// ì a i
		// ì
		if !_accept(parser, _ìAccepts, &pos, &perr) {
			goto fail33
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail33
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail33
		}
		goto ok0
	fail33:
		pos = pos2
		// ì e q
		// ì
		if !_accept(parser, _ìAccepts, &pos, &perr) {
			goto fail35
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail35
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail35
		}
		goto ok0
	fail35:
		pos = pos2
		// ì e
		// ì
		if !_accept(parser, _ìAccepts, &pos, &perr) {
			goto fail37
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail37
		}
		goto ok0
	fail37:
		pos = pos2
		// ì o q
		// ì
		if !_accept(parser, _ìAccepts, &pos, &perr) {
			goto fail39
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail39
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail39
		}
		goto ok0
	fail39:
		pos = pos2
		// ì o
		// ì
		if !_accept(parser, _ìAccepts, &pos, &perr) {
			goto fail41
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail41
		}
		goto ok0
	fail41:
		pos = pos2
		// ì u
		// ì
		if !_accept(parser, _ìAccepts, &pos, &perr) {
			goto fail43
		}
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail43
		}
		goto ok0
	fail43:
		pos = pos2
		// ì a q
		// ì
		if !_accept(parser, _ìAccepts, &pos, &perr) {
			goto fail45
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail45
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail45
		}
		goto ok0
	fail45:
		pos = pos2
		// ì a
		// ì
		if !_accept(parser, _ìAccepts, &pos, &perr) {
			goto fail47
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail47
		}
		goto ok0
	fail47:
		pos = pos2
		// ì q
		// ì
		if !_accept(parser, _ìAccepts, &pos, &perr) {
			goto fail49
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail49
		}
		goto ok0
	fail49:
		pos = pos2
		// ì
		if !_accept(parser, _ìAccepts, &pos, &perr) {
			goto fail51
		}
		goto ok0
	fail51:
		pos = pos2
		// ò e q
		// ò
		if !_accept(parser, _òAccepts, &pos, &perr) {
			goto fail52
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail52
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail52
		}
		goto ok0
	fail52:
		pos = pos2
		// ò e
		// ò
		if !_accept(parser, _òAccepts, &pos, &perr) {
			goto fail54
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail54
		}
		goto ok0
	fail54:
		pos = pos2
		// ò i
		// ò
		if !_accept(parser, _òAccepts, &pos, &perr) {
			goto fail56
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail56
		}
		goto ok0
	fail56:
		pos = pos2
		// ò a q
		// ò
		if !_accept(parser, _òAccepts, &pos, &perr) {
			goto fail58
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail58
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail58
		}
		goto ok0
	fail58:
		pos = pos2
		// ò a
		// ò
		if !_accept(parser, _òAccepts, &pos, &perr) {
			goto fail60
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail60
		}
		goto ok0
	fail60:
		pos = pos2
		// ò q
		// ò
		if !_accept(parser, _òAccepts, &pos, &perr) {
			goto fail62
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail62
		}
		goto ok0
	fail62:
		pos = pos2
		// ò
		if !_accept(parser, _òAccepts, &pos, &perr) {
			goto fail64
		}
		goto ok0
	fail64:
		pos = pos2
		// è o q
		// è
		if !_accept(parser, _èAccepts, &pos, &perr) {
			goto fail65
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail65
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail65
		}
		goto ok0
	fail65:
		pos = pos2
		// è o
		// è
		if !_accept(parser, _èAccepts, &pos, &perr) {
			goto fail67
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail67
		}
		goto ok0
	fail67:
		pos = pos2
		// è i
		// è
		if !_accept(parser, _èAccepts, &pos, &perr) {
			goto fail69
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail69
		}
		goto ok0
	fail69:
		pos = pos2
		// è a q
		// è
		if !_accept(parser, _èAccepts, &pos, &perr) {
			goto fail71
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail71
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail71
		}
		goto ok0
	fail71:
		pos = pos2
		// è a
		// è
		if !_accept(parser, _èAccepts, &pos, &perr) {
			goto fail73
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail73
		}
		goto ok0
	fail73:
		pos = pos2
		// è q
		// è
		if !_accept(parser, _èAccepts, &pos, &perr) {
			goto fail75
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail75
		}
		goto ok0
	fail75:
		pos = pos2
		// è
		if !_accept(parser, _èAccepts, &pos, &perr) {
			goto fail77
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _desinence__à__ù__ì__ò__è, start, pos, perr)
fail:
	return _memoize(parser, _desinence__à__ù__ì__ò__è, start, -1, perr)
}

func _desinence__à__ù__ì__ò__èNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_desinence__à__ù__ì__ò__è]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _desinence__à__ù__ì__ò__è}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "desinence<à, ù, ì, ò, è>"}
	// à o/à i/à q/à/ù a o/ù a i/ù e q/ù e/ù o q/ù o/ù i/ù a q/ù a/ù q/ù/ì a o/ì a i/ì e q/ì e/ì o q/ì o/ì u/ì a q/ì a/ì q/ì/ò e q/ò e/ò i/ò a q/ò a/ò q/ò/è o q/è o/è i/è a q/è a/è q/è
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// à o
		// à
		if !_node(parser, _àNode, node, &pos) {
			goto fail3
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// à i
		// à
		if !_node(parser, _àNode, node, &pos) {
			goto fail5
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// à q
		// à
		if !_node(parser, _àNode, node, &pos) {
			goto fail7
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// à
		if !_node(parser, _àNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ù a o
		// ù
		if !_node(parser, _ùNode, node, &pos) {
			goto fail10
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail10
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ù a i
		// ù
		if !_node(parser, _ùNode, node, &pos) {
			goto fail12
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail12
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail12
		}
		goto ok0
	fail12:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ù e q
		// ù
		if !_node(parser, _ùNode, node, &pos) {
			goto fail14
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail14
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ù e
		// ù
		if !_node(parser, _ùNode, node, &pos) {
			goto fail16
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ù o q
		// ù
		if !_node(parser, _ùNode, node, &pos) {
			goto fail18
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail18
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail18
		}
		goto ok0
	fail18:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ù o
		// ù
		if !_node(parser, _ùNode, node, &pos) {
			goto fail20
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail20
		}
		goto ok0
	fail20:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ù i
		// ù
		if !_node(parser, _ùNode, node, &pos) {
			goto fail22
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail22
		}
		goto ok0
	fail22:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ù a q
		// ù
		if !_node(parser, _ùNode, node, &pos) {
			goto fail24
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail24
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail24
		}
		goto ok0
	fail24:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ù a
		// ù
		if !_node(parser, _ùNode, node, &pos) {
			goto fail26
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail26
		}
		goto ok0
	fail26:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ù q
		// ù
		if !_node(parser, _ùNode, node, &pos) {
			goto fail28
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail28
		}
		goto ok0
	fail28:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ù
		if !_node(parser, _ùNode, node, &pos) {
			goto fail30
		}
		goto ok0
	fail30:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ì a o
		// ì
		if !_node(parser, _ìNode, node, &pos) {
			goto fail31
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail31
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail31
		}
		goto ok0
	fail31:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ì a i
		// ì
		if !_node(parser, _ìNode, node, &pos) {
			goto fail33
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail33
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail33
		}
		goto ok0
	fail33:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ì e q
		// ì
		if !_node(parser, _ìNode, node, &pos) {
			goto fail35
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail35
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail35
		}
		goto ok0
	fail35:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ì e
		// ì
		if !_node(parser, _ìNode, node, &pos) {
			goto fail37
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail37
		}
		goto ok0
	fail37:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ì o q
		// ì
		if !_node(parser, _ìNode, node, &pos) {
			goto fail39
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail39
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail39
		}
		goto ok0
	fail39:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ì o
		// ì
		if !_node(parser, _ìNode, node, &pos) {
			goto fail41
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail41
		}
		goto ok0
	fail41:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ì u
		// ì
		if !_node(parser, _ìNode, node, &pos) {
			goto fail43
		}
		// u
		if !_node(parser, _uNode, node, &pos) {
			goto fail43
		}
		goto ok0
	fail43:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ì a q
		// ì
		if !_node(parser, _ìNode, node, &pos) {
			goto fail45
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail45
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail45
		}
		goto ok0
	fail45:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ì a
		// ì
		if !_node(parser, _ìNode, node, &pos) {
			goto fail47
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail47
		}
		goto ok0
	fail47:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ì q
		// ì
		if !_node(parser, _ìNode, node, &pos) {
			goto fail49
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail49
		}
		goto ok0
	fail49:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ì
		if !_node(parser, _ìNode, node, &pos) {
			goto fail51
		}
		goto ok0
	fail51:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ò e q
		// ò
		if !_node(parser, _òNode, node, &pos) {
			goto fail52
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail52
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail52
		}
		goto ok0
	fail52:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ò e
		// ò
		if !_node(parser, _òNode, node, &pos) {
			goto fail54
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail54
		}
		goto ok0
	fail54:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ò i
		// ò
		if !_node(parser, _òNode, node, &pos) {
			goto fail56
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail56
		}
		goto ok0
	fail56:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ò a q
		// ò
		if !_node(parser, _òNode, node, &pos) {
			goto fail58
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail58
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail58
		}
		goto ok0
	fail58:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ò a
		// ò
		if !_node(parser, _òNode, node, &pos) {
			goto fail60
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail60
		}
		goto ok0
	fail60:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ò q
		// ò
		if !_node(parser, _òNode, node, &pos) {
			goto fail62
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail62
		}
		goto ok0
	fail62:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ò
		if !_node(parser, _òNode, node, &pos) {
			goto fail64
		}
		goto ok0
	fail64:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// è o q
		// è
		if !_node(parser, _èNode, node, &pos) {
			goto fail65
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail65
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail65
		}
		goto ok0
	fail65:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// è o
		// è
		if !_node(parser, _èNode, node, &pos) {
			goto fail67
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail67
		}
		goto ok0
	fail67:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// è i
		// è
		if !_node(parser, _èNode, node, &pos) {
			goto fail69
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail69
		}
		goto ok0
	fail69:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// è a q
		// è
		if !_node(parser, _èNode, node, &pos) {
			goto fail71
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail71
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail71
		}
		goto ok0
	fail71:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// è a
		// è
		if !_node(parser, _èNode, node, &pos) {
			goto fail73
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail73
		}
		goto ok0
	fail73:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// è q
		// è
		if !_node(parser, _èNode, node, &pos) {
			goto fail75
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail75
		}
		goto ok0
	fail75:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// è
		if !_node(parser, _èNode, node, &pos) {
			goto fail77
		}
		goto ok0
	fail77:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _desinence__à__ù__ì__ò__èFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _desinence__à__ù__ì__ò__è, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "desinence__à__ù__ì__ò__è",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _desinence__à__ù__ì__ò__è}
	// à o/à i/à q/à/ù a o/ù a i/ù e q/ù e/ù o q/ù o/ù i/ù a q/ù a/ù q/ù/ì a o/ì a i/ì e q/ì e/ì o q/ì o/ì u/ì a q/ì a/ì q/ì/ò e q/ò e/ò i/ò a q/ò a/ò q/ò/è o q/è o/è i/è a q/è a/è q/è
	{
		pos2 := pos
		// à o
		// à
		if !_fail(parser, _àFail, errPos, failure, &pos) {
			goto fail3
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// à i
		// à
		if !_fail(parser, _àFail, errPos, failure, &pos) {
			goto fail5
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// à q
		// à
		if !_fail(parser, _àFail, errPos, failure, &pos) {
			goto fail7
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// à
		if !_fail(parser, _àFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// ù a o
		// ù
		if !_fail(parser, _ùFail, errPos, failure, &pos) {
			goto fail10
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail10
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		// ù a i
		// ù
		if !_fail(parser, _ùFail, errPos, failure, &pos) {
			goto fail12
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail12
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail12
		}
		goto ok0
	fail12:
		pos = pos2
		// ù e q
		// ù
		if !_fail(parser, _ùFail, errPos, failure, &pos) {
			goto fail14
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail14
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// ù e
		// ù
		if !_fail(parser, _ùFail, errPos, failure, &pos) {
			goto fail16
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		pos = pos2
		// ù o q
		// ù
		if !_fail(parser, _ùFail, errPos, failure, &pos) {
			goto fail18
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail18
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail18
		}
		goto ok0
	fail18:
		pos = pos2
		// ù o
		// ù
		if !_fail(parser, _ùFail, errPos, failure, &pos) {
			goto fail20
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail20
		}
		goto ok0
	fail20:
		pos = pos2
		// ù i
		// ù
		if !_fail(parser, _ùFail, errPos, failure, &pos) {
			goto fail22
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail22
		}
		goto ok0
	fail22:
		pos = pos2
		// ù a q
		// ù
		if !_fail(parser, _ùFail, errPos, failure, &pos) {
			goto fail24
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail24
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail24
		}
		goto ok0
	fail24:
		pos = pos2
		// ù a
		// ù
		if !_fail(parser, _ùFail, errPos, failure, &pos) {
			goto fail26
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail26
		}
		goto ok0
	fail26:
		pos = pos2
		// ù q
		// ù
		if !_fail(parser, _ùFail, errPos, failure, &pos) {
			goto fail28
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail28
		}
		goto ok0
	fail28:
		pos = pos2
		// ù
		if !_fail(parser, _ùFail, errPos, failure, &pos) {
			goto fail30
		}
		goto ok0
	fail30:
		pos = pos2
		// ì a o
		// ì
		if !_fail(parser, _ìFail, errPos, failure, &pos) {
			goto fail31
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail31
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail31
		}
		goto ok0
	fail31:
		pos = pos2
		// ì a i
		// ì
		if !_fail(parser, _ìFail, errPos, failure, &pos) {
			goto fail33
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail33
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail33
		}
		goto ok0
	fail33:
		pos = pos2
		// ì e q
		// ì
		if !_fail(parser, _ìFail, errPos, failure, &pos) {
			goto fail35
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail35
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail35
		}
		goto ok0
	fail35:
		pos = pos2
		// ì e
		// ì
		if !_fail(parser, _ìFail, errPos, failure, &pos) {
			goto fail37
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail37
		}
		goto ok0
	fail37:
		pos = pos2
		// ì o q
		// ì
		if !_fail(parser, _ìFail, errPos, failure, &pos) {
			goto fail39
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail39
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail39
		}
		goto ok0
	fail39:
		pos = pos2
		// ì o
		// ì
		if !_fail(parser, _ìFail, errPos, failure, &pos) {
			goto fail41
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail41
		}
		goto ok0
	fail41:
		pos = pos2
		// ì u
		// ì
		if !_fail(parser, _ìFail, errPos, failure, &pos) {
			goto fail43
		}
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail43
		}
		goto ok0
	fail43:
		pos = pos2
		// ì a q
		// ì
		if !_fail(parser, _ìFail, errPos, failure, &pos) {
			goto fail45
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail45
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail45
		}
		goto ok0
	fail45:
		pos = pos2
		// ì a
		// ì
		if !_fail(parser, _ìFail, errPos, failure, &pos) {
			goto fail47
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail47
		}
		goto ok0
	fail47:
		pos = pos2
		// ì q
		// ì
		if !_fail(parser, _ìFail, errPos, failure, &pos) {
			goto fail49
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail49
		}
		goto ok0
	fail49:
		pos = pos2
		// ì
		if !_fail(parser, _ìFail, errPos, failure, &pos) {
			goto fail51
		}
		goto ok0
	fail51:
		pos = pos2
		// ò e q
		// ò
		if !_fail(parser, _òFail, errPos, failure, &pos) {
			goto fail52
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail52
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail52
		}
		goto ok0
	fail52:
		pos = pos2
		// ò e
		// ò
		if !_fail(parser, _òFail, errPos, failure, &pos) {
			goto fail54
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail54
		}
		goto ok0
	fail54:
		pos = pos2
		// ò i
		// ò
		if !_fail(parser, _òFail, errPos, failure, &pos) {
			goto fail56
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail56
		}
		goto ok0
	fail56:
		pos = pos2
		// ò a q
		// ò
		if !_fail(parser, _òFail, errPos, failure, &pos) {
			goto fail58
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail58
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail58
		}
		goto ok0
	fail58:
		pos = pos2
		// ò a
		// ò
		if !_fail(parser, _òFail, errPos, failure, &pos) {
			goto fail60
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail60
		}
		goto ok0
	fail60:
		pos = pos2
		// ò q
		// ò
		if !_fail(parser, _òFail, errPos, failure, &pos) {
			goto fail62
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail62
		}
		goto ok0
	fail62:
		pos = pos2
		// ò
		if !_fail(parser, _òFail, errPos, failure, &pos) {
			goto fail64
		}
		goto ok0
	fail64:
		pos = pos2
		// è o q
		// è
		if !_fail(parser, _èFail, errPos, failure, &pos) {
			goto fail65
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail65
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail65
		}
		goto ok0
	fail65:
		pos = pos2
		// è o
		// è
		if !_fail(parser, _èFail, errPos, failure, &pos) {
			goto fail67
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail67
		}
		goto ok0
	fail67:
		pos = pos2
		// è i
		// è
		if !_fail(parser, _èFail, errPos, failure, &pos) {
			goto fail69
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail69
		}
		goto ok0
	fail69:
		pos = pos2
		// è a q
		// è
		if !_fail(parser, _èFail, errPos, failure, &pos) {
			goto fail71
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail71
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail71
		}
		goto ok0
	fail71:
		pos = pos2
		// è a
		// è
		if !_fail(parser, _èFail, errPos, failure, &pos) {
			goto fail73
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail73
		}
		goto ok0
	fail73:
		pos = pos2
		// è q
		// è
		if !_fail(parser, _èFail, errPos, failure, &pos) {
			goto fail75
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail75
		}
		goto ok0
	fail75:
		pos = pos2
		// è
		if !_fail(parser, _èFail, errPos, failure, &pos) {
			goto fail77
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _desinence__à__ù__ì__ò__èAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_desinence__à__ù__ì__ò__è]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _desinence__à__ù__ì__ò__è}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// à o/à i/à q/à/ù a o/ù a i/ù e q/ù e/ù o q/ù o/ù i/ù a q/ù a/ù q/ù/ì a o/ì a i/ì e q/ì e/ì o q/ì o/ì u/ì a q/ì a/ì q/ì/ò e q/ò e/ò i/ò a q/ò a/ò q/ò/è o q/è o/è i/è a q/è a/è q/è
	{
		pos2 := pos
		// à o
		{
			var node4 string
			// à
			if p, n := _àAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
		}
		goto ok0
	fail3:
		pos = pos2
		// à i
		{
			var node6 string
			// à
			if p, n := _àAction(parser, pos); n == nil {
				goto fail5
			} else {
				node6 = *n
				pos = p
			}
			node += node6
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail5
			} else {
				node6 = *n
				pos = p
			}
			node += node6
		}
		goto ok0
	fail5:
		pos = pos2
		// à q
		{
			var node8 string
			// à
			if p, n := _àAction(parser, pos); n == nil {
				goto fail7
			} else {
				node8 = *n
				pos = p
			}
			node += node8
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail7
			} else {
				node8 = *n
				pos = p
			}
			node += node8
		}
		goto ok0
	fail7:
		pos = pos2
		// à
		if p, n := _àAction(parser, pos); n == nil {
			goto fail9
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail9:
		pos = pos2
		// ù a o
		{
			var node11 string
			// ù
			if p, n := _ùAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
		}
		goto ok0
	fail10:
		pos = pos2
		// ù a i
		{
			var node13 string
			// ù
			if p, n := _ùAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
		}
		goto ok0
	fail12:
		pos = pos2
		// ù e q
		{
			var node15 string
			// ù
			if p, n := _ùAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
		}
		goto ok0
	fail14:
		pos = pos2
		// ù e
		{
			var node17 string
			// ù
			if p, n := _ùAction(parser, pos); n == nil {
				goto fail16
			} else {
				node17 = *n
				pos = p
			}
			node += node17
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail16
			} else {
				node17 = *n
				pos = p
			}
			node += node17
		}
		goto ok0
	fail16:
		pos = pos2
		// ù o q
		{
			var node19 string
			// ù
			if p, n := _ùAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
		}
		goto ok0
	fail18:
		pos = pos2
		// ù o
		{
			var node21 string
			// ù
			if p, n := _ùAction(parser, pos); n == nil {
				goto fail20
			} else {
				node21 = *n
				pos = p
			}
			node += node21
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail20
			} else {
				node21 = *n
				pos = p
			}
			node += node21
		}
		goto ok0
	fail20:
		pos = pos2
		// ù i
		{
			var node23 string
			// ù
			if p, n := _ùAction(parser, pos); n == nil {
				goto fail22
			} else {
				node23 = *n
				pos = p
			}
			node += node23
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail22
			} else {
				node23 = *n
				pos = p
			}
			node += node23
		}
		goto ok0
	fail22:
		pos = pos2
		// ù a q
		{
			var node25 string
			// ù
			if p, n := _ùAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
		}
		goto ok0
	fail24:
		pos = pos2
		// ù a
		{
			var node27 string
			// ù
			if p, n := _ùAction(parser, pos); n == nil {
				goto fail26
			} else {
				node27 = *n
				pos = p
			}
			node += node27
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail26
			} else {
				node27 = *n
				pos = p
			}
			node += node27
		}
		goto ok0
	fail26:
		pos = pos2
		// ù q
		{
			var node29 string
			// ù
			if p, n := _ùAction(parser, pos); n == nil {
				goto fail28
			} else {
				node29 = *n
				pos = p
			}
			node += node29
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail28
			} else {
				node29 = *n
				pos = p
			}
			node += node29
		}
		goto ok0
	fail28:
		pos = pos2
		// ù
		if p, n := _ùAction(parser, pos); n == nil {
			goto fail30
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail30:
		pos = pos2
		// ì a o
		{
			var node32 string
			// ì
			if p, n := _ìAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
		}
		goto ok0
	fail31:
		pos = pos2
		// ì a i
		{
			var node34 string
			// ì
			if p, n := _ìAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
		}
		goto ok0
	fail33:
		pos = pos2
		// ì e q
		{
			var node36 string
			// ì
			if p, n := _ìAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
		}
		goto ok0
	fail35:
		pos = pos2
		// ì e
		{
			var node38 string
			// ì
			if p, n := _ìAction(parser, pos); n == nil {
				goto fail37
			} else {
				node38 = *n
				pos = p
			}
			node += node38
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail37
			} else {
				node38 = *n
				pos = p
			}
			node += node38
		}
		goto ok0
	fail37:
		pos = pos2
		// ì o q
		{
			var node40 string
			// ì
			if p, n := _ìAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
		}
		goto ok0
	fail39:
		pos = pos2
		// ì o
		{
			var node42 string
			// ì
			if p, n := _ìAction(parser, pos); n == nil {
				goto fail41
			} else {
				node42 = *n
				pos = p
			}
			node += node42
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail41
			} else {
				node42 = *n
				pos = p
			}
			node += node42
		}
		goto ok0
	fail41:
		pos = pos2
		// ì u
		{
			var node44 string
			// ì
			if p, n := _ìAction(parser, pos); n == nil {
				goto fail43
			} else {
				node44 = *n
				pos = p
			}
			node += node44
			// u
			if p, n := _uAction(parser, pos); n == nil {
				goto fail43
			} else {
				node44 = *n
				pos = p
			}
			node += node44
		}
		goto ok0
	fail43:
		pos = pos2
		// ì a q
		{
			var node46 string
			// ì
			if p, n := _ìAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
		}
		goto ok0
	fail45:
		pos = pos2
		// ì a
		{
			var node48 string
			// ì
			if p, n := _ìAction(parser, pos); n == nil {
				goto fail47
			} else {
				node48 = *n
				pos = p
			}
			node += node48
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail47
			} else {
				node48 = *n
				pos = p
			}
			node += node48
		}
		goto ok0
	fail47:
		pos = pos2
		// ì q
		{
			var node50 string
			// ì
			if p, n := _ìAction(parser, pos); n == nil {
				goto fail49
			} else {
				node50 = *n
				pos = p
			}
			node += node50
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail49
			} else {
				node50 = *n
				pos = p
			}
			node += node50
		}
		goto ok0
	fail49:
		pos = pos2
		// ì
		if p, n := _ìAction(parser, pos); n == nil {
			goto fail51
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail51:
		pos = pos2
		// ò e q
		{
			var node53 string
			// ò
			if p, n := _òAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
		}
		goto ok0
	fail52:
		pos = pos2
		// ò e
		{
			var node55 string
			// ò
			if p, n := _òAction(parser, pos); n == nil {
				goto fail54
			} else {
				node55 = *n
				pos = p
			}
			node += node55
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail54
			} else {
				node55 = *n
				pos = p
			}
			node += node55
		}
		goto ok0
	fail54:
		pos = pos2
		// ò i
		{
			var node57 string
			// ò
			if p, n := _òAction(parser, pos); n == nil {
				goto fail56
			} else {
				node57 = *n
				pos = p
			}
			node += node57
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail56
			} else {
				node57 = *n
				pos = p
			}
			node += node57
		}
		goto ok0
	fail56:
		pos = pos2
		// ò a q
		{
			var node59 string
			// ò
			if p, n := _òAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
		}
		goto ok0
	fail58:
		pos = pos2
		// ò a
		{
			var node61 string
			// ò
			if p, n := _òAction(parser, pos); n == nil {
				goto fail60
			} else {
				node61 = *n
				pos = p
			}
			node += node61
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail60
			} else {
				node61 = *n
				pos = p
			}
			node += node61
		}
		goto ok0
	fail60:
		pos = pos2
		// ò q
		{
			var node63 string
			// ò
			if p, n := _òAction(parser, pos); n == nil {
				goto fail62
			} else {
				node63 = *n
				pos = p
			}
			node += node63
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail62
			} else {
				node63 = *n
				pos = p
			}
			node += node63
		}
		goto ok0
	fail62:
		pos = pos2
		// ò
		if p, n := _òAction(parser, pos); n == nil {
			goto fail64
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail64:
		pos = pos2
		// è o q
		{
			var node66 string
			// è
			if p, n := _èAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
		}
		goto ok0
	fail65:
		pos = pos2
		// è o
		{
			var node68 string
			// è
			if p, n := _èAction(parser, pos); n == nil {
				goto fail67
			} else {
				node68 = *n
				pos = p
			}
			node += node68
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail67
			} else {
				node68 = *n
				pos = p
			}
			node += node68
		}
		goto ok0
	fail67:
		pos = pos2
		// è i
		{
			var node70 string
			// è
			if p, n := _èAction(parser, pos); n == nil {
				goto fail69
			} else {
				node70 = *n
				pos = p
			}
			node += node70
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail69
			} else {
				node70 = *n
				pos = p
			}
			node += node70
		}
		goto ok0
	fail69:
		pos = pos2
		// è a q
		{
			var node72 string
			// è
			if p, n := _èAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
		}
		goto ok0
	fail71:
		pos = pos2
		// è a
		{
			var node74 string
			// è
			if p, n := _èAction(parser, pos); n == nil {
				goto fail73
			} else {
				node74 = *n
				pos = p
			}
			node += node74
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail73
			} else {
				node74 = *n
				pos = p
			}
			node += node74
		}
		goto ok0
	fail73:
		pos = pos2
		// è q
		{
			var node76 string
			// è
			if p, n := _èAction(parser, pos); n == nil {
				goto fail75
			} else {
				node76 = *n
				pos = p
			}
			node += node76
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail75
			} else {
				node76 = *n
				pos = p
			}
			node += node76
		}
		goto ok0
	fail75:
		pos = pos2
		// è
		if p, n := _èAction(parser, pos); n == nil {
			goto fail77
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _desinence__ã__ũ__ĩ__õ__ẽAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _desinence__ã__ũ__ĩ__õ__ẽ, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// ã o/ã i/ã q/ã/ũ a o/ũ a i/ũ e q/ũ e/ũ o q/ũ o/ũ i/ũ a q/ũ a/ũ q/ũ/ĩ a o/ĩ a i/ĩ e q/ĩ e/ĩ o q/ĩ o/ĩ u/ĩ a q/ĩ a/ĩ q/ĩ/õ e q/õ e/õ i/õ a q/õ a/õ q/õ/ẽ o q/ẽ o/ẽ i/ẽ a q/ẽ a/ẽ q/ẽ
	{
		pos2 := pos
		// ã o
		// ã
		if !_accept(parser, _ãAccepts, &pos, &perr) {
			goto fail3
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// ã i
		// ã
		if !_accept(parser, _ãAccepts, &pos, &perr) {
			goto fail5
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// ã q
		// ã
		if !_accept(parser, _ãAccepts, &pos, &perr) {
			goto fail7
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// ã
		if !_accept(parser, _ãAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// ũ a o
		// ũ
		if !_accept(parser, _ũAccepts, &pos, &perr) {
			goto fail10
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail10
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		// ũ a i
		// ũ
		if !_accept(parser, _ũAccepts, &pos, &perr) {
			goto fail12
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail12
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail12
		}
		goto ok0
	fail12:
		pos = pos2
		// ũ e q
		// ũ
		if !_accept(parser, _ũAccepts, &pos, &perr) {
			goto fail14
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail14
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// ũ e
		// ũ
		if !_accept(parser, _ũAccepts, &pos, &perr) {
			goto fail16
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail16
		}
		goto ok0
	fail16:
		pos = pos2
		// ũ o q
		// ũ
		if !_accept(parser, _ũAccepts, &pos, &perr) {
			goto fail18
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail18
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail18
		}
		goto ok0
	fail18:
		pos = pos2
		// ũ o
		// ũ
		if !_accept(parser, _ũAccepts, &pos, &perr) {
			goto fail20
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail20
		}
		goto ok0
	fail20:
		pos = pos2
		// ũ i
		// ũ
		if !_accept(parser, _ũAccepts, &pos, &perr) {
			goto fail22
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail22
		}
		goto ok0
	fail22:
		pos = pos2
		// ũ a q
		// ũ
		if !_accept(parser, _ũAccepts, &pos, &perr) {
			goto fail24
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail24
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail24
		}
		goto ok0
	fail24:
		pos = pos2
		// ũ a
		// ũ
		if !_accept(parser, _ũAccepts, &pos, &perr) {
			goto fail26
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail26
		}
		goto ok0
	fail26:
		pos = pos2
		// ũ q
		// ũ
		if !_accept(parser, _ũAccepts, &pos, &perr) {
			goto fail28
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail28
		}
		goto ok0
	fail28:
		pos = pos2
		// ũ
		if !_accept(parser, _ũAccepts, &pos, &perr) {
			goto fail30
		}
		goto ok0
	fail30:
		pos = pos2
		// ĩ a o
		// ĩ
		if !_accept(parser, _ĩAccepts, &pos, &perr) {
			goto fail31
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail31
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail31
		}
		goto ok0
	fail31:
		pos = pos2
		// ĩ a i
		// ĩ
		if !_accept(parser, _ĩAccepts, &pos, &perr) {
			goto fail33
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail33
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail33
		}
		goto ok0
	fail33:
		pos = pos2
		// ĩ e q
		// ĩ
		if !_accept(parser, _ĩAccepts, &pos, &perr) {
			goto fail35
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail35
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail35
		}
		goto ok0
	fail35:
		pos = pos2
		// ĩ e
		// ĩ
		if !_accept(parser, _ĩAccepts, &pos, &perr) {
			goto fail37
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail37
		}
		goto ok0
	fail37:
		pos = pos2
		// ĩ o q
		// ĩ
		if !_accept(parser, _ĩAccepts, &pos, &perr) {
			goto fail39
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail39
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail39
		}
		goto ok0
	fail39:
		pos = pos2
		// ĩ o
		// ĩ
		if !_accept(parser, _ĩAccepts, &pos, &perr) {
			goto fail41
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail41
		}
		goto ok0
	fail41:
		pos = pos2
		// ĩ u
		// ĩ
		if !_accept(parser, _ĩAccepts, &pos, &perr) {
			goto fail43
		}
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail43
		}
		goto ok0
	fail43:
		pos = pos2
		// ĩ a q
		// ĩ
		if !_accept(parser, _ĩAccepts, &pos, &perr) {
			goto fail45
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail45
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail45
		}
		goto ok0
	fail45:
		pos = pos2
		// ĩ a
		// ĩ
		if !_accept(parser, _ĩAccepts, &pos, &perr) {
			goto fail47
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail47
		}
		goto ok0
	fail47:
		pos = pos2
		// ĩ q
		// ĩ
		if !_accept(parser, _ĩAccepts, &pos, &perr) {
			goto fail49
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail49
		}
		goto ok0
	fail49:
		pos = pos2
		// ĩ
		if !_accept(parser, _ĩAccepts, &pos, &perr) {
			goto fail51
		}
		goto ok0
	fail51:
		pos = pos2
		// õ e q
		// õ
		if !_accept(parser, _õAccepts, &pos, &perr) {
			goto fail52
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail52
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail52
		}
		goto ok0
	fail52:
		pos = pos2
		// õ e
		// õ
		if !_accept(parser, _õAccepts, &pos, &perr) {
			goto fail54
		}
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail54
		}
		goto ok0
	fail54:
		pos = pos2
		// õ i
		// õ
		if !_accept(parser, _õAccepts, &pos, &perr) {
			goto fail56
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail56
		}
		goto ok0
	fail56:
		pos = pos2
		// õ a q
		// õ
		if !_accept(parser, _õAccepts, &pos, &perr) {
			goto fail58
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail58
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail58
		}
		goto ok0
	fail58:
		pos = pos2
		// õ a
		// õ
		if !_accept(parser, _õAccepts, &pos, &perr) {
			goto fail60
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail60
		}
		goto ok0
	fail60:
		pos = pos2
		// õ q
		// õ
		if !_accept(parser, _õAccepts, &pos, &perr) {
			goto fail62
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail62
		}
		goto ok0
	fail62:
		pos = pos2
		// õ
		if !_accept(parser, _õAccepts, &pos, &perr) {
			goto fail64
		}
		goto ok0
	fail64:
		pos = pos2
		// ẽ o q
		// ẽ
		if !_accept(parser, _ẽAccepts, &pos, &perr) {
			goto fail65
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail65
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail65
		}
		goto ok0
	fail65:
		pos = pos2
		// ẽ o
		// ẽ
		if !_accept(parser, _ẽAccepts, &pos, &perr) {
			goto fail67
		}
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail67
		}
		goto ok0
	fail67:
		pos = pos2
		// ẽ i
		// ẽ
		if !_accept(parser, _ẽAccepts, &pos, &perr) {
			goto fail69
		}
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail69
		}
		goto ok0
	fail69:
		pos = pos2
		// ẽ a q
		// ẽ
		if !_accept(parser, _ẽAccepts, &pos, &perr) {
			goto fail71
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail71
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail71
		}
		goto ok0
	fail71:
		pos = pos2
		// ẽ a
		// ẽ
		if !_accept(parser, _ẽAccepts, &pos, &perr) {
			goto fail73
		}
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail73
		}
		goto ok0
	fail73:
		pos = pos2
		// ẽ q
		// ẽ
		if !_accept(parser, _ẽAccepts, &pos, &perr) {
			goto fail75
		}
		// q
		if !_accept(parser, _qAccepts, &pos, &perr) {
			goto fail75
		}
		goto ok0
	fail75:
		pos = pos2
		// ẽ
		if !_accept(parser, _ẽAccepts, &pos, &perr) {
			goto fail77
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _desinence__ã__ũ__ĩ__õ__ẽ, start, pos, perr)
fail:
	return _memoize(parser, _desinence__ã__ũ__ĩ__õ__ẽ, start, -1, perr)
}

func _desinence__ã__ũ__ĩ__õ__ẽNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_desinence__ã__ũ__ĩ__õ__ẽ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _desinence__ã__ũ__ĩ__õ__ẽ}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "desinence<ã, ũ, ĩ, õ, ẽ>"}
	// ã o/ã i/ã q/ã/ũ a o/ũ a i/ũ e q/ũ e/ũ o q/ũ o/ũ i/ũ a q/ũ a/ũ q/ũ/ĩ a o/ĩ a i/ĩ e q/ĩ e/ĩ o q/ĩ o/ĩ u/ĩ a q/ĩ a/ĩ q/ĩ/õ e q/õ e/õ i/õ a q/õ a/õ q/õ/ẽ o q/ẽ o/ẽ i/ẽ a q/ẽ a/ẽ q/ẽ
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// ã o
		// ã
		if !_node(parser, _ãNode, node, &pos) {
			goto fail3
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ã i
		// ã
		if !_node(parser, _ãNode, node, &pos) {
			goto fail5
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ã q
		// ã
		if !_node(parser, _ãNode, node, &pos) {
			goto fail7
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ã
		if !_node(parser, _ãNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ũ a o
		// ũ
		if !_node(parser, _ũNode, node, &pos) {
			goto fail10
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail10
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ũ a i
		// ũ
		if !_node(parser, _ũNode, node, &pos) {
			goto fail12
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail12
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail12
		}
		goto ok0
	fail12:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ũ e q
		// ũ
		if !_node(parser, _ũNode, node, &pos) {
			goto fail14
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail14
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ũ e
		// ũ
		if !_node(parser, _ũNode, node, &pos) {
			goto fail16
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ũ o q
		// ũ
		if !_node(parser, _ũNode, node, &pos) {
			goto fail18
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail18
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail18
		}
		goto ok0
	fail18:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ũ o
		// ũ
		if !_node(parser, _ũNode, node, &pos) {
			goto fail20
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail20
		}
		goto ok0
	fail20:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ũ i
		// ũ
		if !_node(parser, _ũNode, node, &pos) {
			goto fail22
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail22
		}
		goto ok0
	fail22:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ũ a q
		// ũ
		if !_node(parser, _ũNode, node, &pos) {
			goto fail24
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail24
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail24
		}
		goto ok0
	fail24:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ũ a
		// ũ
		if !_node(parser, _ũNode, node, &pos) {
			goto fail26
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail26
		}
		goto ok0
	fail26:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ũ q
		// ũ
		if !_node(parser, _ũNode, node, &pos) {
			goto fail28
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail28
		}
		goto ok0
	fail28:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ũ
		if !_node(parser, _ũNode, node, &pos) {
			goto fail30
		}
		goto ok0
	fail30:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ĩ a o
		// ĩ
		if !_node(parser, _ĩNode, node, &pos) {
			goto fail31
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail31
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail31
		}
		goto ok0
	fail31:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ĩ a i
		// ĩ
		if !_node(parser, _ĩNode, node, &pos) {
			goto fail33
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail33
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail33
		}
		goto ok0
	fail33:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ĩ e q
		// ĩ
		if !_node(parser, _ĩNode, node, &pos) {
			goto fail35
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail35
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail35
		}
		goto ok0
	fail35:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ĩ e
		// ĩ
		if !_node(parser, _ĩNode, node, &pos) {
			goto fail37
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail37
		}
		goto ok0
	fail37:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ĩ o q
		// ĩ
		if !_node(parser, _ĩNode, node, &pos) {
			goto fail39
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail39
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail39
		}
		goto ok0
	fail39:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ĩ o
		// ĩ
		if !_node(parser, _ĩNode, node, &pos) {
			goto fail41
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail41
		}
		goto ok0
	fail41:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ĩ u
		// ĩ
		if !_node(parser, _ĩNode, node, &pos) {
			goto fail43
		}
		// u
		if !_node(parser, _uNode, node, &pos) {
			goto fail43
		}
		goto ok0
	fail43:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ĩ a q
		// ĩ
		if !_node(parser, _ĩNode, node, &pos) {
			goto fail45
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail45
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail45
		}
		goto ok0
	fail45:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ĩ a
		// ĩ
		if !_node(parser, _ĩNode, node, &pos) {
			goto fail47
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail47
		}
		goto ok0
	fail47:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ĩ q
		// ĩ
		if !_node(parser, _ĩNode, node, &pos) {
			goto fail49
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail49
		}
		goto ok0
	fail49:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ĩ
		if !_node(parser, _ĩNode, node, &pos) {
			goto fail51
		}
		goto ok0
	fail51:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// õ e q
		// õ
		if !_node(parser, _õNode, node, &pos) {
			goto fail52
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail52
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail52
		}
		goto ok0
	fail52:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// õ e
		// õ
		if !_node(parser, _õNode, node, &pos) {
			goto fail54
		}
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail54
		}
		goto ok0
	fail54:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// õ i
		// õ
		if !_node(parser, _õNode, node, &pos) {
			goto fail56
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail56
		}
		goto ok0
	fail56:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// õ a q
		// õ
		if !_node(parser, _õNode, node, &pos) {
			goto fail58
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail58
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail58
		}
		goto ok0
	fail58:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// õ a
		// õ
		if !_node(parser, _õNode, node, &pos) {
			goto fail60
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail60
		}
		goto ok0
	fail60:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// õ q
		// õ
		if !_node(parser, _õNode, node, &pos) {
			goto fail62
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail62
		}
		goto ok0
	fail62:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// õ
		if !_node(parser, _õNode, node, &pos) {
			goto fail64
		}
		goto ok0
	fail64:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ẽ o q
		// ẽ
		if !_node(parser, _ẽNode, node, &pos) {
			goto fail65
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail65
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail65
		}
		goto ok0
	fail65:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ẽ o
		// ẽ
		if !_node(parser, _ẽNode, node, &pos) {
			goto fail67
		}
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail67
		}
		goto ok0
	fail67:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ẽ i
		// ẽ
		if !_node(parser, _ẽNode, node, &pos) {
			goto fail69
		}
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail69
		}
		goto ok0
	fail69:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ẽ a q
		// ẽ
		if !_node(parser, _ẽNode, node, &pos) {
			goto fail71
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail71
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail71
		}
		goto ok0
	fail71:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ẽ a
		// ẽ
		if !_node(parser, _ẽNode, node, &pos) {
			goto fail73
		}
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail73
		}
		goto ok0
	fail73:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ẽ q
		// ẽ
		if !_node(parser, _ẽNode, node, &pos) {
			goto fail75
		}
		// q
		if !_node(parser, _qNode, node, &pos) {
			goto fail75
		}
		goto ok0
	fail75:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ẽ
		if !_node(parser, _ẽNode, node, &pos) {
			goto fail77
		}
		goto ok0
	fail77:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _desinence__ã__ũ__ĩ__õ__ẽFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _desinence__ã__ũ__ĩ__õ__ẽ, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "desinence__ã__ũ__ĩ__õ__ẽ",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _desinence__ã__ũ__ĩ__õ__ẽ}
	// ã o/ã i/ã q/ã/ũ a o/ũ a i/ũ e q/ũ e/ũ o q/ũ o/ũ i/ũ a q/ũ a/ũ q/ũ/ĩ a o/ĩ a i/ĩ e q/ĩ e/ĩ o q/ĩ o/ĩ u/ĩ a q/ĩ a/ĩ q/ĩ/õ e q/õ e/õ i/õ a q/õ a/õ q/õ/ẽ o q/ẽ o/ẽ i/ẽ a q/ẽ a/ẽ q/ẽ
	{
		pos2 := pos
		// ã o
		// ã
		if !_fail(parser, _ãFail, errPos, failure, &pos) {
			goto fail3
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// ã i
		// ã
		if !_fail(parser, _ãFail, errPos, failure, &pos) {
			goto fail5
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// ã q
		// ã
		if !_fail(parser, _ãFail, errPos, failure, &pos) {
			goto fail7
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// ã
		if !_fail(parser, _ãFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// ũ a o
		// ũ
		if !_fail(parser, _ũFail, errPos, failure, &pos) {
			goto fail10
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail10
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		// ũ a i
		// ũ
		if !_fail(parser, _ũFail, errPos, failure, &pos) {
			goto fail12
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail12
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail12
		}
		goto ok0
	fail12:
		pos = pos2
		// ũ e q
		// ũ
		if !_fail(parser, _ũFail, errPos, failure, &pos) {
			goto fail14
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail14
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail14
		}
		goto ok0
	fail14:
		pos = pos2
		// ũ e
		// ũ
		if !_fail(parser, _ũFail, errPos, failure, &pos) {
			goto fail16
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail16
		}
		goto ok0
	fail16:
		pos = pos2
		// ũ o q
		// ũ
		if !_fail(parser, _ũFail, errPos, failure, &pos) {
			goto fail18
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail18
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail18
		}
		goto ok0
	fail18:
		pos = pos2
		// ũ o
		// ũ
		if !_fail(parser, _ũFail, errPos, failure, &pos) {
			goto fail20
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail20
		}
		goto ok0
	fail20:
		pos = pos2
		// ũ i
		// ũ
		if !_fail(parser, _ũFail, errPos, failure, &pos) {
			goto fail22
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail22
		}
		goto ok0
	fail22:
		pos = pos2
		// ũ a q
		// ũ
		if !_fail(parser, _ũFail, errPos, failure, &pos) {
			goto fail24
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail24
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail24
		}
		goto ok0
	fail24:
		pos = pos2
		// ũ a
		// ũ
		if !_fail(parser, _ũFail, errPos, failure, &pos) {
			goto fail26
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail26
		}
		goto ok0
	fail26:
		pos = pos2
		// ũ q
		// ũ
		if !_fail(parser, _ũFail, errPos, failure, &pos) {
			goto fail28
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail28
		}
		goto ok0
	fail28:
		pos = pos2
		// ũ
		if !_fail(parser, _ũFail, errPos, failure, &pos) {
			goto fail30
		}
		goto ok0
	fail30:
		pos = pos2
		// ĩ a o
		// ĩ
		if !_fail(parser, _ĩFail, errPos, failure, &pos) {
			goto fail31
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail31
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail31
		}
		goto ok0
	fail31:
		pos = pos2
		// ĩ a i
		// ĩ
		if !_fail(parser, _ĩFail, errPos, failure, &pos) {
			goto fail33
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail33
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail33
		}
		goto ok0
	fail33:
		pos = pos2
		// ĩ e q
		// ĩ
		if !_fail(parser, _ĩFail, errPos, failure, &pos) {
			goto fail35
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail35
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail35
		}
		goto ok0
	fail35:
		pos = pos2
		// ĩ e
		// ĩ
		if !_fail(parser, _ĩFail, errPos, failure, &pos) {
			goto fail37
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail37
		}
		goto ok0
	fail37:
		pos = pos2
		// ĩ o q
		// ĩ
		if !_fail(parser, _ĩFail, errPos, failure, &pos) {
			goto fail39
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail39
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail39
		}
		goto ok0
	fail39:
		pos = pos2
		// ĩ o
		// ĩ
		if !_fail(parser, _ĩFail, errPos, failure, &pos) {
			goto fail41
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail41
		}
		goto ok0
	fail41:
		pos = pos2
		// ĩ u
		// ĩ
		if !_fail(parser, _ĩFail, errPos, failure, &pos) {
			goto fail43
		}
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail43
		}
		goto ok0
	fail43:
		pos = pos2
		// ĩ a q
		// ĩ
		if !_fail(parser, _ĩFail, errPos, failure, &pos) {
			goto fail45
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail45
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail45
		}
		goto ok0
	fail45:
		pos = pos2
		// ĩ a
		// ĩ
		if !_fail(parser, _ĩFail, errPos, failure, &pos) {
			goto fail47
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail47
		}
		goto ok0
	fail47:
		pos = pos2
		// ĩ q
		// ĩ
		if !_fail(parser, _ĩFail, errPos, failure, &pos) {
			goto fail49
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail49
		}
		goto ok0
	fail49:
		pos = pos2
		// ĩ
		if !_fail(parser, _ĩFail, errPos, failure, &pos) {
			goto fail51
		}
		goto ok0
	fail51:
		pos = pos2
		// õ e q
		// õ
		if !_fail(parser, _õFail, errPos, failure, &pos) {
			goto fail52
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail52
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail52
		}
		goto ok0
	fail52:
		pos = pos2
		// õ e
		// õ
		if !_fail(parser, _õFail, errPos, failure, &pos) {
			goto fail54
		}
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail54
		}
		goto ok0
	fail54:
		pos = pos2
		// õ i
		// õ
		if !_fail(parser, _õFail, errPos, failure, &pos) {
			goto fail56
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail56
		}
		goto ok0
	fail56:
		pos = pos2
		// õ a q
		// õ
		if !_fail(parser, _õFail, errPos, failure, &pos) {
			goto fail58
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail58
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail58
		}
		goto ok0
	fail58:
		pos = pos2
		// õ a
		// õ
		if !_fail(parser, _õFail, errPos, failure, &pos) {
			goto fail60
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail60
		}
		goto ok0
	fail60:
		pos = pos2
		// õ q
		// õ
		if !_fail(parser, _õFail, errPos, failure, &pos) {
			goto fail62
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail62
		}
		goto ok0
	fail62:
		pos = pos2
		// õ
		if !_fail(parser, _õFail, errPos, failure, &pos) {
			goto fail64
		}
		goto ok0
	fail64:
		pos = pos2
		// ẽ o q
		// ẽ
		if !_fail(parser, _ẽFail, errPos, failure, &pos) {
			goto fail65
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail65
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail65
		}
		goto ok0
	fail65:
		pos = pos2
		// ẽ o
		// ẽ
		if !_fail(parser, _ẽFail, errPos, failure, &pos) {
			goto fail67
		}
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail67
		}
		goto ok0
	fail67:
		pos = pos2
		// ẽ i
		// ẽ
		if !_fail(parser, _ẽFail, errPos, failure, &pos) {
			goto fail69
		}
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail69
		}
		goto ok0
	fail69:
		pos = pos2
		// ẽ a q
		// ẽ
		if !_fail(parser, _ẽFail, errPos, failure, &pos) {
			goto fail71
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail71
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail71
		}
		goto ok0
	fail71:
		pos = pos2
		// ẽ a
		// ẽ
		if !_fail(parser, _ẽFail, errPos, failure, &pos) {
			goto fail73
		}
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail73
		}
		goto ok0
	fail73:
		pos = pos2
		// ẽ q
		// ẽ
		if !_fail(parser, _ẽFail, errPos, failure, &pos) {
			goto fail75
		}
		// q
		if !_fail(parser, _qFail, errPos, failure, &pos) {
			goto fail75
		}
		goto ok0
	fail75:
		pos = pos2
		// ẽ
		if !_fail(parser, _ẽFail, errPos, failure, &pos) {
			goto fail77
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _desinence__ã__ũ__ĩ__õ__ẽAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_desinence__ã__ũ__ĩ__õ__ẽ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _desinence__ã__ũ__ĩ__õ__ẽ}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// ã o/ã i/ã q/ã/ũ a o/ũ a i/ũ e q/ũ e/ũ o q/ũ o/ũ i/ũ a q/ũ a/ũ q/ũ/ĩ a o/ĩ a i/ĩ e q/ĩ e/ĩ o q/ĩ o/ĩ u/ĩ a q/ĩ a/ĩ q/ĩ/õ e q/õ e/õ i/õ a q/õ a/õ q/õ/ẽ o q/ẽ o/ẽ i/ẽ a q/ẽ a/ẽ q/ẽ
	{
		pos2 := pos
		// ã o
		{
			var node4 string
			// ã
			if p, n := _ãAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail3
			} else {
				node4 = *n
				pos = p
			}
			node += node4
		}
		goto ok0
	fail3:
		pos = pos2
		// ã i
		{
			var node6 string
			// ã
			if p, n := _ãAction(parser, pos); n == nil {
				goto fail5
			} else {
				node6 = *n
				pos = p
			}
			node += node6
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail5
			} else {
				node6 = *n
				pos = p
			}
			node += node6
		}
		goto ok0
	fail5:
		pos = pos2
		// ã q
		{
			var node8 string
			// ã
			if p, n := _ãAction(parser, pos); n == nil {
				goto fail7
			} else {
				node8 = *n
				pos = p
			}
			node += node8
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail7
			} else {
				node8 = *n
				pos = p
			}
			node += node8
		}
		goto ok0
	fail7:
		pos = pos2
		// ã
		if p, n := _ãAction(parser, pos); n == nil {
			goto fail9
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail9:
		pos = pos2
		// ũ a o
		{
			var node11 string
			// ũ
			if p, n := _ũAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail10
			} else {
				node11 = *n
				pos = p
			}
			node += node11
		}
		goto ok0
	fail10:
		pos = pos2
		// ũ a i
		{
			var node13 string
			// ũ
			if p, n := _ũAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail12
			} else {
				node13 = *n
				pos = p
			}
			node += node13
		}
		goto ok0
	fail12:
		pos = pos2
		// ũ e q
		{
			var node15 string
			// ũ
			if p, n := _ũAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail14
			} else {
				node15 = *n
				pos = p
			}
			node += node15
		}
		goto ok0
	fail14:
		pos = pos2
		// ũ e
		{
			var node17 string
			// ũ
			if p, n := _ũAction(parser, pos); n == nil {
				goto fail16
			} else {
				node17 = *n
				pos = p
			}
			node += node17
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail16
			} else {
				node17 = *n
				pos = p
			}
			node += node17
		}
		goto ok0
	fail16:
		pos = pos2
		// ũ o q
		{
			var node19 string
			// ũ
			if p, n := _ũAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail18
			} else {
				node19 = *n
				pos = p
			}
			node += node19
		}
		goto ok0
	fail18:
		pos = pos2
		// ũ o
		{
			var node21 string
			// ũ
			if p, n := _ũAction(parser, pos); n == nil {
				goto fail20
			} else {
				node21 = *n
				pos = p
			}
			node += node21
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail20
			} else {
				node21 = *n
				pos = p
			}
			node += node21
		}
		goto ok0
	fail20:
		pos = pos2
		// ũ i
		{
			var node23 string
			// ũ
			if p, n := _ũAction(parser, pos); n == nil {
				goto fail22
			} else {
				node23 = *n
				pos = p
			}
			node += node23
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail22
			} else {
				node23 = *n
				pos = p
			}
			node += node23
		}
		goto ok0
	fail22:
		pos = pos2
		// ũ a q
		{
			var node25 string
			// ũ
			if p, n := _ũAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail24
			} else {
				node25 = *n
				pos = p
			}
			node += node25
		}
		goto ok0
	fail24:
		pos = pos2
		// ũ a
		{
			var node27 string
			// ũ
			if p, n := _ũAction(parser, pos); n == nil {
				goto fail26
			} else {
				node27 = *n
				pos = p
			}
			node += node27
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail26
			} else {
				node27 = *n
				pos = p
			}
			node += node27
		}
		goto ok0
	fail26:
		pos = pos2
		// ũ q
		{
			var node29 string
			// ũ
			if p, n := _ũAction(parser, pos); n == nil {
				goto fail28
			} else {
				node29 = *n
				pos = p
			}
			node += node29
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail28
			} else {
				node29 = *n
				pos = p
			}
			node += node29
		}
		goto ok0
	fail28:
		pos = pos2
		// ũ
		if p, n := _ũAction(parser, pos); n == nil {
			goto fail30
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail30:
		pos = pos2
		// ĩ a o
		{
			var node32 string
			// ĩ
			if p, n := _ĩAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail31
			} else {
				node32 = *n
				pos = p
			}
			node += node32
		}
		goto ok0
	fail31:
		pos = pos2
		// ĩ a i
		{
			var node34 string
			// ĩ
			if p, n := _ĩAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail33
			} else {
				node34 = *n
				pos = p
			}
			node += node34
		}
		goto ok0
	fail33:
		pos = pos2
		// ĩ e q
		{
			var node36 string
			// ĩ
			if p, n := _ĩAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail35
			} else {
				node36 = *n
				pos = p
			}
			node += node36
		}
		goto ok0
	fail35:
		pos = pos2
		// ĩ e
		{
			var node38 string
			// ĩ
			if p, n := _ĩAction(parser, pos); n == nil {
				goto fail37
			} else {
				node38 = *n
				pos = p
			}
			node += node38
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail37
			} else {
				node38 = *n
				pos = p
			}
			node += node38
		}
		goto ok0
	fail37:
		pos = pos2
		// ĩ o q
		{
			var node40 string
			// ĩ
			if p, n := _ĩAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail39
			} else {
				node40 = *n
				pos = p
			}
			node += node40
		}
		goto ok0
	fail39:
		pos = pos2
		// ĩ o
		{
			var node42 string
			// ĩ
			if p, n := _ĩAction(parser, pos); n == nil {
				goto fail41
			} else {
				node42 = *n
				pos = p
			}
			node += node42
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail41
			} else {
				node42 = *n
				pos = p
			}
			node += node42
		}
		goto ok0
	fail41:
		pos = pos2
		// ĩ u
		{
			var node44 string
			// ĩ
			if p, n := _ĩAction(parser, pos); n == nil {
				goto fail43
			} else {
				node44 = *n
				pos = p
			}
			node += node44
			// u
			if p, n := _uAction(parser, pos); n == nil {
				goto fail43
			} else {
				node44 = *n
				pos = p
			}
			node += node44
		}
		goto ok0
	fail43:
		pos = pos2
		// ĩ a q
		{
			var node46 string
			// ĩ
			if p, n := _ĩAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail45
			} else {
				node46 = *n
				pos = p
			}
			node += node46
		}
		goto ok0
	fail45:
		pos = pos2
		// ĩ a
		{
			var node48 string
			// ĩ
			if p, n := _ĩAction(parser, pos); n == nil {
				goto fail47
			} else {
				node48 = *n
				pos = p
			}
			node += node48
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail47
			} else {
				node48 = *n
				pos = p
			}
			node += node48
		}
		goto ok0
	fail47:
		pos = pos2
		// ĩ q
		{
			var node50 string
			// ĩ
			if p, n := _ĩAction(parser, pos); n == nil {
				goto fail49
			} else {
				node50 = *n
				pos = p
			}
			node += node50
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail49
			} else {
				node50 = *n
				pos = p
			}
			node += node50
		}
		goto ok0
	fail49:
		pos = pos2
		// ĩ
		if p, n := _ĩAction(parser, pos); n == nil {
			goto fail51
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail51:
		pos = pos2
		// õ e q
		{
			var node53 string
			// õ
			if p, n := _õAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail52
			} else {
				node53 = *n
				pos = p
			}
			node += node53
		}
		goto ok0
	fail52:
		pos = pos2
		// õ e
		{
			var node55 string
			// õ
			if p, n := _õAction(parser, pos); n == nil {
				goto fail54
			} else {
				node55 = *n
				pos = p
			}
			node += node55
			// e
			if p, n := _eAction(parser, pos); n == nil {
				goto fail54
			} else {
				node55 = *n
				pos = p
			}
			node += node55
		}
		goto ok0
	fail54:
		pos = pos2
		// õ i
		{
			var node57 string
			// õ
			if p, n := _õAction(parser, pos); n == nil {
				goto fail56
			} else {
				node57 = *n
				pos = p
			}
			node += node57
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail56
			} else {
				node57 = *n
				pos = p
			}
			node += node57
		}
		goto ok0
	fail56:
		pos = pos2
		// õ a q
		{
			var node59 string
			// õ
			if p, n := _õAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail58
			} else {
				node59 = *n
				pos = p
			}
			node += node59
		}
		goto ok0
	fail58:
		pos = pos2
		// õ a
		{
			var node61 string
			// õ
			if p, n := _õAction(parser, pos); n == nil {
				goto fail60
			} else {
				node61 = *n
				pos = p
			}
			node += node61
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail60
			} else {
				node61 = *n
				pos = p
			}
			node += node61
		}
		goto ok0
	fail60:
		pos = pos2
		// õ q
		{
			var node63 string
			// õ
			if p, n := _õAction(parser, pos); n == nil {
				goto fail62
			} else {
				node63 = *n
				pos = p
			}
			node += node63
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail62
			} else {
				node63 = *n
				pos = p
			}
			node += node63
		}
		goto ok0
	fail62:
		pos = pos2
		// õ
		if p, n := _õAction(parser, pos); n == nil {
			goto fail64
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail64:
		pos = pos2
		// ẽ o q
		{
			var node66 string
			// ẽ
			if p, n := _ẽAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail65
			} else {
				node66 = *n
				pos = p
			}
			node += node66
		}
		goto ok0
	fail65:
		pos = pos2
		// ẽ o
		{
			var node68 string
			// ẽ
			if p, n := _ẽAction(parser, pos); n == nil {
				goto fail67
			} else {
				node68 = *n
				pos = p
			}
			node += node68
			// o
			if p, n := _oAction(parser, pos); n == nil {
				goto fail67
			} else {
				node68 = *n
				pos = p
			}
			node += node68
		}
		goto ok0
	fail67:
		pos = pos2
		// ẽ i
		{
			var node70 string
			// ẽ
			if p, n := _ẽAction(parser, pos); n == nil {
				goto fail69
			} else {
				node70 = *n
				pos = p
			}
			node += node70
			// i
			if p, n := _iAction(parser, pos); n == nil {
				goto fail69
			} else {
				node70 = *n
				pos = p
			}
			node += node70
		}
		goto ok0
	fail69:
		pos = pos2
		// ẽ a q
		{
			var node72 string
			// ẽ
			if p, n := _ẽAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail71
			} else {
				node72 = *n
				pos = p
			}
			node += node72
		}
		goto ok0
	fail71:
		pos = pos2
		// ẽ a
		{
			var node74 string
			// ẽ
			if p, n := _ẽAction(parser, pos); n == nil {
				goto fail73
			} else {
				node74 = *n
				pos = p
			}
			node += node74
			// a
			if p, n := _aAction(parser, pos); n == nil {
				goto fail73
			} else {
				node74 = *n
				pos = p
			}
			node += node74
		}
		goto ok0
	fail73:
		pos = pos2
		// ẽ q
		{
			var node76 string
			// ẽ
			if p, n := _ẽAction(parser, pos); n == nil {
				goto fail75
			} else {
				node76 = *n
				pos = p
			}
			node += node76
			// q
			if p, n := _qAction(parser, pos); n == nil {
				goto fail75
			} else {
				node76 = *n
				pos = p
			}
			node += node76
		}
		goto ok0
	fail75:
		pos = pos2
		// ẽ
		if p, n := _ẽAction(parser, pos); n == nil {
			goto fail77
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail77:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _neutral_desinenceAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _neutral_desinence, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// desinence<a, u, i, o, e>
	if !_accept(parser, _desinence__a__u__i__o__eAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _neutral_desinence, start, pos, perr)
fail:
	return _memoize(parser, _neutral_desinence, start, -1, perr)
}

func _neutral_desinenceNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_neutral_desinence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _neutral_desinence}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "neutral_desinence"}
	// desinence<a, u, i, o, e>
	if !_node(parser, _desinence__a__u__i__o__eNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _neutral_desinenceFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _neutral_desinence, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "neutral_desinence",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _neutral_desinence}
	// desinence<a, u, i, o, e>
	if !_fail(parser, _desinence__a__u__i__o__eFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _neutral_desinenceAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_neutral_desinence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _neutral_desinence}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// desinence<a, u, i, o, e>
	if p, n := _desinence__a__u__i__o__eAction(parser, pos); n == nil {
		goto fail
	} else {
		node = *n
		pos = p
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _compound_desinenceAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _compound_desinence, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// desinence<ā, ū, ī, ō, ē>
	if !_accept(parser, _desinence__ā__ū__ī__ō__ēAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _compound_desinence, start, pos, perr)
fail:
	return _memoize(parser, _compound_desinence, start, -1, perr)
}

func _compound_desinenceNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_compound_desinence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _compound_desinence}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "compound_desinence"}
	// desinence<ā, ū, ī, ō, ē>
	if !_node(parser, _desinence__ā__ū__ī__ō__ēNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _compound_desinenceFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _compound_desinence, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "compound_desinence",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _compound_desinence}
	// desinence<ā, ū, ī, ō, ē>
	if !_fail(parser, _desinence__ā__ū__ī__ō__ēFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _compound_desinenceAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_compound_desinence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _compound_desinence}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// desinence<ā, ū, ī, ō, ē>
	if p, n := _desinence__ā__ū__ī__ō__ēAction(parser, pos); n == nil {
		goto fail
	} else {
		node = *n
		pos = p
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _arg_desinenceAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _arg_desinence, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// desinence<á, ú, í, ó, é>
	if !_accept(parser, _desinence__á__ú__í__ó__éAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _arg_desinence, start, pos, perr)
fail:
	return _memoize(parser, _arg_desinence, start, -1, perr)
}

func _arg_desinenceNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_arg_desinence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _arg_desinence}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "arg_desinence"}
	// desinence<á, ú, í, ó, é>
	if !_node(parser, _desinence__á__ú__í__ó__éNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _arg_desinenceFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _arg_desinence, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "arg_desinence",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _arg_desinence}
	// desinence<á, ú, í, ó, é>
	if !_fail(parser, _desinence__á__ú__í__ó__éFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _arg_desinenceAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_arg_desinence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _arg_desinence}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// desinence<á, ú, í, ó, é>
	if p, n := _desinence__á__ú__í__ó__éAction(parser, pos); n == nil {
		goto fail
	} else {
		node = *n
		pos = p
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _relative_desinenceAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _relative_desinence, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// desinence<ǎ, ǔ, ǐ, ǒ, ě>
	if !_accept(parser, _desinence__ǎ__ǔ__ǐ__ǒ__ěAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _relative_desinence, start, pos, perr)
fail:
	return _memoize(parser, _relative_desinence, start, -1, perr)
}

func _relative_desinenceNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_relative_desinence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_desinence}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "relative_desinence"}
	// desinence<ǎ, ǔ, ǐ, ǒ, ě>
	if !_node(parser, _desinence__ǎ__ǔ__ǐ__ǒ__ěNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _relative_desinenceFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _relative_desinence, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "relative_desinence",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _relative_desinence}
	// desinence<ǎ, ǔ, ǐ, ǒ, ě>
	if !_fail(parser, _desinence__ǎ__ǔ__ǐ__ǒ__ěFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _relative_desinenceAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_relative_desinence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_desinence}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// desinence<ǎ, ǔ, ǐ, ǒ, ě>
	if p, n := _desinence__ǎ__ǔ__ǐ__ǒ__ěAction(parser, pos); n == nil {
		goto fail
	} else {
		node = *n
		pos = p
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _verb_desinenceAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _verb_desinence, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// desinence<ả, ủ, ỉ, ỏ, ẻ>
	if !_accept(parser, _desinence__ả__ủ__ỉ__ỏ__ẻAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _verb_desinence, start, pos, perr)
fail:
	return _memoize(parser, _verb_desinence, start, -1, perr)
}

func _verb_desinenceNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_verb_desinence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _verb_desinence}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "verb_desinence"}
	// desinence<ả, ủ, ỉ, ỏ, ẻ>
	if !_node(parser, _desinence__ả__ủ__ỉ__ỏ__ẻNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _verb_desinenceFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _verb_desinence, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "verb_desinence",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _verb_desinence}
	// desinence<ả, ủ, ỉ, ỏ, ẻ>
	if !_fail(parser, _desinence__ả__ủ__ỉ__ỏ__ẻFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _verb_desinenceAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_verb_desinence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _verb_desinence}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// desinence<ả, ủ, ỉ, ỏ, ẻ>
	if p, n := _desinence__ả__ủ__ỉ__ỏ__ẻAction(parser, pos); n == nil {
		goto fail
	} else {
		node = *n
		pos = p
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _content_desinenceAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _content_desinence, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// desinence<â, û, î, ô, ê>
	if !_accept(parser, _desinence__â__û__î__ô__êAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _content_desinence, start, pos, perr)
fail:
	return _memoize(parser, _content_desinence, start, -1, perr)
}

func _content_desinenceNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_content_desinence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _content_desinence}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "content_desinence"}
	// desinence<â, û, î, ô, ê>
	if !_node(parser, _desinence__â__û__î__ô__êNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _content_desinenceFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _content_desinence, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "content_desinence",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _content_desinence}
	// desinence<â, û, î, ô, ê>
	if !_fail(parser, _desinence__â__û__î__ô__êFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _content_desinenceAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_content_desinence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _content_desinence}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// desinence<â, û, î, ô, ê>
	if p, n := _desinence__â__û__î__ô__êAction(parser, pos); n == nil {
		goto fail
	} else {
		node = *n
		pos = p
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _preposition_desinenceAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _preposition_desinence, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// desinence<à, ù, ì, ò, è>
	if !_accept(parser, _desinence__à__ù__ì__ò__èAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _preposition_desinence, start, pos, perr)
fail:
	return _memoize(parser, _preposition_desinence, start, -1, perr)
}

func _preposition_desinenceNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_preposition_desinence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _preposition_desinence}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "preposition_desinence"}
	// desinence<à, ù, ì, ò, è>
	if !_node(parser, _desinence__à__ù__ì__ò__èNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _preposition_desinenceFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _preposition_desinence, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "preposition_desinence",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _preposition_desinence}
	// desinence<à, ù, ì, ò, è>
	if !_fail(parser, _desinence__à__ù__ì__ò__èFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _preposition_desinenceAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_preposition_desinence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _preposition_desinence}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// desinence<à, ù, ì, ò, è>
	if p, n := _desinence__à__ù__ì__ò__èAction(parser, pos); n == nil {
		goto fail
	} else {
		node = *n
		pos = p
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _adverb_desinenceAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _adverb_desinence, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// desinence<ã, ũ, ĩ, õ, ẽ>
	if !_accept(parser, _desinence__ã__ũ__ĩ__õ__ẽAccepts, &pos, &perr) {
		goto fail
	}
	return _memoize(parser, _adverb_desinence, start, pos, perr)
fail:
	return _memoize(parser, _adverb_desinence, start, -1, perr)
}

func _adverb_desinenceNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_adverb_desinence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _adverb_desinence}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "adverb_desinence"}
	// desinence<ã, ũ, ĩ, õ, ẽ>
	if !_node(parser, _desinence__ã__ũ__ĩ__õ__ẽNode, node, &pos) {
		goto fail
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _adverb_desinenceFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _adverb_desinence, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "adverb_desinence",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _adverb_desinence}
	// desinence<ã, ũ, ĩ, õ, ẽ>
	if !_fail(parser, _desinence__ã__ũ__ĩ__õ__ẽFail, errPos, failure, &pos) {
		goto fail
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _adverb_desinenceAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_adverb_desinence]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _adverb_desinence}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// desinence<ã, ũ, ĩ, õ, ẽ>
	if p, n := _desinence__ã__ũ__ĩ__õ__ẽAction(parser, pos); n == nil {
		goto fail
	} else {
		node = *n
		pos = p
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// compound_tone/arg_tone/verb_tone/relative_tone/adverb_tone/preposition_tone/content_tone
	{
		pos2 := pos
		// compound_tone
		if !_accept(parser, _compound_toneAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// arg_tone
		if !_accept(parser, _arg_toneAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// verb_tone
		if !_accept(parser, _verb_toneAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// relative_tone
		if !_accept(parser, _relative_toneAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// adverb_tone
		if !_accept(parser, _adverb_toneAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// preposition_tone
		if !_accept(parser, _preposition_toneAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// content_tone
		if !_accept(parser, _content_toneAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _tone, start, pos, perr)
fail:
	return _memoize(parser, _tone, start, -1, perr)
}

func _toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "tone"}
	// compound_tone/arg_tone/verb_tone/relative_tone/adverb_tone/preposition_tone/content_tone
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// compound_tone
		if !_node(parser, _compound_toneNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// arg_tone
		if !_node(parser, _arg_toneNode, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// verb_tone
		if !_node(parser, _verb_toneNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// relative_tone
		if !_node(parser, _relative_toneNode, node, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// adverb_tone
		if !_node(parser, _adverb_toneNode, node, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// preposition_tone
		if !_node(parser, _preposition_toneNode, node, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// content_tone
		if !_node(parser, _content_toneNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _tone}
	// compound_tone/arg_tone/verb_tone/relative_tone/adverb_tone/preposition_tone/content_tone
	{
		pos2 := pos
		// compound_tone
		if !_fail(parser, _compound_toneFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// arg_tone
		if !_fail(parser, _arg_toneFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// verb_tone
		if !_fail(parser, _verb_toneFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// relative_tone
		if !_fail(parser, _relative_toneFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// adverb_tone
		if !_fail(parser, _adverb_toneFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// preposition_tone
		if !_fail(parser, _preposition_toneFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// content_tone
		if !_fail(parser, _content_toneFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// compound_tone/arg_tone/verb_tone/relative_tone/adverb_tone/preposition_tone/content_tone
	{
		pos2 := pos
		// compound_tone
		if p, n := _compound_toneAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// arg_tone
		if p, n := _arg_toneAction(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		// verb_tone
		if p, n := _verb_toneAction(parser, pos); n == nil {
			goto fail5
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail5:
		pos = pos2
		// relative_tone
		if p, n := _relative_toneAction(parser, pos); n == nil {
			goto fail6
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail6:
		pos = pos2
		// adverb_tone
		if p, n := _adverb_toneAction(parser, pos); n == nil {
			goto fail7
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail7:
		pos = pos2
		// preposition_tone
		if p, n := _preposition_toneAction(parser, pos); n == nil {
			goto fail8
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail8:
		pos = pos2
		// content_tone
		if p, n := _content_toneAction(parser, pos); n == nil {
			goto fail9
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail9:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _AAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _A, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// a/ā/á/ǎ/ả/â/à/ã
	{
		pos2 := pos
		// a
		if !_accept(parser, _aAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// ā
		if !_accept(parser, _āAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// á
		if !_accept(parser, _áAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// ǎ
		if !_accept(parser, _ǎAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// ả
		if !_accept(parser, _ảAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// â
		if !_accept(parser, _âAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// à
		if !_accept(parser, _àAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// ã
		if !_accept(parser, _ãAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _A, start, pos, perr)
fail:
	return _memoize(parser, _A, start, -1, perr)
}

func _ANode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_A]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _A}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "A"}
	// a/ā/á/ǎ/ả/â/à/ã
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// a
		if !_node(parser, _aNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ā
		if !_node(parser, _āNode, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// á
		if !_node(parser, _áNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǎ
		if !_node(parser, _ǎNode, node, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ả
		if !_node(parser, _ảNode, node, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// â
		if !_node(parser, _âNode, node, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// à
		if !_node(parser, _àNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ã
		if !_node(parser, _ãNode, node, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _AFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _A, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "A",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _A}
	// a/ā/á/ǎ/ả/â/à/ã
	{
		pos2 := pos
		// a
		if !_fail(parser, _aFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// ā
		if !_fail(parser, _āFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// á
		if !_fail(parser, _áFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// ǎ
		if !_fail(parser, _ǎFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// ả
		if !_fail(parser, _ảFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// â
		if !_fail(parser, _âFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// à
		if !_fail(parser, _àFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// ã
		if !_fail(parser, _ãFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _AAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_A]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _A}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// a/ā/á/ǎ/ả/â/à/ã
	{
		pos2 := pos
		// a
		if p, n := _aAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// ā
		if p, n := _āAction(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		// á
		if p, n := _áAction(parser, pos); n == nil {
			goto fail5
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail5:
		pos = pos2
		// ǎ
		if p, n := _ǎAction(parser, pos); n == nil {
			goto fail6
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail6:
		pos = pos2
		// ả
		if p, n := _ảAction(parser, pos); n == nil {
			goto fail7
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail7:
		pos = pos2
		// â
		if p, n := _âAction(parser, pos); n == nil {
			goto fail8
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail8:
		pos = pos2
		// à
		if p, n := _àAction(parser, pos); n == nil {
			goto fail9
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail9:
		pos = pos2
		// ã
		if p, n := _ãAction(parser, pos); n == nil {
			goto fail10
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _UAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _U, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// u/ū/ú/ǔ/ủ/û/ù/ũ
	{
		pos2 := pos
		// u
		if !_accept(parser, _uAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// ū
		if !_accept(parser, _ūAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// ú
		if !_accept(parser, _úAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// ǔ
		if !_accept(parser, _ǔAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// ủ
		if !_accept(parser, _ủAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// û
		if !_accept(parser, _ûAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// ù
		if !_accept(parser, _ùAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// ũ
		if !_accept(parser, _ũAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _U, start, pos, perr)
fail:
	return _memoize(parser, _U, start, -1, perr)
}

func _UNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_U]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _U}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "U"}
	// u/ū/ú/ǔ/ủ/û/ù/ũ
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// u
		if !_node(parser, _uNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ū
		if !_node(parser, _ūNode, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ú
		if !_node(parser, _úNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǔ
		if !_node(parser, _ǔNode, node, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ủ
		if !_node(parser, _ủNode, node, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// û
		if !_node(parser, _ûNode, node, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ù
		if !_node(parser, _ùNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ũ
		if !_node(parser, _ũNode, node, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _UFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _U, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "U",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _U}
	// u/ū/ú/ǔ/ủ/û/ù/ũ
	{
		pos2 := pos
		// u
		if !_fail(parser, _uFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// ū
		if !_fail(parser, _ūFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// ú
		if !_fail(parser, _úFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// ǔ
		if !_fail(parser, _ǔFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// ủ
		if !_fail(parser, _ủFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// û
		if !_fail(parser, _ûFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// ù
		if !_fail(parser, _ùFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// ũ
		if !_fail(parser, _ũFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _UAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_U]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _U}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// u/ū/ú/ǔ/ủ/û/ù/ũ
	{
		pos2 := pos
		// u
		if p, n := _uAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// ū
		if p, n := _ūAction(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		// ú
		if p, n := _úAction(parser, pos); n == nil {
			goto fail5
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail5:
		pos = pos2
		// ǔ
		if p, n := _ǔAction(parser, pos); n == nil {
			goto fail6
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail6:
		pos = pos2
		// ủ
		if p, n := _ủAction(parser, pos); n == nil {
			goto fail7
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail7:
		pos = pos2
		// û
		if p, n := _ûAction(parser, pos); n == nil {
			goto fail8
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail8:
		pos = pos2
		// ù
		if p, n := _ùAction(parser, pos); n == nil {
			goto fail9
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail9:
		pos = pos2
		// ũ
		if p, n := _ũAction(parser, pos); n == nil {
			goto fail10
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _IAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _I, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// i/ī/í/ǐ/ỉ/î/ì/ĩ
	{
		pos2 := pos
		// i
		if !_accept(parser, _iAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// ī
		if !_accept(parser, _īAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// í
		if !_accept(parser, _íAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// ǐ
		if !_accept(parser, _ǐAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// ỉ
		if !_accept(parser, _ỉAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// î
		if !_accept(parser, _îAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// ì
		if !_accept(parser, _ìAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// ĩ
		if !_accept(parser, _ĩAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _I, start, pos, perr)
fail:
	return _memoize(parser, _I, start, -1, perr)
}

func _INode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_I]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _I}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "I"}
	// i/ī/í/ǐ/ỉ/î/ì/ĩ
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// i
		if !_node(parser, _iNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ī
		if !_node(parser, _īNode, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// í
		if !_node(parser, _íNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǐ
		if !_node(parser, _ǐNode, node, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ỉ
		if !_node(parser, _ỉNode, node, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// î
		if !_node(parser, _îNode, node, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ì
		if !_node(parser, _ìNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ĩ
		if !_node(parser, _ĩNode, node, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _IFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _I, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "I",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _I}
	// i/ī/í/ǐ/ỉ/î/ì/ĩ
	{
		pos2 := pos
		// i
		if !_fail(parser, _iFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// ī
		if !_fail(parser, _īFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// í
		if !_fail(parser, _íFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// ǐ
		if !_fail(parser, _ǐFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// ỉ
		if !_fail(parser, _ỉFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// î
		if !_fail(parser, _îFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// ì
		if !_fail(parser, _ìFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// ĩ
		if !_fail(parser, _ĩFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _IAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_I]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _I}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// i/ī/í/ǐ/ỉ/î/ì/ĩ
	{
		pos2 := pos
		// i
		if p, n := _iAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// ī
		if p, n := _īAction(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		// í
		if p, n := _íAction(parser, pos); n == nil {
			goto fail5
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail5:
		pos = pos2
		// ǐ
		if p, n := _ǐAction(parser, pos); n == nil {
			goto fail6
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail6:
		pos = pos2
		// ỉ
		if p, n := _ỉAction(parser, pos); n == nil {
			goto fail7
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail7:
		pos = pos2
		// î
		if p, n := _îAction(parser, pos); n == nil {
			goto fail8
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail8:
		pos = pos2
		// ì
		if p, n := _ìAction(parser, pos); n == nil {
			goto fail9
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail9:
		pos = pos2
		// ĩ
		if p, n := _ĩAction(parser, pos); n == nil {
			goto fail10
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _OAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _O, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// o/ō/ó/ǒ/ỏ/ô/ò/õ
	{
		pos2 := pos
		// o
		if !_accept(parser, _oAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// ō
		if !_accept(parser, _ōAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// ó
		if !_accept(parser, _óAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// ǒ
		if !_accept(parser, _ǒAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// ỏ
		if !_accept(parser, _ỏAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// ô
		if !_accept(parser, _ôAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// ò
		if !_accept(parser, _òAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// õ
		if !_accept(parser, _õAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _O, start, pos, perr)
fail:
	return _memoize(parser, _O, start, -1, perr)
}

func _ONode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_O]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _O}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "O"}
	// o/ō/ó/ǒ/ỏ/ô/ò/õ
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// o
		if !_node(parser, _oNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ō
		if !_node(parser, _ōNode, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ó
		if !_node(parser, _óNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ǒ
		if !_node(parser, _ǒNode, node, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ỏ
		if !_node(parser, _ỏNode, node, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ô
		if !_node(parser, _ôNode, node, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ò
		if !_node(parser, _òNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// õ
		if !_node(parser, _õNode, node, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _OFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _O, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "O",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _O}
	// o/ō/ó/ǒ/ỏ/ô/ò/õ
	{
		pos2 := pos
		// o
		if !_fail(parser, _oFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// ō
		if !_fail(parser, _ōFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// ó
		if !_fail(parser, _óFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// ǒ
		if !_fail(parser, _ǒFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// ỏ
		if !_fail(parser, _ỏFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// ô
		if !_fail(parser, _ôFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// ò
		if !_fail(parser, _òFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// õ
		if !_fail(parser, _õFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _OAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_O]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _O}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// o/ō/ó/ǒ/ỏ/ô/ò/õ
	{
		pos2 := pos
		// o
		if p, n := _oAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// ō
		if p, n := _ōAction(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		// ó
		if p, n := _óAction(parser, pos); n == nil {
			goto fail5
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail5:
		pos = pos2
		// ǒ
		if p, n := _ǒAction(parser, pos); n == nil {
			goto fail6
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail6:
		pos = pos2
		// ỏ
		if p, n := _ỏAction(parser, pos); n == nil {
			goto fail7
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail7:
		pos = pos2
		// ô
		if p, n := _ôAction(parser, pos); n == nil {
			goto fail8
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail8:
		pos = pos2
		// ò
		if p, n := _òAction(parser, pos); n == nil {
			goto fail9
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail9:
		pos = pos2
		// õ
		if p, n := _õAction(parser, pos); n == nil {
			goto fail10
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _EAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _E, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// e/ē/é/ě/ẻ/ê/è/ẽ
	{
		pos2 := pos
		// e
		if !_accept(parser, _eAccepts, &pos, &perr) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// ē
		if !_accept(parser, _ēAccepts, &pos, &perr) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// é
		if !_accept(parser, _éAccepts, &pos, &perr) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// ě
		if !_accept(parser, _ěAccepts, &pos, &perr) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// ẻ
		if !_accept(parser, _ẻAccepts, &pos, &perr) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// ê
		if !_accept(parser, _êAccepts, &pos, &perr) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// è
		if !_accept(parser, _èAccepts, &pos, &perr) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// ẽ
		if !_accept(parser, _ẽAccepts, &pos, &perr) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _E, start, pos, perr)
fail:
	return _memoize(parser, _E, start, -1, perr)
}

func _ENode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_E]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _E}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "E"}
	// e/ē/é/ě/ẻ/ê/è/ẽ
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// e
		if !_node(parser, _eNode, node, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ē
		if !_node(parser, _ēNode, node, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// é
		if !_node(parser, _éNode, node, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ě
		if !_node(parser, _ěNode, node, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ẻ
		if !_node(parser, _ẻNode, node, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ê
		if !_node(parser, _êNode, node, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// è
		if !_node(parser, _èNode, node, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// ẽ
		if !_node(parser, _ẽNode, node, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _EFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _E, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "E",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _E}
	// e/ē/é/ě/ẻ/ê/è/ẽ
	{
		pos2 := pos
		// e
		if !_fail(parser, _eFail, errPos, failure, &pos) {
			goto fail3
		}
		goto ok0
	fail3:
		pos = pos2
		// ē
		if !_fail(parser, _ēFail, errPos, failure, &pos) {
			goto fail4
		}
		goto ok0
	fail4:
		pos = pos2
		// é
		if !_fail(parser, _éFail, errPos, failure, &pos) {
			goto fail5
		}
		goto ok0
	fail5:
		pos = pos2
		// ě
		if !_fail(parser, _ěFail, errPos, failure, &pos) {
			goto fail6
		}
		goto ok0
	fail6:
		pos = pos2
		// ẻ
		if !_fail(parser, _ẻFail, errPos, failure, &pos) {
			goto fail7
		}
		goto ok0
	fail7:
		pos = pos2
		// ê
		if !_fail(parser, _êFail, errPos, failure, &pos) {
			goto fail8
		}
		goto ok0
	fail8:
		pos = pos2
		// è
		if !_fail(parser, _èFail, errPos, failure, &pos) {
			goto fail9
		}
		goto ok0
	fail9:
		pos = pos2
		// ẽ
		if !_fail(parser, _ẽFail, errPos, failure, &pos) {
			goto fail10
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _EAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_E]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _E}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// e/ē/é/ě/ẻ/ê/è/ẽ
	{
		pos2 := pos
		// e
		if p, n := _eAction(parser, pos); n == nil {
			goto fail3
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail3:
		pos = pos2
		// ē
		if p, n := _ēAction(parser, pos); n == nil {
			goto fail4
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail4:
		pos = pos2
		// é
		if p, n := _éAction(parser, pos); n == nil {
			goto fail5
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail5:
		pos = pos2
		// ě
		if p, n := _ěAction(parser, pos); n == nil {
			goto fail6
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail6:
		pos = pos2
		// ẻ
		if p, n := _ẻAction(parser, pos); n == nil {
			goto fail7
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail7:
		pos = pos2
		// ê
		if p, n := _êAction(parser, pos); n == nil {
			goto fail8
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail8:
		pos = pos2
		// è
		if p, n := _èAction(parser, pos); n == nil {
			goto fail9
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail9:
		pos = pos2
		// ẽ
		if p, n := _ẽAction(parser, pos); n == nil {
			goto fail10
		} else {
			node = *n
			pos = p
		}
		goto ok0
	fail10:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _āAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ā, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [āĀ]/[aA] (macron_combiner/compound_tone)
	{
		pos2 := pos
		// [āĀ]
		if r, w := _next(parser, pos); r != 'ā' && r != 'Ā' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (macron_combiner/compound_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (macron_combiner/compound_tone)
		// macron_combiner/compound_tone
		{
			pos8 := pos
			// macron_combiner
			if !_accept(parser, _macron_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// compound_tone
			if !_accept(parser, _compound_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ā, start, pos, perr)
fail:
	return _memoize(parser, _ā, start, -1, perr)
}

func _āNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ā]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ā}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ā"}
	// [āĀ]/[aA] (macron_combiner/compound_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [āĀ]
		if r, w := _next(parser, pos); r != 'ā' && r != 'Ā' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [aA] (macron_combiner/compound_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (macron_combiner/compound_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// macron_combiner/compound_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// macron_combiner
				if !_node(parser, _macron_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// compound_tone
				if !_node(parser, _compound_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _āFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ā, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ā",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ā}
	// [āĀ]/[aA] (macron_combiner/compound_tone)
	{
		pos2 := pos
		// [āĀ]
		if r, w := _next(parser, pos); r != 'ā' && r != 'Ā' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[āĀ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (macron_combiner/compound_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[aA]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (macron_combiner/compound_tone)
		// macron_combiner/compound_tone
		{
			pos8 := pos
			// macron_combiner
			if !_fail(parser, _macron_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// compound_tone
			if !_fail(parser, _compound_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _āAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ā]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ā}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [āĀ]/[aA] (macron_combiner/compound_tone)
	{
		pos2 := pos
		// [āĀ]
		if r, w := _next(parser, pos); r != 'ā' && r != 'Ā' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (macron_combiner/compound_tone)
		{
			var node5 string
			// [aA]
			if r, w := _next(parser, pos); r != 'a' && r != 'A' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (macron_combiner/compound_tone)
			// macron_combiner/compound_tone
			{
				pos8 := pos
				// macron_combiner
				if p, n := _macron_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// compound_tone
				if p, n := _compound_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ūAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ū, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ūŪ]/[uU] (macron_combiner/compound_tone)
	{
		pos2 := pos
		// [ūŪ]
		if r, w := _next(parser, pos); r != 'ū' && r != 'Ū' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (macron_combiner/compound_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (macron_combiner/compound_tone)
		// macron_combiner/compound_tone
		{
			pos8 := pos
			// macron_combiner
			if !_accept(parser, _macron_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// compound_tone
			if !_accept(parser, _compound_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ū, start, pos, perr)
fail:
	return _memoize(parser, _ū, start, -1, perr)
}

func _ūNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ū]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ū}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ū"}
	// [ūŪ]/[uU] (macron_combiner/compound_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ūŪ]
		if r, w := _next(parser, pos); r != 'ū' && r != 'Ū' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [uU] (macron_combiner/compound_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (macron_combiner/compound_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// macron_combiner/compound_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// macron_combiner
				if !_node(parser, _macron_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// compound_tone
				if !_node(parser, _compound_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ūFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ū, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ū",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ū}
	// [ūŪ]/[uU] (macron_combiner/compound_tone)
	{
		pos2 := pos
		// [ūŪ]
		if r, w := _next(parser, pos); r != 'ū' && r != 'Ū' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ūŪ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (macron_combiner/compound_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[uU]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (macron_combiner/compound_tone)
		// macron_combiner/compound_tone
		{
			pos8 := pos
			// macron_combiner
			if !_fail(parser, _macron_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// compound_tone
			if !_fail(parser, _compound_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ūAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ū]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ū}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ūŪ]/[uU] (macron_combiner/compound_tone)
	{
		pos2 := pos
		// [ūŪ]
		if r, w := _next(parser, pos); r != 'ū' && r != 'Ū' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (macron_combiner/compound_tone)
		{
			var node5 string
			// [uU]
			if r, w := _next(parser, pos); r != 'u' && r != 'U' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (macron_combiner/compound_tone)
			// macron_combiner/compound_tone
			{
				pos8 := pos
				// macron_combiner
				if p, n := _macron_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// compound_tone
				if p, n := _compound_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _īAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ī, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [īĪ]/[iI] (macron_combiner/compound_tone)
	{
		pos2 := pos
		// [īĪ]
		if r, w := _next(parser, pos); r != 'ī' && r != 'Ī' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (macron_combiner/compound_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (macron_combiner/compound_tone)
		// macron_combiner/compound_tone
		{
			pos8 := pos
			// macron_combiner
			if !_accept(parser, _macron_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// compound_tone
			if !_accept(parser, _compound_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ī, start, pos, perr)
fail:
	return _memoize(parser, _ī, start, -1, perr)
}

func _īNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ī]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ī}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ī"}
	// [īĪ]/[iI] (macron_combiner/compound_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [īĪ]
		if r, w := _next(parser, pos); r != 'ī' && r != 'Ī' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [iI] (macron_combiner/compound_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (macron_combiner/compound_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// macron_combiner/compound_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// macron_combiner
				if !_node(parser, _macron_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// compound_tone
				if !_node(parser, _compound_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _īFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ī, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ī",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ī}
	// [īĪ]/[iI] (macron_combiner/compound_tone)
	{
		pos2 := pos
		// [īĪ]
		if r, w := _next(parser, pos); r != 'ī' && r != 'Ī' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[īĪ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (macron_combiner/compound_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[iI]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (macron_combiner/compound_tone)
		// macron_combiner/compound_tone
		{
			pos8 := pos
			// macron_combiner
			if !_fail(parser, _macron_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// compound_tone
			if !_fail(parser, _compound_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _īAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ī]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ī}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [īĪ]/[iI] (macron_combiner/compound_tone)
	{
		pos2 := pos
		// [īĪ]
		if r, w := _next(parser, pos); r != 'ī' && r != 'Ī' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (macron_combiner/compound_tone)
		{
			var node5 string
			// [iI]
			if r, w := _next(parser, pos); r != 'i' && r != 'I' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (macron_combiner/compound_tone)
			// macron_combiner/compound_tone
			{
				pos8 := pos
				// macron_combiner
				if p, n := _macron_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// compound_tone
				if p, n := _compound_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ōAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ō, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ōŌ]/[oO] (macron_combiner/compound_tone)
	{
		pos2 := pos
		// [ōŌ]
		if r, w := _next(parser, pos); r != 'ō' && r != 'Ō' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (macron_combiner/compound_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (macron_combiner/compound_tone)
		// macron_combiner/compound_tone
		{
			pos8 := pos
			// macron_combiner
			if !_accept(parser, _macron_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// compound_tone
			if !_accept(parser, _compound_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ō, start, pos, perr)
fail:
	return _memoize(parser, _ō, start, -1, perr)
}

func _ōNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ō]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ō}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ō"}
	// [ōŌ]/[oO] (macron_combiner/compound_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ōŌ]
		if r, w := _next(parser, pos); r != 'ō' && r != 'Ō' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [oO] (macron_combiner/compound_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (macron_combiner/compound_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// macron_combiner/compound_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// macron_combiner
				if !_node(parser, _macron_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// compound_tone
				if !_node(parser, _compound_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ōFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ō, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ō",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ō}
	// [ōŌ]/[oO] (macron_combiner/compound_tone)
	{
		pos2 := pos
		// [ōŌ]
		if r, w := _next(parser, pos); r != 'ō' && r != 'Ō' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ōŌ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (macron_combiner/compound_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[oO]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (macron_combiner/compound_tone)
		// macron_combiner/compound_tone
		{
			pos8 := pos
			// macron_combiner
			if !_fail(parser, _macron_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// compound_tone
			if !_fail(parser, _compound_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ōAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ō]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ō}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ōŌ]/[oO] (macron_combiner/compound_tone)
	{
		pos2 := pos
		// [ōŌ]
		if r, w := _next(parser, pos); r != 'ō' && r != 'Ō' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (macron_combiner/compound_tone)
		{
			var node5 string
			// [oO]
			if r, w := _next(parser, pos); r != 'o' && r != 'O' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (macron_combiner/compound_tone)
			// macron_combiner/compound_tone
			{
				pos8 := pos
				// macron_combiner
				if p, n := _macron_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// compound_tone
				if p, n := _compound_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ēAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ē, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ēĒ]/[eE] (macron_combiner/compound_tone)
	{
		pos2 := pos
		// [ēĒ]
		if r, w := _next(parser, pos); r != 'ē' && r != 'Ē' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (macron_combiner/compound_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (macron_combiner/compound_tone)
		// macron_combiner/compound_tone
		{
			pos8 := pos
			// macron_combiner
			if !_accept(parser, _macron_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// compound_tone
			if !_accept(parser, _compound_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ē, start, pos, perr)
fail:
	return _memoize(parser, _ē, start, -1, perr)
}

func _ēNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ē]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ē}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ē"}
	// [ēĒ]/[eE] (macron_combiner/compound_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ēĒ]
		if r, w := _next(parser, pos); r != 'ē' && r != 'Ē' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [eE] (macron_combiner/compound_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (macron_combiner/compound_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// macron_combiner/compound_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// macron_combiner
				if !_node(parser, _macron_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// compound_tone
				if !_node(parser, _compound_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ēFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ē, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ē",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ē}
	// [ēĒ]/[eE] (macron_combiner/compound_tone)
	{
		pos2 := pos
		// [ēĒ]
		if r, w := _next(parser, pos); r != 'ē' && r != 'Ē' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ēĒ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (macron_combiner/compound_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[eE]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (macron_combiner/compound_tone)
		// macron_combiner/compound_tone
		{
			pos8 := pos
			// macron_combiner
			if !_fail(parser, _macron_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// compound_tone
			if !_fail(parser, _compound_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ēAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ē]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ē}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ēĒ]/[eE] (macron_combiner/compound_tone)
	{
		pos2 := pos
		// [ēĒ]
		if r, w := _next(parser, pos); r != 'ē' && r != 'Ē' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (macron_combiner/compound_tone)
		{
			var node5 string
			// [eE]
			if r, w := _next(parser, pos); r != 'e' && r != 'E' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (macron_combiner/compound_tone)
			// macron_combiner/compound_tone
			{
				pos8 := pos
				// macron_combiner
				if p, n := _macron_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// compound_tone
				if p, n := _compound_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _macron_combinerAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _macron_combiner, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// "̄"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̄" {
		perr = _max(perr, pos)
		goto fail
	}
	pos += 2
	perr = start
	return _memoize(parser, _macron_combiner, start, pos, perr)
fail:
	return _memoize(parser, _macron_combiner, start, -1, perr)
}

func _macron_combinerNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_macron_combiner]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _macron_combiner}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "macron_combiner"}
	// "̄"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̄" {
		goto fail
	}
	node.Kids = append(node.Kids, _leaf(parser, pos, pos+2))
	pos += 2
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _macron_combinerFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _macron_combiner, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "macron_combiner",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _macron_combiner}
	// "̄"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̄" {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "\"̄\"",
			})
		}
		goto fail
	}
	pos += 2
	failure.Kids = nil
	parser.fail[key] = failure
	return pos, failure
fail:
	failure.Kids = nil
	failure.Want = "◌̄"
	parser.fail[key] = failure
	return -1, failure
}

func _macron_combinerAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_macron_combiner]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _macron_combiner}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// "̄"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̄" {
		goto fail
	}
	node = parser.text[pos : pos+2]
	pos += 2
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _compound_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _compound_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [\-1]
	if r, w := _next(parser, pos); r != '-' && r != '1' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _compound_tone, start, pos, perr)
fail:
	return _memoize(parser, _compound_tone, start, -1, perr)
}

func _compound_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_compound_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _compound_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "compound_tone"}
	// [\-1]
	if r, w := _next(parser, pos); r != '-' && r != '1' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _compound_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _compound_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "compound_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _compound_tone}
	// [\-1]
	if r, w := _next(parser, pos); r != '-' && r != '1' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[\\-1]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _compound_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_compound_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _compound_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [\-1]
	if r, w := _next(parser, pos); r != '-' && r != '1' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _áAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _á, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [áÁ]/[aA] (acute_combiner/arg_tone)
	{
		pos2 := pos
		// [áÁ]
		if r, w := _next(parser, pos); r != 'á' && r != 'Á' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (acute_combiner/arg_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (acute_combiner/arg_tone)
		// acute_combiner/arg_tone
		{
			pos8 := pos
			// acute_combiner
			if !_accept(parser, _acute_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// arg_tone
			if !_accept(parser, _arg_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _á, start, pos, perr)
fail:
	return _memoize(parser, _á, start, -1, perr)
}

func _áNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_á]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _á}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "á"}
	// [áÁ]/[aA] (acute_combiner/arg_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [áÁ]
		if r, w := _next(parser, pos); r != 'á' && r != 'Á' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [aA] (acute_combiner/arg_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (acute_combiner/arg_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// acute_combiner/arg_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// acute_combiner
				if !_node(parser, _acute_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// arg_tone
				if !_node(parser, _arg_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _áFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _á, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "á",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _á}
	// [áÁ]/[aA] (acute_combiner/arg_tone)
	{
		pos2 := pos
		// [áÁ]
		if r, w := _next(parser, pos); r != 'á' && r != 'Á' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[áÁ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (acute_combiner/arg_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[aA]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (acute_combiner/arg_tone)
		// acute_combiner/arg_tone
		{
			pos8 := pos
			// acute_combiner
			if !_fail(parser, _acute_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// arg_tone
			if !_fail(parser, _arg_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _áAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_á]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _á}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [áÁ]/[aA] (acute_combiner/arg_tone)
	{
		pos2 := pos
		// [áÁ]
		if r, w := _next(parser, pos); r != 'á' && r != 'Á' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (acute_combiner/arg_tone)
		{
			var node5 string
			// [aA]
			if r, w := _next(parser, pos); r != 'a' && r != 'A' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (acute_combiner/arg_tone)
			// acute_combiner/arg_tone
			{
				pos8 := pos
				// acute_combiner
				if p, n := _acute_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// arg_tone
				if p, n := _arg_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _úAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ú, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [úÚ]/[uU] (acute_combiner/arg_tone)
	{
		pos2 := pos
		// [úÚ]
		if r, w := _next(parser, pos); r != 'ú' && r != 'Ú' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (acute_combiner/arg_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (acute_combiner/arg_tone)
		// acute_combiner/arg_tone
		{
			pos8 := pos
			// acute_combiner
			if !_accept(parser, _acute_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// arg_tone
			if !_accept(parser, _arg_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ú, start, pos, perr)
fail:
	return _memoize(parser, _ú, start, -1, perr)
}

func _úNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ú]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ú}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ú"}
	// [úÚ]/[uU] (acute_combiner/arg_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [úÚ]
		if r, w := _next(parser, pos); r != 'ú' && r != 'Ú' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [uU] (acute_combiner/arg_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (acute_combiner/arg_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// acute_combiner/arg_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// acute_combiner
				if !_node(parser, _acute_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// arg_tone
				if !_node(parser, _arg_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _úFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ú, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ú",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ú}
	// [úÚ]/[uU] (acute_combiner/arg_tone)
	{
		pos2 := pos
		// [úÚ]
		if r, w := _next(parser, pos); r != 'ú' && r != 'Ú' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[úÚ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (acute_combiner/arg_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[uU]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (acute_combiner/arg_tone)
		// acute_combiner/arg_tone
		{
			pos8 := pos
			// acute_combiner
			if !_fail(parser, _acute_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// arg_tone
			if !_fail(parser, _arg_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _úAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ú]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ú}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [úÚ]/[uU] (acute_combiner/arg_tone)
	{
		pos2 := pos
		// [úÚ]
		if r, w := _next(parser, pos); r != 'ú' && r != 'Ú' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (acute_combiner/arg_tone)
		{
			var node5 string
			// [uU]
			if r, w := _next(parser, pos); r != 'u' && r != 'U' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (acute_combiner/arg_tone)
			// acute_combiner/arg_tone
			{
				pos8 := pos
				// acute_combiner
				if p, n := _acute_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// arg_tone
				if p, n := _arg_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _íAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _í, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [íÍ]/[iI] (acute_combiner/arg_tone)
	{
		pos2 := pos
		// [íÍ]
		if r, w := _next(parser, pos); r != 'í' && r != 'Í' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (acute_combiner/arg_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (acute_combiner/arg_tone)
		// acute_combiner/arg_tone
		{
			pos8 := pos
			// acute_combiner
			if !_accept(parser, _acute_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// arg_tone
			if !_accept(parser, _arg_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _í, start, pos, perr)
fail:
	return _memoize(parser, _í, start, -1, perr)
}

func _íNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_í]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _í}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "í"}
	// [íÍ]/[iI] (acute_combiner/arg_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [íÍ]
		if r, w := _next(parser, pos); r != 'í' && r != 'Í' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [iI] (acute_combiner/arg_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (acute_combiner/arg_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// acute_combiner/arg_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// acute_combiner
				if !_node(parser, _acute_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// arg_tone
				if !_node(parser, _arg_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _íFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _í, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "í",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _í}
	// [íÍ]/[iI] (acute_combiner/arg_tone)
	{
		pos2 := pos
		// [íÍ]
		if r, w := _next(parser, pos); r != 'í' && r != 'Í' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[íÍ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (acute_combiner/arg_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[iI]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (acute_combiner/arg_tone)
		// acute_combiner/arg_tone
		{
			pos8 := pos
			// acute_combiner
			if !_fail(parser, _acute_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// arg_tone
			if !_fail(parser, _arg_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _íAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_í]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _í}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [íÍ]/[iI] (acute_combiner/arg_tone)
	{
		pos2 := pos
		// [íÍ]
		if r, w := _next(parser, pos); r != 'í' && r != 'Í' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (acute_combiner/arg_tone)
		{
			var node5 string
			// [iI]
			if r, w := _next(parser, pos); r != 'i' && r != 'I' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (acute_combiner/arg_tone)
			// acute_combiner/arg_tone
			{
				pos8 := pos
				// acute_combiner
				if p, n := _acute_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// arg_tone
				if p, n := _arg_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _óAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ó, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [óÓ]/[oO] (acute_combiner/arg_tone)
	{
		pos2 := pos
		// [óÓ]
		if r, w := _next(parser, pos); r != 'ó' && r != 'Ó' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (acute_combiner/arg_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (acute_combiner/arg_tone)
		// acute_combiner/arg_tone
		{
			pos8 := pos
			// acute_combiner
			if !_accept(parser, _acute_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// arg_tone
			if !_accept(parser, _arg_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ó, start, pos, perr)
fail:
	return _memoize(parser, _ó, start, -1, perr)
}

func _óNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ó]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ó}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ó"}
	// [óÓ]/[oO] (acute_combiner/arg_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [óÓ]
		if r, w := _next(parser, pos); r != 'ó' && r != 'Ó' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [oO] (acute_combiner/arg_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (acute_combiner/arg_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// acute_combiner/arg_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// acute_combiner
				if !_node(parser, _acute_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// arg_tone
				if !_node(parser, _arg_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _óFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ó, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ó",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ó}
	// [óÓ]/[oO] (acute_combiner/arg_tone)
	{
		pos2 := pos
		// [óÓ]
		if r, w := _next(parser, pos); r != 'ó' && r != 'Ó' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[óÓ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (acute_combiner/arg_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[oO]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (acute_combiner/arg_tone)
		// acute_combiner/arg_tone
		{
			pos8 := pos
			// acute_combiner
			if !_fail(parser, _acute_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// arg_tone
			if !_fail(parser, _arg_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _óAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ó]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ó}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [óÓ]/[oO] (acute_combiner/arg_tone)
	{
		pos2 := pos
		// [óÓ]
		if r, w := _next(parser, pos); r != 'ó' && r != 'Ó' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (acute_combiner/arg_tone)
		{
			var node5 string
			// [oO]
			if r, w := _next(parser, pos); r != 'o' && r != 'O' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (acute_combiner/arg_tone)
			// acute_combiner/arg_tone
			{
				pos8 := pos
				// acute_combiner
				if p, n := _acute_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// arg_tone
				if p, n := _arg_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _éAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _é, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [éÉ]/[eE] (acute_combiner/arg_tone)
	{
		pos2 := pos
		// [éÉ]
		if r, w := _next(parser, pos); r != 'é' && r != 'É' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (acute_combiner/arg_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (acute_combiner/arg_tone)
		// acute_combiner/arg_tone
		{
			pos8 := pos
			// acute_combiner
			if !_accept(parser, _acute_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// arg_tone
			if !_accept(parser, _arg_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _é, start, pos, perr)
fail:
	return _memoize(parser, _é, start, -1, perr)
}

func _éNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_é]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _é}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "é"}
	// [éÉ]/[eE] (acute_combiner/arg_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [éÉ]
		if r, w := _next(parser, pos); r != 'é' && r != 'É' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [eE] (acute_combiner/arg_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (acute_combiner/arg_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// acute_combiner/arg_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// acute_combiner
				if !_node(parser, _acute_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// arg_tone
				if !_node(parser, _arg_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _éFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _é, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "é",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _é}
	// [éÉ]/[eE] (acute_combiner/arg_tone)
	{
		pos2 := pos
		// [éÉ]
		if r, w := _next(parser, pos); r != 'é' && r != 'É' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[éÉ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (acute_combiner/arg_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[eE]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (acute_combiner/arg_tone)
		// acute_combiner/arg_tone
		{
			pos8 := pos
			// acute_combiner
			if !_fail(parser, _acute_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// arg_tone
			if !_fail(parser, _arg_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _éAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_é]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _é}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [éÉ]/[eE] (acute_combiner/arg_tone)
	{
		pos2 := pos
		// [éÉ]
		if r, w := _next(parser, pos); r != 'é' && r != 'É' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (acute_combiner/arg_tone)
		{
			var node5 string
			// [eE]
			if r, w := _next(parser, pos); r != 'e' && r != 'E' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (acute_combiner/arg_tone)
			// acute_combiner/arg_tone
			{
				pos8 := pos
				// acute_combiner
				if p, n := _acute_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// arg_tone
				if p, n := _arg_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _acute_combinerAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _acute_combiner, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// "́"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "́" {
		perr = _max(perr, pos)
		goto fail
	}
	pos += 2
	perr = start
	return _memoize(parser, _acute_combiner, start, pos, perr)
fail:
	return _memoize(parser, _acute_combiner, start, -1, perr)
}

func _acute_combinerNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_acute_combiner]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _acute_combiner}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "acute_combiner"}
	// "́"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "́" {
		goto fail
	}
	node.Kids = append(node.Kids, _leaf(parser, pos, pos+2))
	pos += 2
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _acute_combinerFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _acute_combiner, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "acute_combiner",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _acute_combiner}
	// "́"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "́" {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "\"́\"",
			})
		}
		goto fail
	}
	pos += 2
	failure.Kids = nil
	parser.fail[key] = failure
	return pos, failure
fail:
	failure.Kids = nil
	failure.Want = "◌́"
	parser.fail[key] = failure
	return -1, failure
}

func _acute_combinerAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_acute_combiner]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _acute_combiner}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// "́"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "́" {
		goto fail
	}
	node = parser.text[pos : pos+2]
	pos += 2
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _arg_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _arg_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [/2]
	if r, w := _next(parser, pos); r != '/' && r != '2' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _arg_tone, start, pos, perr)
fail:
	return _memoize(parser, _arg_tone, start, -1, perr)
}

func _arg_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_arg_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _arg_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "arg_tone"}
	// [/2]
	if r, w := _next(parser, pos); r != '/' && r != '2' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _arg_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _arg_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "arg_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _arg_tone}
	// [/2]
	if r, w := _next(parser, pos); r != '/' && r != '2' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[/2]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _arg_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_arg_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _arg_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [/2]
	if r, w := _next(parser, pos); r != '/' && r != '2' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ǎAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ǎ, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ǎǍ]/[aA] (caron_combiner/breve_combiner/relative_tone)
	{
		pos2 := pos
		// [ǎǍ]
		if r, w := _next(parser, pos); r != 'ǎ' && r != 'Ǎ' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (caron_combiner/breve_combiner/relative_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (caron_combiner/breve_combiner/relative_tone)
		// caron_combiner/breve_combiner/relative_tone
		{
			pos8 := pos
			// caron_combiner
			if !_accept(parser, _caron_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// breve_combiner
			if !_accept(parser, _breve_combinerAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			// relative_tone
			if !_accept(parser, _relative_toneAccepts, &pos, &perr) {
				goto fail11
			}
			goto ok6
		fail11:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ǎ, start, pos, perr)
fail:
	return _memoize(parser, _ǎ, start, -1, perr)
}

func _ǎNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ǎ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ǎ}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ǎ"}
	// [ǎǍ]/[aA] (caron_combiner/breve_combiner/relative_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ǎǍ]
		if r, w := _next(parser, pos); r != 'ǎ' && r != 'Ǎ' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [aA] (caron_combiner/breve_combiner/relative_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (caron_combiner/breve_combiner/relative_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// caron_combiner/breve_combiner/relative_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// caron_combiner
				if !_node(parser, _caron_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// breve_combiner
				if !_node(parser, _breve_combinerNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// relative_tone
				if !_node(parser, _relative_toneNode, node, &pos) {
					goto fail13
				}
				goto ok8
			fail13:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ǎFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ǎ, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ǎ",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ǎ}
	// [ǎǍ]/[aA] (caron_combiner/breve_combiner/relative_tone)
	{
		pos2 := pos
		// [ǎǍ]
		if r, w := _next(parser, pos); r != 'ǎ' && r != 'Ǎ' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ǎǍ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (caron_combiner/breve_combiner/relative_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[aA]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (caron_combiner/breve_combiner/relative_tone)
		// caron_combiner/breve_combiner/relative_tone
		{
			pos8 := pos
			// caron_combiner
			if !_fail(parser, _caron_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// breve_combiner
			if !_fail(parser, _breve_combinerFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			// relative_tone
			if !_fail(parser, _relative_toneFail, errPos, failure, &pos) {
				goto fail11
			}
			goto ok6
		fail11:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ǎAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ǎ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ǎ}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ǎǍ]/[aA] (caron_combiner/breve_combiner/relative_tone)
	{
		pos2 := pos
		// [ǎǍ]
		if r, w := _next(parser, pos); r != 'ǎ' && r != 'Ǎ' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (caron_combiner/breve_combiner/relative_tone)
		{
			var node5 string
			// [aA]
			if r, w := _next(parser, pos); r != 'a' && r != 'A' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (caron_combiner/breve_combiner/relative_tone)
			// caron_combiner/breve_combiner/relative_tone
			{
				pos8 := pos
				// caron_combiner
				if p, n := _caron_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// breve_combiner
				if p, n := _breve_combinerAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				// relative_tone
				if p, n := _relative_toneAction(parser, pos); n == nil {
					goto fail11
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail11:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ǔAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ǔ, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ǔǓ]/[uU] (caron_combiner/breve_combiner/relative_tone)
	{
		pos2 := pos
		// [ǔǓ]
		if r, w := _next(parser, pos); r != 'ǔ' && r != 'Ǔ' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (caron_combiner/breve_combiner/relative_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (caron_combiner/breve_combiner/relative_tone)
		// caron_combiner/breve_combiner/relative_tone
		{
			pos8 := pos
			// caron_combiner
			if !_accept(parser, _caron_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// breve_combiner
			if !_accept(parser, _breve_combinerAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			// relative_tone
			if !_accept(parser, _relative_toneAccepts, &pos, &perr) {
				goto fail11
			}
			goto ok6
		fail11:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ǔ, start, pos, perr)
fail:
	return _memoize(parser, _ǔ, start, -1, perr)
}

func _ǔNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ǔ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ǔ}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ǔ"}
	// [ǔǓ]/[uU] (caron_combiner/breve_combiner/relative_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ǔǓ]
		if r, w := _next(parser, pos); r != 'ǔ' && r != 'Ǔ' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [uU] (caron_combiner/breve_combiner/relative_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (caron_combiner/breve_combiner/relative_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// caron_combiner/breve_combiner/relative_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// caron_combiner
				if !_node(parser, _caron_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// breve_combiner
				if !_node(parser, _breve_combinerNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// relative_tone
				if !_node(parser, _relative_toneNode, node, &pos) {
					goto fail13
				}
				goto ok8
			fail13:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ǔFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ǔ, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ǔ",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ǔ}
	// [ǔǓ]/[uU] (caron_combiner/breve_combiner/relative_tone)
	{
		pos2 := pos
		// [ǔǓ]
		if r, w := _next(parser, pos); r != 'ǔ' && r != 'Ǔ' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ǔǓ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (caron_combiner/breve_combiner/relative_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[uU]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (caron_combiner/breve_combiner/relative_tone)
		// caron_combiner/breve_combiner/relative_tone
		{
			pos8 := pos
			// caron_combiner
			if !_fail(parser, _caron_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// breve_combiner
			if !_fail(parser, _breve_combinerFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			// relative_tone
			if !_fail(parser, _relative_toneFail, errPos, failure, &pos) {
				goto fail11
			}
			goto ok6
		fail11:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ǔAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ǔ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ǔ}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ǔǓ]/[uU] (caron_combiner/breve_combiner/relative_tone)
	{
		pos2 := pos
		// [ǔǓ]
		if r, w := _next(parser, pos); r != 'ǔ' && r != 'Ǔ' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (caron_combiner/breve_combiner/relative_tone)
		{
			var node5 string
			// [uU]
			if r, w := _next(parser, pos); r != 'u' && r != 'U' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (caron_combiner/breve_combiner/relative_tone)
			// caron_combiner/breve_combiner/relative_tone
			{
				pos8 := pos
				// caron_combiner
				if p, n := _caron_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// breve_combiner
				if p, n := _breve_combinerAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				// relative_tone
				if p, n := _relative_toneAction(parser, pos); n == nil {
					goto fail11
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail11:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ǐAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ǐ, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ǐǏ]/[iI] (caron_combiner/breve_combiner/relative_tone)
	{
		pos2 := pos
		// [ǐǏ]
		if r, w := _next(parser, pos); r != 'ǐ' && r != 'Ǐ' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (caron_combiner/breve_combiner/relative_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (caron_combiner/breve_combiner/relative_tone)
		// caron_combiner/breve_combiner/relative_tone
		{
			pos8 := pos
			// caron_combiner
			if !_accept(parser, _caron_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// breve_combiner
			if !_accept(parser, _breve_combinerAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			// relative_tone
			if !_accept(parser, _relative_toneAccepts, &pos, &perr) {
				goto fail11
			}
			goto ok6
		fail11:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ǐ, start, pos, perr)
fail:
	return _memoize(parser, _ǐ, start, -1, perr)
}

func _ǐNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ǐ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ǐ}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ǐ"}
	// [ǐǏ]/[iI] (caron_combiner/breve_combiner/relative_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ǐǏ]
		if r, w := _next(parser, pos); r != 'ǐ' && r != 'Ǐ' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [iI] (caron_combiner/breve_combiner/relative_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (caron_combiner/breve_combiner/relative_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// caron_combiner/breve_combiner/relative_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// caron_combiner
				if !_node(parser, _caron_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// breve_combiner
				if !_node(parser, _breve_combinerNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// relative_tone
				if !_node(parser, _relative_toneNode, node, &pos) {
					goto fail13
				}
				goto ok8
			fail13:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ǐFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ǐ, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ǐ",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ǐ}
	// [ǐǏ]/[iI] (caron_combiner/breve_combiner/relative_tone)
	{
		pos2 := pos
		// [ǐǏ]
		if r, w := _next(parser, pos); r != 'ǐ' && r != 'Ǐ' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ǐǏ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (caron_combiner/breve_combiner/relative_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[iI]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (caron_combiner/breve_combiner/relative_tone)
		// caron_combiner/breve_combiner/relative_tone
		{
			pos8 := pos
			// caron_combiner
			if !_fail(parser, _caron_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// breve_combiner
			if !_fail(parser, _breve_combinerFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			// relative_tone
			if !_fail(parser, _relative_toneFail, errPos, failure, &pos) {
				goto fail11
			}
			goto ok6
		fail11:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ǐAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ǐ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ǐ}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ǐǏ]/[iI] (caron_combiner/breve_combiner/relative_tone)
	{
		pos2 := pos
		// [ǐǏ]
		if r, w := _next(parser, pos); r != 'ǐ' && r != 'Ǐ' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (caron_combiner/breve_combiner/relative_tone)
		{
			var node5 string
			// [iI]
			if r, w := _next(parser, pos); r != 'i' && r != 'I' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (caron_combiner/breve_combiner/relative_tone)
			// caron_combiner/breve_combiner/relative_tone
			{
				pos8 := pos
				// caron_combiner
				if p, n := _caron_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// breve_combiner
				if p, n := _breve_combinerAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				// relative_tone
				if p, n := _relative_toneAction(parser, pos); n == nil {
					goto fail11
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail11:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ǒAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ǒ, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ǒǑ]/[oO] (caron_combiner/breve_combiner/relative_tone)
	{
		pos2 := pos
		// [ǒǑ]
		if r, w := _next(parser, pos); r != 'ǒ' && r != 'Ǒ' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (caron_combiner/breve_combiner/relative_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (caron_combiner/breve_combiner/relative_tone)
		// caron_combiner/breve_combiner/relative_tone
		{
			pos8 := pos
			// caron_combiner
			if !_accept(parser, _caron_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// breve_combiner
			if !_accept(parser, _breve_combinerAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			// relative_tone
			if !_accept(parser, _relative_toneAccepts, &pos, &perr) {
				goto fail11
			}
			goto ok6
		fail11:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ǒ, start, pos, perr)
fail:
	return _memoize(parser, _ǒ, start, -1, perr)
}

func _ǒNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ǒ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ǒ}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ǒ"}
	// [ǒǑ]/[oO] (caron_combiner/breve_combiner/relative_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ǒǑ]
		if r, w := _next(parser, pos); r != 'ǒ' && r != 'Ǒ' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [oO] (caron_combiner/breve_combiner/relative_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (caron_combiner/breve_combiner/relative_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// caron_combiner/breve_combiner/relative_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// caron_combiner
				if !_node(parser, _caron_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// breve_combiner
				if !_node(parser, _breve_combinerNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// relative_tone
				if !_node(parser, _relative_toneNode, node, &pos) {
					goto fail13
				}
				goto ok8
			fail13:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ǒFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ǒ, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ǒ",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ǒ}
	// [ǒǑ]/[oO] (caron_combiner/breve_combiner/relative_tone)
	{
		pos2 := pos
		// [ǒǑ]
		if r, w := _next(parser, pos); r != 'ǒ' && r != 'Ǒ' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ǒǑ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (caron_combiner/breve_combiner/relative_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[oO]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (caron_combiner/breve_combiner/relative_tone)
		// caron_combiner/breve_combiner/relative_tone
		{
			pos8 := pos
			// caron_combiner
			if !_fail(parser, _caron_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// breve_combiner
			if !_fail(parser, _breve_combinerFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			// relative_tone
			if !_fail(parser, _relative_toneFail, errPos, failure, &pos) {
				goto fail11
			}
			goto ok6
		fail11:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ǒAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ǒ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ǒ}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ǒǑ]/[oO] (caron_combiner/breve_combiner/relative_tone)
	{
		pos2 := pos
		// [ǒǑ]
		if r, w := _next(parser, pos); r != 'ǒ' && r != 'Ǒ' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (caron_combiner/breve_combiner/relative_tone)
		{
			var node5 string
			// [oO]
			if r, w := _next(parser, pos); r != 'o' && r != 'O' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (caron_combiner/breve_combiner/relative_tone)
			// caron_combiner/breve_combiner/relative_tone
			{
				pos8 := pos
				// caron_combiner
				if p, n := _caron_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// breve_combiner
				if p, n := _breve_combinerAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				// relative_tone
				if p, n := _relative_toneAction(parser, pos); n == nil {
					goto fail11
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail11:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ěAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ě, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ěĚ]/[eE] (caron_combiner/breve_combiner/relative_tone)
	{
		pos2 := pos
		// [ěĚ]
		if r, w := _next(parser, pos); r != 'ě' && r != 'Ě' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (caron_combiner/breve_combiner/relative_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (caron_combiner/breve_combiner/relative_tone)
		// caron_combiner/breve_combiner/relative_tone
		{
			pos8 := pos
			// caron_combiner
			if !_accept(parser, _caron_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// breve_combiner
			if !_accept(parser, _breve_combinerAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			// relative_tone
			if !_accept(parser, _relative_toneAccepts, &pos, &perr) {
				goto fail11
			}
			goto ok6
		fail11:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ě, start, pos, perr)
fail:
	return _memoize(parser, _ě, start, -1, perr)
}

func _ěNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ě]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ě}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ě"}
	// [ěĚ]/[eE] (caron_combiner/breve_combiner/relative_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ěĚ]
		if r, w := _next(parser, pos); r != 'ě' && r != 'Ě' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [eE] (caron_combiner/breve_combiner/relative_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (caron_combiner/breve_combiner/relative_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// caron_combiner/breve_combiner/relative_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// caron_combiner
				if !_node(parser, _caron_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// breve_combiner
				if !_node(parser, _breve_combinerNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// relative_tone
				if !_node(parser, _relative_toneNode, node, &pos) {
					goto fail13
				}
				goto ok8
			fail13:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ěFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ě, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ě",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ě}
	// [ěĚ]/[eE] (caron_combiner/breve_combiner/relative_tone)
	{
		pos2 := pos
		// [ěĚ]
		if r, w := _next(parser, pos); r != 'ě' && r != 'Ě' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ěĚ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (caron_combiner/breve_combiner/relative_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[eE]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (caron_combiner/breve_combiner/relative_tone)
		// caron_combiner/breve_combiner/relative_tone
		{
			pos8 := pos
			// caron_combiner
			if !_fail(parser, _caron_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// breve_combiner
			if !_fail(parser, _breve_combinerFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			// relative_tone
			if !_fail(parser, _relative_toneFail, errPos, failure, &pos) {
				goto fail11
			}
			goto ok6
		fail11:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ěAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ě]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ě}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ěĚ]/[eE] (caron_combiner/breve_combiner/relative_tone)
	{
		pos2 := pos
		// [ěĚ]
		if r, w := _next(parser, pos); r != 'ě' && r != 'Ě' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (caron_combiner/breve_combiner/relative_tone)
		{
			var node5 string
			// [eE]
			if r, w := _next(parser, pos); r != 'e' && r != 'E' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (caron_combiner/breve_combiner/relative_tone)
			// caron_combiner/breve_combiner/relative_tone
			{
				pos8 := pos
				// caron_combiner
				if p, n := _caron_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// breve_combiner
				if p, n := _breve_combinerAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				// relative_tone
				if p, n := _relative_toneAction(parser, pos); n == nil {
					goto fail11
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail11:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _caron_combinerAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _caron_combiner, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// "̌"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̌" {
		perr = _max(perr, pos)
		goto fail
	}
	pos += 2
	perr = start
	return _memoize(parser, _caron_combiner, start, pos, perr)
fail:
	return _memoize(parser, _caron_combiner, start, -1, perr)
}

func _caron_combinerNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_caron_combiner]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _caron_combiner}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "caron_combiner"}
	// "̌"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̌" {
		goto fail
	}
	node.Kids = append(node.Kids, _leaf(parser, pos, pos+2))
	pos += 2
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _caron_combinerFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _caron_combiner, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "caron_combiner",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _caron_combiner}
	// "̌"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̌" {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "\"̌\"",
			})
		}
		goto fail
	}
	pos += 2
	failure.Kids = nil
	parser.fail[key] = failure
	return pos, failure
fail:
	failure.Kids = nil
	failure.Want = "◌̌"
	parser.fail[key] = failure
	return -1, failure
}

func _caron_combinerAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_caron_combiner]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _caron_combiner}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// "̌"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̌" {
		goto fail
	}
	node = parser.text[pos : pos+2]
	pos += 2
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _breve_combinerAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _breve_combiner, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// "̆"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̆" {
		perr = _max(perr, pos)
		goto fail
	}
	pos += 2
	perr = start
	return _memoize(parser, _breve_combiner, start, pos, perr)
fail:
	return _memoize(parser, _breve_combiner, start, -1, perr)
}

func _breve_combinerNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_breve_combiner]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _breve_combiner}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "breve_combiner"}
	// "̆"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̆" {
		goto fail
	}
	node.Kids = append(node.Kids, _leaf(parser, pos, pos+2))
	pos += 2
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _breve_combinerFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _breve_combiner, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "breve_combiner",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _breve_combiner}
	// "̆"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̆" {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "\"̆\"",
			})
		}
		goto fail
	}
	pos += 2
	failure.Kids = nil
	parser.fail[key] = failure
	return pos, failure
fail:
	failure.Kids = nil
	failure.Want = "◌̆"
	parser.fail[key] = failure
	return -1, failure
}

func _breve_combinerAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_breve_combiner]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _breve_combiner}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// "̆"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̆" {
		goto fail
	}
	node = parser.text[pos : pos+2]
	pos += 2
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _relative_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _relative_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [V3]
	if r, w := _next(parser, pos); r != 'V' && r != '3' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _relative_tone, start, pos, perr)
fail:
	return _memoize(parser, _relative_tone, start, -1, perr)
}

func _relative_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_relative_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "relative_tone"}
	// [V3]
	if r, w := _next(parser, pos); r != 'V' && r != '3' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _relative_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _relative_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "relative_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _relative_tone}
	// [V3]
	if r, w := _next(parser, pos); r != 'V' && r != '3' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[V3]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _relative_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_relative_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _relative_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [V3]
	if r, w := _next(parser, pos); r != 'V' && r != '3' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ảAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ả, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ảẢ]/[aA] (hook_combiner/verb_tone)
	{
		pos2 := pos
		// [ảẢ]
		if r, w := _next(parser, pos); r != 'ả' && r != 'Ả' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (hook_combiner/verb_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (hook_combiner/verb_tone)
		// hook_combiner/verb_tone
		{
			pos8 := pos
			// hook_combiner
			if !_accept(parser, _hook_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// verb_tone
			if !_accept(parser, _verb_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ả, start, pos, perr)
fail:
	return _memoize(parser, _ả, start, -1, perr)
}

func _ảNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ả]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ả}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ả"}
	// [ảẢ]/[aA] (hook_combiner/verb_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ảẢ]
		if r, w := _next(parser, pos); r != 'ả' && r != 'Ả' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [aA] (hook_combiner/verb_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (hook_combiner/verb_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// hook_combiner/verb_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// hook_combiner
				if !_node(parser, _hook_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// verb_tone
				if !_node(parser, _verb_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ảFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ả, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ả",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ả}
	// [ảẢ]/[aA] (hook_combiner/verb_tone)
	{
		pos2 := pos
		// [ảẢ]
		if r, w := _next(parser, pos); r != 'ả' && r != 'Ả' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ảẢ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (hook_combiner/verb_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[aA]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (hook_combiner/verb_tone)
		// hook_combiner/verb_tone
		{
			pos8 := pos
			// hook_combiner
			if !_fail(parser, _hook_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// verb_tone
			if !_fail(parser, _verb_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ảAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ả]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ả}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ảẢ]/[aA] (hook_combiner/verb_tone)
	{
		pos2 := pos
		// [ảẢ]
		if r, w := _next(parser, pos); r != 'ả' && r != 'Ả' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (hook_combiner/verb_tone)
		{
			var node5 string
			// [aA]
			if r, w := _next(parser, pos); r != 'a' && r != 'A' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (hook_combiner/verb_tone)
			// hook_combiner/verb_tone
			{
				pos8 := pos
				// hook_combiner
				if p, n := _hook_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// verb_tone
				if p, n := _verb_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ủAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ủ, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ủỦ]/[uU] (hook_combiner/verb_tone)
	{
		pos2 := pos
		// [ủỦ]
		if r, w := _next(parser, pos); r != 'ủ' && r != 'Ủ' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (hook_combiner/verb_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (hook_combiner/verb_tone)
		// hook_combiner/verb_tone
		{
			pos8 := pos
			// hook_combiner
			if !_accept(parser, _hook_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// verb_tone
			if !_accept(parser, _verb_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ủ, start, pos, perr)
fail:
	return _memoize(parser, _ủ, start, -1, perr)
}

func _ủNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ủ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ủ}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ủ"}
	// [ủỦ]/[uU] (hook_combiner/verb_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ủỦ]
		if r, w := _next(parser, pos); r != 'ủ' && r != 'Ủ' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [uU] (hook_combiner/verb_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (hook_combiner/verb_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// hook_combiner/verb_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// hook_combiner
				if !_node(parser, _hook_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// verb_tone
				if !_node(parser, _verb_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ủFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ủ, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ủ",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ủ}
	// [ủỦ]/[uU] (hook_combiner/verb_tone)
	{
		pos2 := pos
		// [ủỦ]
		if r, w := _next(parser, pos); r != 'ủ' && r != 'Ủ' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ủỦ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (hook_combiner/verb_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[uU]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (hook_combiner/verb_tone)
		// hook_combiner/verb_tone
		{
			pos8 := pos
			// hook_combiner
			if !_fail(parser, _hook_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// verb_tone
			if !_fail(parser, _verb_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ủAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ủ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ủ}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ủỦ]/[uU] (hook_combiner/verb_tone)
	{
		pos2 := pos
		// [ủỦ]
		if r, w := _next(parser, pos); r != 'ủ' && r != 'Ủ' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (hook_combiner/verb_tone)
		{
			var node5 string
			// [uU]
			if r, w := _next(parser, pos); r != 'u' && r != 'U' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (hook_combiner/verb_tone)
			// hook_combiner/verb_tone
			{
				pos8 := pos
				// hook_combiner
				if p, n := _hook_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// verb_tone
				if p, n := _verb_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ỉAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ỉ, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ỉỈ]/[iI] (hook_combiner/verb_tone)
	{
		pos2 := pos
		// [ỉỈ]
		if r, w := _next(parser, pos); r != 'ỉ' && r != 'Ỉ' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (hook_combiner/verb_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (hook_combiner/verb_tone)
		// hook_combiner/verb_tone
		{
			pos8 := pos
			// hook_combiner
			if !_accept(parser, _hook_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// verb_tone
			if !_accept(parser, _verb_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ỉ, start, pos, perr)
fail:
	return _memoize(parser, _ỉ, start, -1, perr)
}

func _ỉNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ỉ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ỉ}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ỉ"}
	// [ỉỈ]/[iI] (hook_combiner/verb_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ỉỈ]
		if r, w := _next(parser, pos); r != 'ỉ' && r != 'Ỉ' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [iI] (hook_combiner/verb_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (hook_combiner/verb_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// hook_combiner/verb_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// hook_combiner
				if !_node(parser, _hook_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// verb_tone
				if !_node(parser, _verb_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ỉFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ỉ, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ỉ",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ỉ}
	// [ỉỈ]/[iI] (hook_combiner/verb_tone)
	{
		pos2 := pos
		// [ỉỈ]
		if r, w := _next(parser, pos); r != 'ỉ' && r != 'Ỉ' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ỉỈ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (hook_combiner/verb_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[iI]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (hook_combiner/verb_tone)
		// hook_combiner/verb_tone
		{
			pos8 := pos
			// hook_combiner
			if !_fail(parser, _hook_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// verb_tone
			if !_fail(parser, _verb_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ỉAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ỉ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ỉ}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ỉỈ]/[iI] (hook_combiner/verb_tone)
	{
		pos2 := pos
		// [ỉỈ]
		if r, w := _next(parser, pos); r != 'ỉ' && r != 'Ỉ' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (hook_combiner/verb_tone)
		{
			var node5 string
			// [iI]
			if r, w := _next(parser, pos); r != 'i' && r != 'I' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (hook_combiner/verb_tone)
			// hook_combiner/verb_tone
			{
				pos8 := pos
				// hook_combiner
				if p, n := _hook_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// verb_tone
				if p, n := _verb_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ỏAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ỏ, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ỏỎ]/[oO] (hook_combiner/verb_tone)
	{
		pos2 := pos
		// [ỏỎ]
		if r, w := _next(parser, pos); r != 'ỏ' && r != 'Ỏ' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (hook_combiner/verb_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (hook_combiner/verb_tone)
		// hook_combiner/verb_tone
		{
			pos8 := pos
			// hook_combiner
			if !_accept(parser, _hook_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// verb_tone
			if !_accept(parser, _verb_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ỏ, start, pos, perr)
fail:
	return _memoize(parser, _ỏ, start, -1, perr)
}

func _ỏNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ỏ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ỏ}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ỏ"}
	// [ỏỎ]/[oO] (hook_combiner/verb_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ỏỎ]
		if r, w := _next(parser, pos); r != 'ỏ' && r != 'Ỏ' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [oO] (hook_combiner/verb_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (hook_combiner/verb_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// hook_combiner/verb_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// hook_combiner
				if !_node(parser, _hook_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// verb_tone
				if !_node(parser, _verb_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ỏFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ỏ, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ỏ",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ỏ}
	// [ỏỎ]/[oO] (hook_combiner/verb_tone)
	{
		pos2 := pos
		// [ỏỎ]
		if r, w := _next(parser, pos); r != 'ỏ' && r != 'Ỏ' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ỏỎ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (hook_combiner/verb_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[oO]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (hook_combiner/verb_tone)
		// hook_combiner/verb_tone
		{
			pos8 := pos
			// hook_combiner
			if !_fail(parser, _hook_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// verb_tone
			if !_fail(parser, _verb_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ỏAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ỏ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ỏ}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ỏỎ]/[oO] (hook_combiner/verb_tone)
	{
		pos2 := pos
		// [ỏỎ]
		if r, w := _next(parser, pos); r != 'ỏ' && r != 'Ỏ' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (hook_combiner/verb_tone)
		{
			var node5 string
			// [oO]
			if r, w := _next(parser, pos); r != 'o' && r != 'O' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (hook_combiner/verb_tone)
			// hook_combiner/verb_tone
			{
				pos8 := pos
				// hook_combiner
				if p, n := _hook_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// verb_tone
				if p, n := _verb_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ẻAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ẻ, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ẻẺ]/[eE] (hook_combiner/verb_tone)
	{
		pos2 := pos
		// [ẻẺ]
		if r, w := _next(parser, pos); r != 'ẻ' && r != 'Ẻ' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (hook_combiner/verb_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (hook_combiner/verb_tone)
		// hook_combiner/verb_tone
		{
			pos8 := pos
			// hook_combiner
			if !_accept(parser, _hook_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// verb_tone
			if !_accept(parser, _verb_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ẻ, start, pos, perr)
fail:
	return _memoize(parser, _ẻ, start, -1, perr)
}

func _ẻNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ẻ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ẻ}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ẻ"}
	// [ẻẺ]/[eE] (hook_combiner/verb_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ẻẺ]
		if r, w := _next(parser, pos); r != 'ẻ' && r != 'Ẻ' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [eE] (hook_combiner/verb_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (hook_combiner/verb_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// hook_combiner/verb_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// hook_combiner
				if !_node(parser, _hook_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// verb_tone
				if !_node(parser, _verb_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ẻFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ẻ, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ẻ",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ẻ}
	// [ẻẺ]/[eE] (hook_combiner/verb_tone)
	{
		pos2 := pos
		// [ẻẺ]
		if r, w := _next(parser, pos); r != 'ẻ' && r != 'Ẻ' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ẻẺ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (hook_combiner/verb_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[eE]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (hook_combiner/verb_tone)
		// hook_combiner/verb_tone
		{
			pos8 := pos
			// hook_combiner
			if !_fail(parser, _hook_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// verb_tone
			if !_fail(parser, _verb_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ẻAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ẻ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ẻ}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ẻẺ]/[eE] (hook_combiner/verb_tone)
	{
		pos2 := pos
		// [ẻẺ]
		if r, w := _next(parser, pos); r != 'ẻ' && r != 'Ẻ' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (hook_combiner/verb_tone)
		{
			var node5 string
			// [eE]
			if r, w := _next(parser, pos); r != 'e' && r != 'E' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (hook_combiner/verb_tone)
			// hook_combiner/verb_tone
			{
				pos8 := pos
				// hook_combiner
				if p, n := _hook_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// verb_tone
				if p, n := _verb_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _hook_combinerAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _hook_combiner, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// "̉"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̉" {
		perr = _max(perr, pos)
		goto fail
	}
	pos += 2
	perr = start
	return _memoize(parser, _hook_combiner, start, pos, perr)
fail:
	return _memoize(parser, _hook_combiner, start, -1, perr)
}

func _hook_combinerNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_hook_combiner]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _hook_combiner}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "hook_combiner"}
	// "̉"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̉" {
		goto fail
	}
	node.Kids = append(node.Kids, _leaf(parser, pos, pos+2))
	pos += 2
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _hook_combinerFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _hook_combiner, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "hook_combiner",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _hook_combiner}
	// "̉"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̉" {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "\"̉\"",
			})
		}
		goto fail
	}
	pos += 2
	failure.Kids = nil
	parser.fail[key] = failure
	return pos, failure
fail:
	failure.Kids = nil
	failure.Want = "◌̉"
	parser.fail[key] = failure
	return -1, failure
}

func _hook_combinerAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_hook_combiner]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _hook_combiner}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// "̉"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̉" {
		goto fail
	}
	node = parser.text[pos : pos+2]
	pos += 2
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _verb_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _verb_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [?4]
	if r, w := _next(parser, pos); r != '?' && r != '4' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _verb_tone, start, pos, perr)
fail:
	return _memoize(parser, _verb_tone, start, -1, perr)
}

func _verb_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_verb_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _verb_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "verb_tone"}
	// [?4]
	if r, w := _next(parser, pos); r != '?' && r != '4' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _verb_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _verb_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "verb_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _verb_tone}
	// [?4]
	if r, w := _next(parser, pos); r != '?' && r != '4' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[?4]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _verb_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_verb_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _verb_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [?4]
	if r, w := _next(parser, pos); r != '?' && r != '4' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _âAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _â, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [âÂ]/[aA] (circumflex_combiner/content_tone)
	{
		pos2 := pos
		// [âÂ]
		if r, w := _next(parser, pos); r != 'â' && r != 'Â' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (circumflex_combiner/content_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (circumflex_combiner/content_tone)
		// circumflex_combiner/content_tone
		{
			pos8 := pos
			// circumflex_combiner
			if !_accept(parser, _circumflex_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// content_tone
			if !_accept(parser, _content_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _â, start, pos, perr)
fail:
	return _memoize(parser, _â, start, -1, perr)
}

func _âNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_â]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _â}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "â"}
	// [âÂ]/[aA] (circumflex_combiner/content_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [âÂ]
		if r, w := _next(parser, pos); r != 'â' && r != 'Â' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [aA] (circumflex_combiner/content_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (circumflex_combiner/content_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// circumflex_combiner/content_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// circumflex_combiner
				if !_node(parser, _circumflex_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// content_tone
				if !_node(parser, _content_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _âFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _â, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "â",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _â}
	// [âÂ]/[aA] (circumflex_combiner/content_tone)
	{
		pos2 := pos
		// [âÂ]
		if r, w := _next(parser, pos); r != 'â' && r != 'Â' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[âÂ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (circumflex_combiner/content_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[aA]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (circumflex_combiner/content_tone)
		// circumflex_combiner/content_tone
		{
			pos8 := pos
			// circumflex_combiner
			if !_fail(parser, _circumflex_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// content_tone
			if !_fail(parser, _content_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _âAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_â]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _â}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [âÂ]/[aA] (circumflex_combiner/content_tone)
	{
		pos2 := pos
		// [âÂ]
		if r, w := _next(parser, pos); r != 'â' && r != 'Â' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (circumflex_combiner/content_tone)
		{
			var node5 string
			// [aA]
			if r, w := _next(parser, pos); r != 'a' && r != 'A' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (circumflex_combiner/content_tone)
			// circumflex_combiner/content_tone
			{
				pos8 := pos
				// circumflex_combiner
				if p, n := _circumflex_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// content_tone
				if p, n := _content_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ûAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _û, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ûÛ]/[uU] (circumflex_combiner/content_tone)
	{
		pos2 := pos
		// [ûÛ]
		if r, w := _next(parser, pos); r != 'û' && r != 'Û' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (circumflex_combiner/content_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (circumflex_combiner/content_tone)
		// circumflex_combiner/content_tone
		{
			pos8 := pos
			// circumflex_combiner
			if !_accept(parser, _circumflex_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// content_tone
			if !_accept(parser, _content_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _û, start, pos, perr)
fail:
	return _memoize(parser, _û, start, -1, perr)
}

func _ûNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_û]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _û}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "û"}
	// [ûÛ]/[uU] (circumflex_combiner/content_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ûÛ]
		if r, w := _next(parser, pos); r != 'û' && r != 'Û' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [uU] (circumflex_combiner/content_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (circumflex_combiner/content_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// circumflex_combiner/content_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// circumflex_combiner
				if !_node(parser, _circumflex_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// content_tone
				if !_node(parser, _content_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ûFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _û, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "û",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _û}
	// [ûÛ]/[uU] (circumflex_combiner/content_tone)
	{
		pos2 := pos
		// [ûÛ]
		if r, w := _next(parser, pos); r != 'û' && r != 'Û' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ûÛ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (circumflex_combiner/content_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[uU]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (circumflex_combiner/content_tone)
		// circumflex_combiner/content_tone
		{
			pos8 := pos
			// circumflex_combiner
			if !_fail(parser, _circumflex_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// content_tone
			if !_fail(parser, _content_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ûAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_û]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _û}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ûÛ]/[uU] (circumflex_combiner/content_tone)
	{
		pos2 := pos
		// [ûÛ]
		if r, w := _next(parser, pos); r != 'û' && r != 'Û' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (circumflex_combiner/content_tone)
		{
			var node5 string
			// [uU]
			if r, w := _next(parser, pos); r != 'u' && r != 'U' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (circumflex_combiner/content_tone)
			// circumflex_combiner/content_tone
			{
				pos8 := pos
				// circumflex_combiner
				if p, n := _circumflex_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// content_tone
				if p, n := _content_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _îAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _î, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [îÎ]/[iI] (circumflex_combiner/content_tone)
	{
		pos2 := pos
		// [îÎ]
		if r, w := _next(parser, pos); r != 'î' && r != 'Î' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (circumflex_combiner/content_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (circumflex_combiner/content_tone)
		// circumflex_combiner/content_tone
		{
			pos8 := pos
			// circumflex_combiner
			if !_accept(parser, _circumflex_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// content_tone
			if !_accept(parser, _content_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _î, start, pos, perr)
fail:
	return _memoize(parser, _î, start, -1, perr)
}

func _îNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_î]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _î}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "î"}
	// [îÎ]/[iI] (circumflex_combiner/content_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [îÎ]
		if r, w := _next(parser, pos); r != 'î' && r != 'Î' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [iI] (circumflex_combiner/content_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (circumflex_combiner/content_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// circumflex_combiner/content_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// circumflex_combiner
				if !_node(parser, _circumflex_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// content_tone
				if !_node(parser, _content_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _îFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _î, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "î",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _î}
	// [îÎ]/[iI] (circumflex_combiner/content_tone)
	{
		pos2 := pos
		// [îÎ]
		if r, w := _next(parser, pos); r != 'î' && r != 'Î' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[îÎ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (circumflex_combiner/content_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[iI]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (circumflex_combiner/content_tone)
		// circumflex_combiner/content_tone
		{
			pos8 := pos
			// circumflex_combiner
			if !_fail(parser, _circumflex_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// content_tone
			if !_fail(parser, _content_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _îAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_î]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _î}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [îÎ]/[iI] (circumflex_combiner/content_tone)
	{
		pos2 := pos
		// [îÎ]
		if r, w := _next(parser, pos); r != 'î' && r != 'Î' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (circumflex_combiner/content_tone)
		{
			var node5 string
			// [iI]
			if r, w := _next(parser, pos); r != 'i' && r != 'I' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (circumflex_combiner/content_tone)
			// circumflex_combiner/content_tone
			{
				pos8 := pos
				// circumflex_combiner
				if p, n := _circumflex_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// content_tone
				if p, n := _content_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ôAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ô, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ôÔ]/[oO] (circumflex_combiner/content_tone)
	{
		pos2 := pos
		// [ôÔ]
		if r, w := _next(parser, pos); r != 'ô' && r != 'Ô' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (circumflex_combiner/content_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (circumflex_combiner/content_tone)
		// circumflex_combiner/content_tone
		{
			pos8 := pos
			// circumflex_combiner
			if !_accept(parser, _circumflex_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// content_tone
			if !_accept(parser, _content_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ô, start, pos, perr)
fail:
	return _memoize(parser, _ô, start, -1, perr)
}

func _ôNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ô]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ô}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ô"}
	// [ôÔ]/[oO] (circumflex_combiner/content_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ôÔ]
		if r, w := _next(parser, pos); r != 'ô' && r != 'Ô' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [oO] (circumflex_combiner/content_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (circumflex_combiner/content_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// circumflex_combiner/content_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// circumflex_combiner
				if !_node(parser, _circumflex_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// content_tone
				if !_node(parser, _content_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ôFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ô, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ô",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ô}
	// [ôÔ]/[oO] (circumflex_combiner/content_tone)
	{
		pos2 := pos
		// [ôÔ]
		if r, w := _next(parser, pos); r != 'ô' && r != 'Ô' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ôÔ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (circumflex_combiner/content_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[oO]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (circumflex_combiner/content_tone)
		// circumflex_combiner/content_tone
		{
			pos8 := pos
			// circumflex_combiner
			if !_fail(parser, _circumflex_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// content_tone
			if !_fail(parser, _content_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ôAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ô]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ô}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ôÔ]/[oO] (circumflex_combiner/content_tone)
	{
		pos2 := pos
		// [ôÔ]
		if r, w := _next(parser, pos); r != 'ô' && r != 'Ô' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (circumflex_combiner/content_tone)
		{
			var node5 string
			// [oO]
			if r, w := _next(parser, pos); r != 'o' && r != 'O' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (circumflex_combiner/content_tone)
			// circumflex_combiner/content_tone
			{
				pos8 := pos
				// circumflex_combiner
				if p, n := _circumflex_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// content_tone
				if p, n := _content_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _êAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ê, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [êÊ]/[eE] (circumflex_combiner/content_tone)
	{
		pos2 := pos
		// [êÊ]
		if r, w := _next(parser, pos); r != 'ê' && r != 'Ê' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (circumflex_combiner/content_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (circumflex_combiner/content_tone)
		// circumflex_combiner/content_tone
		{
			pos8 := pos
			// circumflex_combiner
			if !_accept(parser, _circumflex_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// content_tone
			if !_accept(parser, _content_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ê, start, pos, perr)
fail:
	return _memoize(parser, _ê, start, -1, perr)
}

func _êNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ê]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ê}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ê"}
	// [êÊ]/[eE] (circumflex_combiner/content_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [êÊ]
		if r, w := _next(parser, pos); r != 'ê' && r != 'Ê' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [eE] (circumflex_combiner/content_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (circumflex_combiner/content_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// circumflex_combiner/content_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// circumflex_combiner
				if !_node(parser, _circumflex_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// content_tone
				if !_node(parser, _content_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _êFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ê, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ê",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ê}
	// [êÊ]/[eE] (circumflex_combiner/content_tone)
	{
		pos2 := pos
		// [êÊ]
		if r, w := _next(parser, pos); r != 'ê' && r != 'Ê' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[êÊ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (circumflex_combiner/content_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[eE]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (circumflex_combiner/content_tone)
		// circumflex_combiner/content_tone
		{
			pos8 := pos
			// circumflex_combiner
			if !_fail(parser, _circumflex_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// content_tone
			if !_fail(parser, _content_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _êAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ê]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ê}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [êÊ]/[eE] (circumflex_combiner/content_tone)
	{
		pos2 := pos
		// [êÊ]
		if r, w := _next(parser, pos); r != 'ê' && r != 'Ê' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (circumflex_combiner/content_tone)
		{
			var node5 string
			// [eE]
			if r, w := _next(parser, pos); r != 'e' && r != 'E' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (circumflex_combiner/content_tone)
			// circumflex_combiner/content_tone
			{
				pos8 := pos
				// circumflex_combiner
				if p, n := _circumflex_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// content_tone
				if p, n := _content_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _circumflex_combinerAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _circumflex_combiner, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// "̂"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̂" {
		perr = _max(perr, pos)
		goto fail
	}
	pos += 2
	perr = start
	return _memoize(parser, _circumflex_combiner, start, pos, perr)
fail:
	return _memoize(parser, _circumflex_combiner, start, -1, perr)
}

func _circumflex_combinerNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_circumflex_combiner]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _circumflex_combiner}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "circumflex_combiner"}
	// "̂"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̂" {
		goto fail
	}
	node.Kids = append(node.Kids, _leaf(parser, pos, pos+2))
	pos += 2
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _circumflex_combinerFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _circumflex_combiner, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "circumflex_combiner",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _circumflex_combiner}
	// "̂"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̂" {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "\"̂\"",
			})
		}
		goto fail
	}
	pos += 2
	failure.Kids = nil
	parser.fail[key] = failure
	return pos, failure
fail:
	failure.Kids = nil
	failure.Want = "◌̂"
	parser.fail[key] = failure
	return -1, failure
}

func _circumflex_combinerAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_circumflex_combiner]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _circumflex_combiner}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// "̂"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̂" {
		goto fail
	}
	node = parser.text[pos : pos+2]
	pos += 2
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _content_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _content_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [5\^]
	if r, w := _next(parser, pos); r != '5' && r != '^' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _content_tone, start, pos, perr)
fail:
	return _memoize(parser, _content_tone, start, -1, perr)
}

func _content_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_content_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _content_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "content_tone"}
	// [5\^]
	if r, w := _next(parser, pos); r != '5' && r != '^' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _content_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _content_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "content_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _content_tone}
	// [5\^]
	if r, w := _next(parser, pos); r != '5' && r != '^' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[5\\^]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _content_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_content_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _content_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [5\^]
	if r, w := _next(parser, pos); r != '5' && r != '^' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _àAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _à, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [àÀ]/[aA] (grave_combiner/preposition_tone)
	{
		pos2 := pos
		// [àÀ]
		if r, w := _next(parser, pos); r != 'à' && r != 'À' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (grave_combiner/preposition_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (grave_combiner/preposition_tone)
		// grave_combiner/preposition_tone
		{
			pos8 := pos
			// grave_combiner
			if !_accept(parser, _grave_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// preposition_tone
			if !_accept(parser, _preposition_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _à, start, pos, perr)
fail:
	return _memoize(parser, _à, start, -1, perr)
}

func _àNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_à]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _à}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "à"}
	// [àÀ]/[aA] (grave_combiner/preposition_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [àÀ]
		if r, w := _next(parser, pos); r != 'à' && r != 'À' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [aA] (grave_combiner/preposition_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (grave_combiner/preposition_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// grave_combiner/preposition_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// grave_combiner
				if !_node(parser, _grave_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// preposition_tone
				if !_node(parser, _preposition_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _àFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _à, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "à",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _à}
	// [àÀ]/[aA] (grave_combiner/preposition_tone)
	{
		pos2 := pos
		// [àÀ]
		if r, w := _next(parser, pos); r != 'à' && r != 'À' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[àÀ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (grave_combiner/preposition_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[aA]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (grave_combiner/preposition_tone)
		// grave_combiner/preposition_tone
		{
			pos8 := pos
			// grave_combiner
			if !_fail(parser, _grave_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// preposition_tone
			if !_fail(parser, _preposition_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _àAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_à]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _à}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [àÀ]/[aA] (grave_combiner/preposition_tone)
	{
		pos2 := pos
		// [àÀ]
		if r, w := _next(parser, pos); r != 'à' && r != 'À' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (grave_combiner/preposition_tone)
		{
			var node5 string
			// [aA]
			if r, w := _next(parser, pos); r != 'a' && r != 'A' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (grave_combiner/preposition_tone)
			// grave_combiner/preposition_tone
			{
				pos8 := pos
				// grave_combiner
				if p, n := _grave_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// preposition_tone
				if p, n := _preposition_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ùAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ù, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ùÙ]/[uU] (grave_combiner/preposition_tone)
	{
		pos2 := pos
		// [ùÙ]
		if r, w := _next(parser, pos); r != 'ù' && r != 'Ù' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (grave_combiner/preposition_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (grave_combiner/preposition_tone)
		// grave_combiner/preposition_tone
		{
			pos8 := pos
			// grave_combiner
			if !_accept(parser, _grave_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// preposition_tone
			if !_accept(parser, _preposition_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ù, start, pos, perr)
fail:
	return _memoize(parser, _ù, start, -1, perr)
}

func _ùNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ù]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ù}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ù"}
	// [ùÙ]/[uU] (grave_combiner/preposition_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ùÙ]
		if r, w := _next(parser, pos); r != 'ù' && r != 'Ù' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [uU] (grave_combiner/preposition_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (grave_combiner/preposition_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// grave_combiner/preposition_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// grave_combiner
				if !_node(parser, _grave_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// preposition_tone
				if !_node(parser, _preposition_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ùFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ù, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ù",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ù}
	// [ùÙ]/[uU] (grave_combiner/preposition_tone)
	{
		pos2 := pos
		// [ùÙ]
		if r, w := _next(parser, pos); r != 'ù' && r != 'Ù' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ùÙ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (grave_combiner/preposition_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[uU]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (grave_combiner/preposition_tone)
		// grave_combiner/preposition_tone
		{
			pos8 := pos
			// grave_combiner
			if !_fail(parser, _grave_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// preposition_tone
			if !_fail(parser, _preposition_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ùAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ù]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ù}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ùÙ]/[uU] (grave_combiner/preposition_tone)
	{
		pos2 := pos
		// [ùÙ]
		if r, w := _next(parser, pos); r != 'ù' && r != 'Ù' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (grave_combiner/preposition_tone)
		{
			var node5 string
			// [uU]
			if r, w := _next(parser, pos); r != 'u' && r != 'U' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (grave_combiner/preposition_tone)
			// grave_combiner/preposition_tone
			{
				pos8 := pos
				// grave_combiner
				if p, n := _grave_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// preposition_tone
				if p, n := _preposition_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ìAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ì, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ìÌ]/[iI] (grave_combiner/preposition_tone)
	{
		pos2 := pos
		// [ìÌ]
		if r, w := _next(parser, pos); r != 'ì' && r != 'Ì' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (grave_combiner/preposition_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (grave_combiner/preposition_tone)
		// grave_combiner/preposition_tone
		{
			pos8 := pos
			// grave_combiner
			if !_accept(parser, _grave_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// preposition_tone
			if !_accept(parser, _preposition_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ì, start, pos, perr)
fail:
	return _memoize(parser, _ì, start, -1, perr)
}

func _ìNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ì]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ì}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ì"}
	// [ìÌ]/[iI] (grave_combiner/preposition_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ìÌ]
		if r, w := _next(parser, pos); r != 'ì' && r != 'Ì' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [iI] (grave_combiner/preposition_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (grave_combiner/preposition_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// grave_combiner/preposition_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// grave_combiner
				if !_node(parser, _grave_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// preposition_tone
				if !_node(parser, _preposition_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ìFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ì, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ì",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ì}
	// [ìÌ]/[iI] (grave_combiner/preposition_tone)
	{
		pos2 := pos
		// [ìÌ]
		if r, w := _next(parser, pos); r != 'ì' && r != 'Ì' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ìÌ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (grave_combiner/preposition_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[iI]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (grave_combiner/preposition_tone)
		// grave_combiner/preposition_tone
		{
			pos8 := pos
			// grave_combiner
			if !_fail(parser, _grave_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// preposition_tone
			if !_fail(parser, _preposition_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ìAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ì]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ì}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ìÌ]/[iI] (grave_combiner/preposition_tone)
	{
		pos2 := pos
		// [ìÌ]
		if r, w := _next(parser, pos); r != 'ì' && r != 'Ì' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (grave_combiner/preposition_tone)
		{
			var node5 string
			// [iI]
			if r, w := _next(parser, pos); r != 'i' && r != 'I' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (grave_combiner/preposition_tone)
			// grave_combiner/preposition_tone
			{
				pos8 := pos
				// grave_combiner
				if p, n := _grave_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// preposition_tone
				if p, n := _preposition_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _òAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ò, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [òÒ]/[oO] (grave_combiner/preposition_tone)
	{
		pos2 := pos
		// [òÒ]
		if r, w := _next(parser, pos); r != 'ò' && r != 'Ò' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (grave_combiner/preposition_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (grave_combiner/preposition_tone)
		// grave_combiner/preposition_tone
		{
			pos8 := pos
			// grave_combiner
			if !_accept(parser, _grave_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// preposition_tone
			if !_accept(parser, _preposition_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ò, start, pos, perr)
fail:
	return _memoize(parser, _ò, start, -1, perr)
}

func _òNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ò]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ò}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ò"}
	// [òÒ]/[oO] (grave_combiner/preposition_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [òÒ]
		if r, w := _next(parser, pos); r != 'ò' && r != 'Ò' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [oO] (grave_combiner/preposition_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (grave_combiner/preposition_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// grave_combiner/preposition_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// grave_combiner
				if !_node(parser, _grave_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// preposition_tone
				if !_node(parser, _preposition_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _òFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ò, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ò",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ò}
	// [òÒ]/[oO] (grave_combiner/preposition_tone)
	{
		pos2 := pos
		// [òÒ]
		if r, w := _next(parser, pos); r != 'ò' && r != 'Ò' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[òÒ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (grave_combiner/preposition_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[oO]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (grave_combiner/preposition_tone)
		// grave_combiner/preposition_tone
		{
			pos8 := pos
			// grave_combiner
			if !_fail(parser, _grave_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// preposition_tone
			if !_fail(parser, _preposition_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _òAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ò]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ò}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [òÒ]/[oO] (grave_combiner/preposition_tone)
	{
		pos2 := pos
		// [òÒ]
		if r, w := _next(parser, pos); r != 'ò' && r != 'Ò' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (grave_combiner/preposition_tone)
		{
			var node5 string
			// [oO]
			if r, w := _next(parser, pos); r != 'o' && r != 'O' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (grave_combiner/preposition_tone)
			// grave_combiner/preposition_tone
			{
				pos8 := pos
				// grave_combiner
				if p, n := _grave_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// preposition_tone
				if p, n := _preposition_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _èAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _è, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [èÈ]/[eE] (grave_combiner/preposition_tone)
	{
		pos2 := pos
		// [èÈ]
		if r, w := _next(parser, pos); r != 'è' && r != 'È' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (grave_combiner/preposition_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (grave_combiner/preposition_tone)
		// grave_combiner/preposition_tone
		{
			pos8 := pos
			// grave_combiner
			if !_accept(parser, _grave_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// preposition_tone
			if !_accept(parser, _preposition_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _è, start, pos, perr)
fail:
	return _memoize(parser, _è, start, -1, perr)
}

func _èNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_è]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _è}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "è"}
	// [èÈ]/[eE] (grave_combiner/preposition_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [èÈ]
		if r, w := _next(parser, pos); r != 'è' && r != 'È' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [eE] (grave_combiner/preposition_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (grave_combiner/preposition_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// grave_combiner/preposition_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// grave_combiner
				if !_node(parser, _grave_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// preposition_tone
				if !_node(parser, _preposition_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _èFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _è, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "è",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _è}
	// [èÈ]/[eE] (grave_combiner/preposition_tone)
	{
		pos2 := pos
		// [èÈ]
		if r, w := _next(parser, pos); r != 'è' && r != 'È' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[èÈ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (grave_combiner/preposition_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[eE]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (grave_combiner/preposition_tone)
		// grave_combiner/preposition_tone
		{
			pos8 := pos
			// grave_combiner
			if !_fail(parser, _grave_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// preposition_tone
			if !_fail(parser, _preposition_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _èAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_è]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _è}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [èÈ]/[eE] (grave_combiner/preposition_tone)
	{
		pos2 := pos
		// [èÈ]
		if r, w := _next(parser, pos); r != 'è' && r != 'È' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (grave_combiner/preposition_tone)
		{
			var node5 string
			// [eE]
			if r, w := _next(parser, pos); r != 'e' && r != 'E' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (grave_combiner/preposition_tone)
			// grave_combiner/preposition_tone
			{
				pos8 := pos
				// grave_combiner
				if p, n := _grave_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// preposition_tone
				if p, n := _preposition_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _grave_combinerAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _grave_combiner, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// "̀"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̀" {
		perr = _max(perr, pos)
		goto fail
	}
	pos += 2
	perr = start
	return _memoize(parser, _grave_combiner, start, pos, perr)
fail:
	return _memoize(parser, _grave_combiner, start, -1, perr)
}

func _grave_combinerNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_grave_combiner]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _grave_combiner}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "grave_combiner"}
	// "̀"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̀" {
		goto fail
	}
	node.Kids = append(node.Kids, _leaf(parser, pos, pos+2))
	pos += 2
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _grave_combinerFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _grave_combiner, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "grave_combiner",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _grave_combiner}
	// "̀"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̀" {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "\"̀\"",
			})
		}
		goto fail
	}
	pos += 2
	failure.Kids = nil
	parser.fail[key] = failure
	return pos, failure
fail:
	failure.Kids = nil
	failure.Want = "◌̀"
	parser.fail[key] = failure
	return -1, failure
}

func _grave_combinerAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_grave_combiner]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _grave_combiner}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// "̀"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̀" {
		goto fail
	}
	node = parser.text[pos : pos+2]
	pos += 2
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _preposition_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _preposition_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [\\6]
	if r, w := _next(parser, pos); r != '\\' && r != '6' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _preposition_tone, start, pos, perr)
fail:
	return _memoize(parser, _preposition_tone, start, -1, perr)
}

func _preposition_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_preposition_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _preposition_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "preposition_tone"}
	// [\\6]
	if r, w := _next(parser, pos); r != '\\' && r != '6' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _preposition_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _preposition_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "preposition_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _preposition_tone}
	// [\\6]
	if r, w := _next(parser, pos); r != '\\' && r != '6' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[\\\\6]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _preposition_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_preposition_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _preposition_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [\\6]
	if r, w := _next(parser, pos); r != '\\' && r != '6' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ãAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ã, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ãÃ]/[aA] (tilde_combiner/adverb_tone)
	{
		pos2 := pos
		// [ãÃ]
		if r, w := _next(parser, pos); r != 'ã' && r != 'Ã' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (tilde_combiner/adverb_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (tilde_combiner/adverb_tone)
		// tilde_combiner/adverb_tone
		{
			pos8 := pos
			// tilde_combiner
			if !_accept(parser, _tilde_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// adverb_tone
			if !_accept(parser, _adverb_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ã, start, pos, perr)
fail:
	return _memoize(parser, _ã, start, -1, perr)
}

func _ãNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ã]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ã}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ã"}
	// [ãÃ]/[aA] (tilde_combiner/adverb_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ãÃ]
		if r, w := _next(parser, pos); r != 'ã' && r != 'Ã' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [aA] (tilde_combiner/adverb_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (tilde_combiner/adverb_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// tilde_combiner/adverb_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// tilde_combiner
				if !_node(parser, _tilde_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// adverb_tone
				if !_node(parser, _adverb_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ãFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ã, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ã",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ã}
	// [ãÃ]/[aA] (tilde_combiner/adverb_tone)
	{
		pos2 := pos
		// [ãÃ]
		if r, w := _next(parser, pos); r != 'ã' && r != 'Ã' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ãÃ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (tilde_combiner/adverb_tone)
		// [aA]
		if r, w := _next(parser, pos); r != 'a' && r != 'A' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[aA]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (tilde_combiner/adverb_tone)
		// tilde_combiner/adverb_tone
		{
			pos8 := pos
			// tilde_combiner
			if !_fail(parser, _tilde_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// adverb_tone
			if !_fail(parser, _adverb_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ãAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ã]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ã}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ãÃ]/[aA] (tilde_combiner/adverb_tone)
	{
		pos2 := pos
		// [ãÃ]
		if r, w := _next(parser, pos); r != 'ã' && r != 'Ã' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [aA] (tilde_combiner/adverb_tone)
		{
			var node5 string
			// [aA]
			if r, w := _next(parser, pos); r != 'a' && r != 'A' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (tilde_combiner/adverb_tone)
			// tilde_combiner/adverb_tone
			{
				pos8 := pos
				// tilde_combiner
				if p, n := _tilde_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// adverb_tone
				if p, n := _adverb_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ũAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ũ, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ũŨ]/[uU] (tilde_combiner/adverb_tone)
	{
		pos2 := pos
		// [ũŨ]
		if r, w := _next(parser, pos); r != 'ũ' && r != 'Ũ' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (tilde_combiner/adverb_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (tilde_combiner/adverb_tone)
		// tilde_combiner/adverb_tone
		{
			pos8 := pos
			// tilde_combiner
			if !_accept(parser, _tilde_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// adverb_tone
			if !_accept(parser, _adverb_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ũ, start, pos, perr)
fail:
	return _memoize(parser, _ũ, start, -1, perr)
}

func _ũNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ũ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ũ}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ũ"}
	// [ũŨ]/[uU] (tilde_combiner/adverb_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ũŨ]
		if r, w := _next(parser, pos); r != 'ũ' && r != 'Ũ' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [uU] (tilde_combiner/adverb_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (tilde_combiner/adverb_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// tilde_combiner/adverb_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// tilde_combiner
				if !_node(parser, _tilde_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// adverb_tone
				if !_node(parser, _adverb_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ũFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ũ, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ũ",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ũ}
	// [ũŨ]/[uU] (tilde_combiner/adverb_tone)
	{
		pos2 := pos
		// [ũŨ]
		if r, w := _next(parser, pos); r != 'ũ' && r != 'Ũ' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ũŨ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (tilde_combiner/adverb_tone)
		// [uU]
		if r, w := _next(parser, pos); r != 'u' && r != 'U' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[uU]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (tilde_combiner/adverb_tone)
		// tilde_combiner/adverb_tone
		{
			pos8 := pos
			// tilde_combiner
			if !_fail(parser, _tilde_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// adverb_tone
			if !_fail(parser, _adverb_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ũAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ũ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ũ}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ũŨ]/[uU] (tilde_combiner/adverb_tone)
	{
		pos2 := pos
		// [ũŨ]
		if r, w := _next(parser, pos); r != 'ũ' && r != 'Ũ' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [uU] (tilde_combiner/adverb_tone)
		{
			var node5 string
			// [uU]
			if r, w := _next(parser, pos); r != 'u' && r != 'U' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (tilde_combiner/adverb_tone)
			// tilde_combiner/adverb_tone
			{
				pos8 := pos
				// tilde_combiner
				if p, n := _tilde_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// adverb_tone
				if p, n := _adverb_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ĩAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ĩ, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ĩĨ]/[iI] (tilde_combiner/adverb_tone)
	{
		pos2 := pos
		// [ĩĨ]
		if r, w := _next(parser, pos); r != 'ĩ' && r != 'Ĩ' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (tilde_combiner/adverb_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (tilde_combiner/adverb_tone)
		// tilde_combiner/adverb_tone
		{
			pos8 := pos
			// tilde_combiner
			if !_accept(parser, _tilde_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// adverb_tone
			if !_accept(parser, _adverb_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ĩ, start, pos, perr)
fail:
	return _memoize(parser, _ĩ, start, -1, perr)
}

func _ĩNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ĩ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ĩ}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ĩ"}
	// [ĩĨ]/[iI] (tilde_combiner/adverb_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ĩĨ]
		if r, w := _next(parser, pos); r != 'ĩ' && r != 'Ĩ' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [iI] (tilde_combiner/adverb_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (tilde_combiner/adverb_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// tilde_combiner/adverb_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// tilde_combiner
				if !_node(parser, _tilde_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// adverb_tone
				if !_node(parser, _adverb_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ĩFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ĩ, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ĩ",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ĩ}
	// [ĩĨ]/[iI] (tilde_combiner/adverb_tone)
	{
		pos2 := pos
		// [ĩĨ]
		if r, w := _next(parser, pos); r != 'ĩ' && r != 'Ĩ' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ĩĨ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (tilde_combiner/adverb_tone)
		// [iI]
		if r, w := _next(parser, pos); r != 'i' && r != 'I' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[iI]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (tilde_combiner/adverb_tone)
		// tilde_combiner/adverb_tone
		{
			pos8 := pos
			// tilde_combiner
			if !_fail(parser, _tilde_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// adverb_tone
			if !_fail(parser, _adverb_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ĩAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ĩ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ĩ}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ĩĨ]/[iI] (tilde_combiner/adverb_tone)
	{
		pos2 := pos
		// [ĩĨ]
		if r, w := _next(parser, pos); r != 'ĩ' && r != 'Ĩ' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [iI] (tilde_combiner/adverb_tone)
		{
			var node5 string
			// [iI]
			if r, w := _next(parser, pos); r != 'i' && r != 'I' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (tilde_combiner/adverb_tone)
			// tilde_combiner/adverb_tone
			{
				pos8 := pos
				// tilde_combiner
				if p, n := _tilde_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// adverb_tone
				if p, n := _adverb_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _õAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _õ, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [õÕ]/[oO] (tilde_combiner/adverb_tone)
	{
		pos2 := pos
		// [õÕ]
		if r, w := _next(parser, pos); r != 'õ' && r != 'Õ' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (tilde_combiner/adverb_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (tilde_combiner/adverb_tone)
		// tilde_combiner/adverb_tone
		{
			pos8 := pos
			// tilde_combiner
			if !_accept(parser, _tilde_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// adverb_tone
			if !_accept(parser, _adverb_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _õ, start, pos, perr)
fail:
	return _memoize(parser, _õ, start, -1, perr)
}

func _õNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_õ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _õ}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "õ"}
	// [õÕ]/[oO] (tilde_combiner/adverb_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [õÕ]
		if r, w := _next(parser, pos); r != 'õ' && r != 'Õ' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [oO] (tilde_combiner/adverb_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (tilde_combiner/adverb_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// tilde_combiner/adverb_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// tilde_combiner
				if !_node(parser, _tilde_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// adverb_tone
				if !_node(parser, _adverb_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _õFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _õ, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "õ",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _õ}
	// [õÕ]/[oO] (tilde_combiner/adverb_tone)
	{
		pos2 := pos
		// [õÕ]
		if r, w := _next(parser, pos); r != 'õ' && r != 'Õ' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[õÕ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (tilde_combiner/adverb_tone)
		// [oO]
		if r, w := _next(parser, pos); r != 'o' && r != 'O' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[oO]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (tilde_combiner/adverb_tone)
		// tilde_combiner/adverb_tone
		{
			pos8 := pos
			// tilde_combiner
			if !_fail(parser, _tilde_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// adverb_tone
			if !_fail(parser, _adverb_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _õAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_õ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _õ}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [õÕ]/[oO] (tilde_combiner/adverb_tone)
	{
		pos2 := pos
		// [õÕ]
		if r, w := _next(parser, pos); r != 'õ' && r != 'Õ' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [oO] (tilde_combiner/adverb_tone)
		{
			var node5 string
			// [oO]
			if r, w := _next(parser, pos); r != 'o' && r != 'O' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (tilde_combiner/adverb_tone)
			// tilde_combiner/adverb_tone
			{
				pos8 := pos
				// tilde_combiner
				if p, n := _tilde_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// adverb_tone
				if p, n := _adverb_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _ẽAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _ẽ, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ẽẼ]/[eE] (tilde_combiner/adverb_tone)
	{
		pos2 := pos
		// [ẽẼ]
		if r, w := _next(parser, pos); r != 'ẽ' && r != 'Ẽ' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (tilde_combiner/adverb_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			perr = _max(perr, pos)
			goto fail4
		} else {
			pos += w
		}
		// (tilde_combiner/adverb_tone)
		// tilde_combiner/adverb_tone
		{
			pos8 := pos
			// tilde_combiner
			if !_accept(parser, _tilde_combinerAccepts, &pos, &perr) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// adverb_tone
			if !_accept(parser, _adverb_toneAccepts, &pos, &perr) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	return _memoize(parser, _ẽ, start, pos, perr)
fail:
	return _memoize(parser, _ẽ, start, -1, perr)
}

func _ẽNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_ẽ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ẽ}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "ẽ"}
	// [ẽẼ]/[eE] (tilde_combiner/adverb_tone)
	{
		pos2 := pos
		nkids1 := len(node.Kids)
		// [ẽẼ]
		if r, w := _next(parser, pos); r != 'ẽ' && r != 'Ẽ' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		goto ok0
	fail3:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		// [eE] (tilde_combiner/adverb_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			goto fail4
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		// (tilde_combiner/adverb_tone)
		{
			nkids6 := len(node.Kids)
			pos07 := pos
			// tilde_combiner/adverb_tone
			{
				pos10 := pos
				nkids9 := len(node.Kids)
				// tilde_combiner
				if !_node(parser, _tilde_combinerNode, node, &pos) {
					goto fail11
				}
				goto ok8
			fail11:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				// adverb_tone
				if !_node(parser, _adverb_toneNode, node, &pos) {
					goto fail12
				}
				goto ok8
			fail12:
				node.Kids = node.Kids[:nkids9]
				pos = pos10
				goto fail4
			ok8:
			}
			sub := _sub(parser, pos07, pos, node.Kids[nkids6:])
			node.Kids = append(node.Kids[:nkids6], sub)
		}
		goto ok0
	fail4:
		node.Kids = node.Kids[:nkids1]
		pos = pos2
		goto fail
	ok0:
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _ẽFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _ẽ, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "ẽ",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _ẽ}
	// [ẽẼ]/[eE] (tilde_combiner/adverb_tone)
	{
		pos2 := pos
		// [ẽẼ]
		if r, w := _next(parser, pos); r != 'ẽ' && r != 'Ẽ' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[ẽẼ]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (tilde_combiner/adverb_tone)
		// [eE]
		if r, w := _next(parser, pos); r != 'e' && r != 'E' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[eE]",
				})
			}
			goto fail4
		} else {
			pos += w
		}
		// (tilde_combiner/adverb_tone)
		// tilde_combiner/adverb_tone
		{
			pos8 := pos
			// tilde_combiner
			if !_fail(parser, _tilde_combinerFail, errPos, failure, &pos) {
				goto fail9
			}
			goto ok6
		fail9:
			pos = pos8
			// adverb_tone
			if !_fail(parser, _adverb_toneFail, errPos, failure, &pos) {
				goto fail10
			}
			goto ok6
		fail10:
			pos = pos8
			goto fail4
		ok6:
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _ẽAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_ẽ]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _ẽ}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ẽẼ]/[eE] (tilde_combiner/adverb_tone)
	{
		pos2 := pos
		// [ẽẼ]
		if r, w := _next(parser, pos); r != 'ẽ' && r != 'Ẽ' {
			goto fail3
		} else {
			node = parser.text[pos : pos+w]
			pos += w
		}
		goto ok0
	fail3:
		pos = pos2
		// [eE] (tilde_combiner/adverb_tone)
		{
			var node5 string
			// [eE]
			if r, w := _next(parser, pos); r != 'e' && r != 'E' {
				goto fail4
			} else {
				node5 = parser.text[pos : pos+w]
				pos += w
			}
			node += node5
			// (tilde_combiner/adverb_tone)
			// tilde_combiner/adverb_tone
			{
				pos8 := pos
				// tilde_combiner
				if p, n := _tilde_combinerAction(parser, pos); n == nil {
					goto fail9
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail9:
				pos = pos8
				// adverb_tone
				if p, n := _adverb_toneAction(parser, pos); n == nil {
					goto fail10
				} else {
					node5 = *n
					pos = p
				}
				goto ok6
			fail10:
				pos = pos8
				goto fail4
			ok6:
			}
			node += node5
		}
		goto ok0
	fail4:
		pos = pos2
		goto fail
	ok0:
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _tilde_combinerAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _tilde_combiner, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// "̃"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̃" {
		perr = _max(perr, pos)
		goto fail
	}
	pos += 2
	perr = start
	return _memoize(parser, _tilde_combiner, start, pos, perr)
fail:
	return _memoize(parser, _tilde_combiner, start, -1, perr)
}

func _tilde_combinerNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_tilde_combiner]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _tilde_combiner}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "tilde_combiner"}
	// "̃"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̃" {
		goto fail
	}
	node.Kids = append(node.Kids, _leaf(parser, pos, pos+2))
	pos += 2
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _tilde_combinerFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _tilde_combiner, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "tilde_combiner",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _tilde_combiner}
	// "̃"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̃" {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "\"̃\"",
			})
		}
		goto fail
	}
	pos += 2
	failure.Kids = nil
	parser.fail[key] = failure
	return pos, failure
fail:
	failure.Kids = nil
	failure.Want = "◌̃"
	parser.fail[key] = failure
	return -1, failure
}

func _tilde_combinerAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_tilde_combiner]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _tilde_combiner}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// "̃"
	if len(parser.text[pos:]) < 2 || parser.text[pos:pos+2] != "̃" {
		goto fail
	}
	node = parser.text[pos : pos+2]
	pos += 2
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _adverb_toneAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _adverb_tone, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [~7]
	if r, w := _next(parser, pos); r != '~' && r != '7' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _adverb_tone, start, pos, perr)
fail:
	return _memoize(parser, _adverb_tone, start, -1, perr)
}

func _adverb_toneNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_adverb_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _adverb_tone}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "adverb_tone"}
	// [~7]
	if r, w := _next(parser, pos); r != '~' && r != '7' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _adverb_toneFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _adverb_tone, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "adverb_tone",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _adverb_tone}
	// [~7]
	if r, w := _next(parser, pos); r != '~' && r != '7' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[~7]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _adverb_toneAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_adverb_tone]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _adverb_tone}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [~7]
	if r, w := _next(parser, pos); r != '~' && r != '7' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _aAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _a, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [aA]
	if r, w := _next(parser, pos); r != 'a' && r != 'A' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _a, start, pos, perr)
fail:
	return _memoize(parser, _a, start, -1, perr)
}

func _aNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_a]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _a}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "a"}
	// [aA]
	if r, w := _next(parser, pos); r != 'a' && r != 'A' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _aFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _a, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "a",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _a}
	// [aA]
	if r, w := _next(parser, pos); r != 'a' && r != 'A' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[aA]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _aAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_a]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _a}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [aA]
	if r, w := _next(parser, pos); r != 'a' && r != 'A' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _bAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _b, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [bB]
	if r, w := _next(parser, pos); r != 'b' && r != 'B' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _b, start, pos, perr)
fail:
	return _memoize(parser, _b, start, -1, perr)
}

func _bNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_b]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _b}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "b"}
	// [bB]
	if r, w := _next(parser, pos); r != 'b' && r != 'B' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _bFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _b, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "b",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _b}
	// [bB]
	if r, w := _next(parser, pos); r != 'b' && r != 'B' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[bB]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _bAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_b]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _b}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [bB]
	if r, w := _next(parser, pos); r != 'b' && r != 'B' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _cAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _c, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [cC]
	if r, w := _next(parser, pos); r != 'c' && r != 'C' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _c, start, pos, perr)
fail:
	return _memoize(parser, _c, start, -1, perr)
}

func _cNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_c]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _c}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "c"}
	// [cC]
	if r, w := _next(parser, pos); r != 'c' && r != 'C' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _cFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _c, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "c",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _c}
	// [cC]
	if r, w := _next(parser, pos); r != 'c' && r != 'C' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[cC]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _cAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_c]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _c}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [cC]
	if r, w := _next(parser, pos); r != 'c' && r != 'C' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _dAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _d, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [dD]
	if r, w := _next(parser, pos); r != 'd' && r != 'D' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _d, start, pos, perr)
fail:
	return _memoize(parser, _d, start, -1, perr)
}

func _dNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_d]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _d}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "d"}
	// [dD]
	if r, w := _next(parser, pos); r != 'd' && r != 'D' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _dFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _d, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "d",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _d}
	// [dD]
	if r, w := _next(parser, pos); r != 'd' && r != 'D' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[dD]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _dAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_d]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _d}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [dD]
	if r, w := _next(parser, pos); r != 'd' && r != 'D' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _eAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _e, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [eE]
	if r, w := _next(parser, pos); r != 'e' && r != 'E' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _e, start, pos, perr)
fail:
	return _memoize(parser, _e, start, -1, perr)
}

func _eNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_e]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _e}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "e"}
	// [eE]
	if r, w := _next(parser, pos); r != 'e' && r != 'E' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _eFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _e, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "e",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _e}
	// [eE]
	if r, w := _next(parser, pos); r != 'e' && r != 'E' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[eE]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _eAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_e]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _e}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [eE]
	if r, w := _next(parser, pos); r != 'e' && r != 'E' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _fAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _f, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [fF]
	if r, w := _next(parser, pos); r != 'f' && r != 'F' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _f, start, pos, perr)
fail:
	return _memoize(parser, _f, start, -1, perr)
}

func _fNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_f]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _f}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "f"}
	// [fF]
	if r, w := _next(parser, pos); r != 'f' && r != 'F' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _fFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _f, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "f",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _f}
	// [fF]
	if r, w := _next(parser, pos); r != 'f' && r != 'F' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[fF]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _fAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_f]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _f}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [fF]
	if r, w := _next(parser, pos); r != 'f' && r != 'F' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _gAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _g, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [gG]
	if r, w := _next(parser, pos); r != 'g' && r != 'G' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _g, start, pos, perr)
fail:
	return _memoize(parser, _g, start, -1, perr)
}

func _gNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_g]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _g}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "g"}
	// [gG]
	if r, w := _next(parser, pos); r != 'g' && r != 'G' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _gFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _g, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "g",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _g}
	// [gG]
	if r, w := _next(parser, pos); r != 'g' && r != 'G' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[gG]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _gAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_g]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _g}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [gG]
	if r, w := _next(parser, pos); r != 'g' && r != 'G' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _hAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _h, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [hH]
	if r, w := _next(parser, pos); r != 'h' && r != 'H' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _h, start, pos, perr)
fail:
	return _memoize(parser, _h, start, -1, perr)
}

func _hNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_h]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _h}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "h"}
	// [hH]
	if r, w := _next(parser, pos); r != 'h' && r != 'H' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _hFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _h, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "h",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _h}
	// [hH]
	if r, w := _next(parser, pos); r != 'h' && r != 'H' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[hH]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _hAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_h]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _h}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [hH]
	if r, w := _next(parser, pos); r != 'h' && r != 'H' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _iAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _i, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [ıiI]
	if r, w := _next(parser, pos); r != 'ı' && r != 'i' && r != 'I' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _i, start, pos, perr)
fail:
	return _memoize(parser, _i, start, -1, perr)
}

func _iNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_i]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _i}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "i"}
	// [ıiI]
	if r, w := _next(parser, pos); r != 'ı' && r != 'i' && r != 'I' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _iFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _i, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "i",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _i}
	// [ıiI]
	if r, w := _next(parser, pos); r != 'ı' && r != 'i' && r != 'I' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[ıiI]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _iAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_i]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _i}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [ıiI]
	if r, w := _next(parser, pos); r != 'ı' && r != 'i' && r != 'I' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _jAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _j, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [jJ]
	if r, w := _next(parser, pos); r != 'j' && r != 'J' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _j, start, pos, perr)
fail:
	return _memoize(parser, _j, start, -1, perr)
}

func _jNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_j]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _j}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "j"}
	// [jJ]
	if r, w := _next(parser, pos); r != 'j' && r != 'J' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _jFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _j, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "j",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _j}
	// [jJ]
	if r, w := _next(parser, pos); r != 'j' && r != 'J' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[jJ]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _jAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_j]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _j}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [jJ]
	if r, w := _next(parser, pos); r != 'j' && r != 'J' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _kAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _k, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [kK]
	if r, w := _next(parser, pos); r != 'k' && r != 'K' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _k, start, pos, perr)
fail:
	return _memoize(parser, _k, start, -1, perr)
}

func _kNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_k]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _k}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "k"}
	// [kK]
	if r, w := _next(parser, pos); r != 'k' && r != 'K' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _kFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _k, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "k",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _k}
	// [kK]
	if r, w := _next(parser, pos); r != 'k' && r != 'K' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[kK]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _kAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_k]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _k}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [kK]
	if r, w := _next(parser, pos); r != 'k' && r != 'K' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _lAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _l, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [lL]
	if r, w := _next(parser, pos); r != 'l' && r != 'L' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _l, start, pos, perr)
fail:
	return _memoize(parser, _l, start, -1, perr)
}

func _lNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_l]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _l}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "l"}
	// [lL]
	if r, w := _next(parser, pos); r != 'l' && r != 'L' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _lFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _l, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "l",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _l}
	// [lL]
	if r, w := _next(parser, pos); r != 'l' && r != 'L' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[lL]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _lAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_l]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _l}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [lL]
	if r, w := _next(parser, pos); r != 'l' && r != 'L' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _mAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _m, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [mM]
	if r, w := _next(parser, pos); r != 'm' && r != 'M' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _m, start, pos, perr)
fail:
	return _memoize(parser, _m, start, -1, perr)
}

func _mNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_m]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _m}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "m"}
	// [mM]
	if r, w := _next(parser, pos); r != 'm' && r != 'M' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _mFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _m, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "m",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _m}
	// [mM]
	if r, w := _next(parser, pos); r != 'm' && r != 'M' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[mM]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _mAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_m]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _m}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [mM]
	if r, w := _next(parser, pos); r != 'm' && r != 'M' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _nAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _n, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [nN]
	if r, w := _next(parser, pos); r != 'n' && r != 'N' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _n, start, pos, perr)
fail:
	return _memoize(parser, _n, start, -1, perr)
}

func _nNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_n]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _n}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "n"}
	// [nN]
	if r, w := _next(parser, pos); r != 'n' && r != 'N' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _nFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _n, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "n",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _n}
	// [nN]
	if r, w := _next(parser, pos); r != 'n' && r != 'N' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[nN]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _nAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_n]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _n}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [nN]
	if r, w := _next(parser, pos); r != 'n' && r != 'N' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _oAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _o, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [oO]
	if r, w := _next(parser, pos); r != 'o' && r != 'O' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _o, start, pos, perr)
fail:
	return _memoize(parser, _o, start, -1, perr)
}

func _oNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_o]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _o}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "o"}
	// [oO]
	if r, w := _next(parser, pos); r != 'o' && r != 'O' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _oFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _o, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "o",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _o}
	// [oO]
	if r, w := _next(parser, pos); r != 'o' && r != 'O' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[oO]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _oAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_o]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _o}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [oO]
	if r, w := _next(parser, pos); r != 'o' && r != 'O' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _pAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _p, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [pP]
	if r, w := _next(parser, pos); r != 'p' && r != 'P' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _p, start, pos, perr)
fail:
	return _memoize(parser, _p, start, -1, perr)
}

func _pNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_p]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _p}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "p"}
	// [pP]
	if r, w := _next(parser, pos); r != 'p' && r != 'P' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _pFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _p, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "p",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _p}
	// [pP]
	if r, w := _next(parser, pos); r != 'p' && r != 'P' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[pP]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _pAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_p]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _p}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [pP]
	if r, w := _next(parser, pos); r != 'p' && r != 'P' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _qAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _q, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [qQ]
	if r, w := _next(parser, pos); r != 'q' && r != 'Q' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _q, start, pos, perr)
fail:
	return _memoize(parser, _q, start, -1, perr)
}

func _qNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_q]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _q}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "q"}
	// [qQ]
	if r, w := _next(parser, pos); r != 'q' && r != 'Q' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _qFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _q, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "q",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _q}
	// [qQ]
	if r, w := _next(parser, pos); r != 'q' && r != 'Q' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[qQ]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _qAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_q]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _q}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [qQ]
	if r, w := _next(parser, pos); r != 'q' && r != 'Q' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _rAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _r, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [rR]
	if r, w := _next(parser, pos); r != 'r' && r != 'R' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _r, start, pos, perr)
fail:
	return _memoize(parser, _r, start, -1, perr)
}

func _rNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_r]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _r}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "r"}
	// [rR]
	if r, w := _next(parser, pos); r != 'r' && r != 'R' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _rFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _r, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "r",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _r}
	// [rR]
	if r, w := _next(parser, pos); r != 'r' && r != 'R' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[rR]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _rAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_r]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _r}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [rR]
	if r, w := _next(parser, pos); r != 'r' && r != 'R' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _sAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _s, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [sS]
	if r, w := _next(parser, pos); r != 's' && r != 'S' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _s, start, pos, perr)
fail:
	return _memoize(parser, _s, start, -1, perr)
}

func _sNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_s]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _s}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "s"}
	// [sS]
	if r, w := _next(parser, pos); r != 's' && r != 'S' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _sFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _s, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "s",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _s}
	// [sS]
	if r, w := _next(parser, pos); r != 's' && r != 'S' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[sS]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _sAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_s]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _s}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [sS]
	if r, w := _next(parser, pos); r != 's' && r != 'S' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _tAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _t, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [tT]
	if r, w := _next(parser, pos); r != 't' && r != 'T' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _t, start, pos, perr)
fail:
	return _memoize(parser, _t, start, -1, perr)
}

func _tNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_t]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _t}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "t"}
	// [tT]
	if r, w := _next(parser, pos); r != 't' && r != 'T' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _tFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _t, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "t",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _t}
	// [tT]
	if r, w := _next(parser, pos); r != 't' && r != 'T' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[tT]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _tAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_t]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _t}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [tT]
	if r, w := _next(parser, pos); r != 't' && r != 'T' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _uAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _u, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [uU]
	if r, w := _next(parser, pos); r != 'u' && r != 'U' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _u, start, pos, perr)
fail:
	return _memoize(parser, _u, start, -1, perr)
}

func _uNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_u]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _u}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "u"}
	// [uU]
	if r, w := _next(parser, pos); r != 'u' && r != 'U' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _uFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _u, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "u",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _u}
	// [uU]
	if r, w := _next(parser, pos); r != 'u' && r != 'U' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[uU]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _uAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_u]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _u}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [uU]
	if r, w := _next(parser, pos); r != 'u' && r != 'U' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _wAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _w, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [wW]
	if r, w := _next(parser, pos); r != 'w' && r != 'W' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _w, start, pos, perr)
fail:
	return _memoize(parser, _w, start, -1, perr)
}

func _wNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_w]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _w}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "w"}
	// [wW]
	if r, w := _next(parser, pos); r != 'w' && r != 'W' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _wFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _w, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "w",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _w}
	// [wW]
	if r, w := _next(parser, pos); r != 'w' && r != 'W' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[wW]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _wAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_w]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _w}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [wW]
	if r, w := _next(parser, pos); r != 'w' && r != 'W' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _yAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _y, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [yY]
	if r, w := _next(parser, pos); r != 'y' && r != 'Y' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	return _memoize(parser, _y, start, pos, perr)
fail:
	return _memoize(parser, _y, start, -1, perr)
}

func _yNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_y]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _y}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "y"}
	// [yY]
	if r, w := _next(parser, pos); r != 'y' && r != 'Y' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _yFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _y, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "y",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _y}
	// [yY]
	if r, w := _next(parser, pos); r != 'y' && r != 'Y' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[yY]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	parser.fail[key] = failure
	return pos, failure
fail:
	parser.fail[key] = failure
	return -1, failure
}

func _yAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_y]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _y}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [yY]
	if r, w := _next(parser, pos); r != 'y' && r != 'Y' {
		goto fail
	} else {
		node = parser.text[pos : pos+w]
		pos += w
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _spacesAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _spaces, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// [\t\n\r! .,:]+
	// [\t\n\r! .,:]
	if r, w := _next(parser, pos); r != '\t' && r != '\n' && r != '\r' && r != '!' && r != ' ' && r != '.' && r != ',' && r != ':' {
		perr = _max(perr, pos)
		goto fail
	} else {
		pos += w
	}
	for {
		pos1 := pos
		// [\t\n\r! .,:]
		if r, w := _next(parser, pos); r != '\t' && r != '\n' && r != '\r' && r != '!' && r != ' ' && r != '.' && r != ',' && r != ':' {
			perr = _max(perr, pos)
			goto fail3
		} else {
			pos += w
		}
		continue
	fail3:
		pos = pos1
		break
	}
	perr = start
	return _memoize(parser, _spaces, start, pos, perr)
fail:
	return _memoize(parser, _spaces, start, -1, perr)
}

func _spacesNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_spaces]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _spaces}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "spaces"}
	// [\t\n\r! .,:]+
	// [\t\n\r! .,:]
	if r, w := _next(parser, pos); r != '\t' && r != '\n' && r != '\r' && r != '!' && r != ' ' && r != '.' && r != ',' && r != ':' {
		goto fail
	} else {
		node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
		pos += w
	}
	for {
		nkids0 := len(node.Kids)
		pos1 := pos
		// [\t\n\r! .,:]
		if r, w := _next(parser, pos); r != '\t' && r != '\n' && r != '\r' && r != '!' && r != ' ' && r != '.' && r != ',' && r != ':' {
			goto fail3
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		continue
	fail3:
		node.Kids = node.Kids[:nkids0]
		pos = pos1
		break
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _spacesFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _spaces, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "spaces",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _spaces}
	// [\t\n\r! .,:]+
	// [\t\n\r! .,:]
	if r, w := _next(parser, pos); r != '\t' && r != '\n' && r != '\r' && r != '!' && r != ' ' && r != '.' && r != ',' && r != ':' {
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "[\\t\\n\\r! .,:]",
			})
		}
		goto fail
	} else {
		pos += w
	}
	for {
		pos1 := pos
		// [\t\n\r! .,:]
		if r, w := _next(parser, pos); r != '\t' && r != '\n' && r != '\r' && r != '!' && r != ' ' && r != '.' && r != ',' && r != ':' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: "[\\t\\n\\r! .,:]",
				})
			}
			goto fail3
		} else {
			pos += w
		}
		continue
	fail3:
		pos = pos1
		break
	}
	failure.Kids = nil
	parser.fail[key] = failure
	return pos, failure
fail:
	failure.Kids = nil
	failure.Want = "space"
	parser.fail[key] = failure
	return -1, failure
}

func _spacesAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_spaces]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _spaces}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// [\t\n\r! .,:]+
	{
		var node2 string
		// [\t\n\r! .,:]
		if r, w := _next(parser, pos); r != '\t' && r != '\n' && r != '\r' && r != '!' && r != ' ' && r != '.' && r != ',' && r != ':' {
			goto fail
		} else {
			node2 = parser.text[pos : pos+w]
			pos += w
		}
		node += node2
	}
	for {
		pos1 := pos
		var node2 string
		// [\t\n\r! .,:]
		if r, w := _next(parser, pos); r != '\t' && r != '\n' && r != '\r' && r != '!' && r != ' ' && r != '.' && r != ',' && r != ':' {
			goto fail3
		} else {
			node2 = parser.text[pos : pos+w]
			pos += w
		}
		node += node2
		continue
	fail3:
		pos = pos1
		break
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}

func _EOFAccepts(parser *_Parser, start int) (deltaPos, deltaErr int) {
	if dp, de, ok := _memo(parser, _EOF, start); ok {
		return dp, de
	}
	pos, perr := start, -1
	// !.
	{
		pos1 := pos
		perr3 := perr
		// .
		if r, w := _next(parser, pos); w == 0 || r == '\uFFFD' {
			perr = _max(perr, pos)
			goto ok0
		} else {
			pos += w
		}
		pos = pos1
		perr = _max(perr3, pos)
		goto fail
	ok0:
		pos = pos1
		perr = perr3
	}
	perr = start
	return _memoize(parser, _EOF, start, pos, perr)
fail:
	return _memoize(parser, _EOF, start, -1, perr)
}

func _EOFNode(parser *_Parser, start int) (int, *peg.Node) {
	dp := parser.deltaPos[start][_EOF]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _EOF}
	node := parser.node[key]
	if node != nil {
		return start + int(dp-1), node
	}
	pos := start
	node = &peg.Node{Name: "EOF"}
	// !.
	{
		pos1 := pos
		nkids2 := len(node.Kids)
		// .
		if r, w := _next(parser, pos); w == 0 || r == '\uFFFD' {
			goto ok0
		} else {
			node.Kids = append(node.Kids, _leaf(parser, pos, pos+w))
			pos += w
		}
		pos = pos1
		node.Kids = node.Kids[:nkids2]
		goto fail
	ok0:
		pos = pos1
		node.Kids = node.Kids[:nkids2]
	}
	node.Text = parser.text[start:pos]
	parser.node[key] = node
	return pos, node
fail:
	return -1, nil
}

func _EOFFail(parser *_Parser, start, errPos int) (int, *peg.Fail) {
	pos, failure := _failMemo(parser, _EOF, start, errPos)
	if failure != nil {
		return pos, failure
	}
	failure = &peg.Fail{
		Name: "EOF",
		Pos:  int(start),
	}
	key := _key{start: start, rule: _EOF}
	// !.
	{
		pos1 := pos
		nkids2 := len(failure.Kids)
		// .
		if r, w := _next(parser, pos); w == 0 || r == '\uFFFD' {
			if pos >= errPos {
				failure.Kids = append(failure.Kids, &peg.Fail{
					Pos:  int(pos),
					Want: ".",
				})
			}
			goto ok0
		} else {
			pos += w
		}
		pos = pos1
		failure.Kids = failure.Kids[:nkids2]
		if pos >= errPos {
			failure.Kids = append(failure.Kids, &peg.Fail{
				Pos:  int(pos),
				Want: "!.",
			})
		}
		goto fail
	ok0:
		pos = pos1
		failure.Kids = failure.Kids[:nkids2]
	}
	failure.Kids = nil
	parser.fail[key] = failure
	return pos, failure
fail:
	failure.Kids = nil
	failure.Want = "EOF"
	parser.fail[key] = failure
	return -1, failure
}

func _EOFAction(parser *_Parser, start int) (int, *string) {
	dp := parser.deltaPos[start][_EOF]
	if dp < 0 {
		return -1, nil
	}
	key := _key{start: start, rule: _EOF}
	n := parser.act[key]
	if n != nil {
		n := n.(string)
		return start + int(dp-1), &n
	}
	var node string
	pos := start
	// !.
	{
		pos1 := pos
		// .
		if r, w := _next(parser, pos); w == 0 || r == '\uFFFD' {
			goto ok0
		} else {
			pos += w
		}
		pos = pos1
		goto fail
	ok0:
		pos = pos1
		node = ""
	}
	parser.act[key] = node
	return pos, &node
fail:
	return -1, nil
}
